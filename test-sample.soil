------------------------------------------------------------------------------
--! @authors: Jason Hunter, Kayvia Harriott, Tashna-Gail Williams
--! Created on: 2021-11-02
--! @version: 0.4.8
--! Last Updated: 2021-12-01 00:45:22
------------------------------------------------------------------------------

-- PLEASE DON'T EDIT THIS FILE DIRECTLY, COPY AND PASTE IT AND WORK ON THAT
-- WHEN TESTING. DON'T COMMIT YOUR CUSTOM TEST FILE DIRECTLY EITHER. IF YOU
-- CREATED ANE NEW OBJECTS THAT COULD BE USEFUL FOR TESTING YOU MAY ADD THE
-- CHANGES HERE BUT OTHERWISE THIS IS JUST A BASE FILE TO MAKE YOUR PERSONAL
-- TESTS FROM

reset

!new Scrumble ('scrumble')

!new Clock('clk')
!insert (scrumble, clk) into ScrumbleClock
!new DateTime('rightNow')
!rightNow.initialise(2021, 10, 22, 12, 59, 59)
!insert (rightNow, rightNow) into CurrentTime
!clk.time := rightNow

!new MatchFactory('mFactory')
!insert (scrumble, mFactory) into ScrumbleMatchFactory

!new MatchBuilder('mBuilder')
!insert (scrumble, mBuilder) into ScrumbleMatchBuilder
!insert (mFactory, mBuilder) into MatchFactoryBuilder

!new Leaderboard('lboard')
!insert (scrumble, lboard) into ScrumbleLboard
!insert (lboard, lboard) into OnlyLboard

!new Queue('rankedQ')
!insert (scrumble, rankedQ) into ScrumbleQueues
!rankedQ.init(#RANKED, true)
!new Queue('unrankedTimedQ')
!insert (scrumble, unrankedTimedQ) into ScrumbleQueues
!unrankedTimedQ.init(#UNRANKED, true)
!new Queue('unrankedUntimedQ')
!insert (scrumble, unrankedUntimedQ) into ScrumbleQueues
!unrankedUntimedQ.init(#UNRANKED, false)

--------Dictionary

!new Dictionary('dict')
!insert (scrumble, dict) into ScrumbleDict
!insert (dict, dict) into OnlyDict

!new Word('word')
!spelling := Sequence{'W', 'O', 'R', 'D'}
!word.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (word, l) into Spelling; end;
!insert (dict, word) into ValidWord

!new Word('door')
!spelling := Sequence{'D', 'O', 'O', 'R'}
!door.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (door, l) into Spelling; end;
!insert (dict, door) into ValidWord

!new Word('stream')
!spelling := Sequence{'S', 'T', 'R', 'E', 'A', 'M'}
!stream.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (stream, l) into Spelling; end;
!insert (dict, stream) into ValidWord

!new Word('ate')
!spelling := Sequence{'A', 'T', 'E'}
!ate.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (ate, l) into Spelling; end;
!insert (dict, ate) into ValidWord

!new Word('remote')
!spelling := Sequence{'R', 'E', 'M', 'O', 'T', 'E'}
!remote.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (remote, l) into Spelling; end;
!insert (dict, remote) into ValidWord

!new Word('axe')
!spelling := Sequence{'A', 'X', 'E'}
!axe.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (axe, l) into Spelling; end;
!insert (dict, axe) into ValidWord

!new Word('jeering')
!spelling := Sequence{'J', 'E', 'E', 'R', 'I', 'N', 'G'}
!jeering.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (jeering, l) into Spelling; end;
!insert (dict, jeering) into ValidWord

!new Word('ea')
!spelling := Sequence{'E', 'A'}
!ea.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (ea, l) into Spelling; end;
!insert (dict, ea) into ValidWord

!new Word('ex')
!spelling := Sequence{'E', 'X'}
!ex.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (ex, l) into Spelling; end;
!insert (dict, ex) into ValidWord

!new Word('subnet')
!spelling := Sequence{'S', 'U', 'B', 'N', 'E', 'T'}
!subnet.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (subnet, l) into Spelling; end;
!insert (dict, subnet) into ValidWord

!new Word('remotes')
!spelling := Sequence{'R', 'E', 'M', 'O', 'T', 'E', 'S'}
!remotes.category := #NONE
!for c in spelling do l := new Letter(); l.letter := c; insert (remotes, l) into Spelling; end;
!insert (dict, remotes) into ValidWord

--------Users

!new User('u1')
!u1.id := 'u1'
!insert (scrumble, u1) into ScrumbleUsers
!new DateTime('u1DoB')
!insert (u1DoB, rightNow) into CurrentTime
!new Player('player1')
!insert (u1, player1) into UserRole
!player1.initialise('TestUser1', 'test1@email.com', u1DoB)

!player1.openApp()

!new User('u2')
!u2.id := 'u2'
!insert (scrumble, u2) into ScrumbleUsers
!new DateTime('u2DoB')
!insert (u2DoB, rightNow) into CurrentTime
!new Player('player2')
!insert (u2, player2) into UserRole
!player2.initialise('TestUser2', 'test2@email.com', u2DoB)

!player2.openApp()

--------Friend Request between Players 1 and 2

!new DateTime('frReq1SentDate')
!insert (frReq1SentDate, rightNow) into CurrentTime
!frReq1SentDate.initialise(2021, 10, 20, 18, 05, 13)

!new DateTime('frReq1AddrDate')
!insert (frReq1AddrDate, rightNow) into CurrentTime
!frReq1AddrDate.initialise(2021, 10, 21, 6, 05, 21)

!new Period('frReq1Period')
!frReq1Period.addStart(frReq1AddrDate)

!new Request('frReq1P1P2')
!frReq1P1P2.id := 'frReq1'
!frReq1P1P2.type := #FRIEND
!frReq1P1P2.status := #ACCEPTED
!frReq1P1P2.sentDate := frReq1SentDate
!frReq1P1P2.activePeriod := frReq1Period
!insert (player1,frReq1P1P2) into SentRequest
!insert (player2,frReq1P1P2) into RecievedRequest

!insert (player1, player2) into FriendList
!insert (player2, player1) into FriendList

--------Chat between Players 1 and 2

!new Chat('chatp1p2')
!new ChatState('chat1p1') between (chatp1p2,player1)
!chat1p1.status := #OPEN
!new ChatState('chat1p2') between (chatp1p2,player2)
!chat1p2.status := #OPEN

!rightNow.initialise(2021, 10, 22, 12, 35, 06)
!chatp1p2.createMessage(player2, 'This is a test')

!for tick in Sequence{1..20} do clk.tick(); end
!chatp1p2.view(player1)

!for tick in Sequence{1..19} do clk.tick(); end
!chatp1p2.createMessage(player1, 'This is a test')

!for tick in Sequence{1..14} do clk.tick(); end
!chatp1p2.view(player2)

!chat1p1.lastOpened := chatp1p2.messages->last().sentDate
!chat1p2.lastOpened := chatp1p2.messages->last().seenDate

--------Match Request between Players 1 and 2

--!new DateTime('matchReq1SentDate')
--!insert (matchReq1SentDate, rightNow) into CurrentTime
--!matchReq1SentDate.initialise(2021, 10, 22, 12, 36, 12)

--!new DateTime('matchReq1AddrDate')
--!insert (matchReq1AddrDate, rightNow) into CurrentTime
--!matchReq1AddrDate.initialise(2021, 10, 22, 12, 37, 21)

--!new Period('matchReq1Period')
--!matchReq1Period.addStart(matchReq1AddrDate)

--!new MatchRequest('matchReq1')
--!matchReq1.id := 'matchReq1'
--!matchReq1.sentDate := matchReq1SentDate
--!matchReq1.activePeriod := matchReq1Period
--!matchReq1.type := #MATCH
--!matchReq1.matchType := #UNRANKED
--!matchReq1.timed := false
--!matchReq1.status := #ACCEPTED
--!insert (player1,matchReq1) into SentRequest
--!insert (player2,matchReq1) into RecievedRequest

--------Player 1 and 2 joining the queue

!player1.joinQueue(#UNRANKED, false)
!player2.joinQueue(#UNRANKED, false)

--------Match between Player 1 and 2

!player1.openMatch(player1.matchHistory->last())
!player2.openMatch(player2.matchHistory->last())

-- At this point rightNow = 2021-10-22 12:35:59
-- Changing the time before this point will change the letters assigned to
-- each Rack meaning you'll have to make new words all over again

? m1Rack1.tiles
!tSeq := OrderedSet{m1R5Tile, m1E5Tile, m1M2Tile, m1O3Tile, m1T1Tile, m1E9Tile}
!m1Rack1.triggerPlay(8, 8, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(8, 8, #HORIZONTAL, tSeq, rightNow)

!for tick in Sequence{1..8} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1A8Tile, m1X1Tile}
!m1Rack2.triggerPlay(6, 9, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(6, 9, #VERTICAL, tSeq, rightNow)

!for tick in Sequence{1..11} do clk.tick(); end
? m1Rack1.tiles
--!tSeq := OrderedSet{m1J1Tile, m1E11Tile, m1E2Tile, m1R2Tile, m1I1Tile, m1N4Tile, m1G2Tile}
!tSeq := OrderedSet{m1J1Tile, m1E11Tile, m1E2Tile, m1I1Tile, m1N4Tile, m1G2Tile}
!m1Rack1.triggerPlay(5, 8, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(5, 8, #VERTICAL, tSeq, rightNow)

!for tick in Sequence{1..10} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1S4Tile, m1U2Tile, m1B1Tile, m1N2Tile, m1E6Tile, m1T4Tile}
!m1Rack2.triggerPlay(8, 14, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(8, 14, #VERTICAL, tSeq, rightNow)

? m1Rack1.tiles
? m1Rack2.tiles

check
