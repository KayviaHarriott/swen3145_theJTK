------------------------------------------------------------------------------
--! @authors: Jason Hunter, Kayvia Harriott, Tashna-Gail Williams
--! Created on: 2021-11-02
--! @version: 0.5.0
--! Last Updated: 2021-12-01 17:12:50
------------------------------------------------------------------------------

-- PLEASE DON'T EDIT THIS FILE DIRECTLY, COPY AND PASTE IT AND WORK ON THAT
-- WHEN TESTING. DON'T COMMIT YOUR CUSTOM TEST FILE DIRECTLY EITHER. IF YOU
-- CREATED ANE NEW OBJECTS THAT COULD BE USEFUL FOR TESTING YOU MAY ADD THE
-- CHANGES HERE BUT OTHERWISE THIS IS JUST A BASE FILE TO MAKE YOUR PERSONAL
-- TESTS FROM

reset

!new Scrumble ('scrumble')

!new Clock('clk')
!insert (scrumble, clk) into ScrumbleClock
!new DateTime('rightNow')
--!rightNow.initialise(2021, 10, 22, 12, 59, 59)
!rightNow.initialise(2021, 10, 20, 18, 05, 13)
!insert (rightNow, rightNow) into CurrentTime
!clk.time := rightNow

!new RequestFactory('rFactory')
!insert (scrumble, rFactory) into ScrumbleReqFactory

!new MatchFactory('mFactory')
!insert (scrumble, mFactory) into ScrumbleMatchFactory

!new MatchBuilder('mBuilder')
!insert (scrumble, mBuilder) into ScrumbleMatchBuilder
!insert (mFactory, mBuilder) into MatchFactoryBuilder

!new Leaderboard('lboard')
!insert (scrumble, lboard) into ScrumbleLboard
!insert (lboard, lboard) into OnlyLboard

!new Queue('rankedQ')
!insert (scrumble, rankedQ) into ScrumbleQueues
!rankedQ.init(#RANKED, true)
!new Queue('unrankedTimedQ')
!insert (scrumble, unrankedTimedQ) into ScrumbleQueues
!unrankedTimedQ.init(#UNRANKED, true)
!new Queue('unrankedUntimedQ')
!insert (scrumble, unrankedUntimedQ) into ScrumbleQueues
!unrankedUntimedQ.init(#UNRANKED, false)

--------Dictionary

!new Dictionary('dict')
!insert (scrumble, dict) into ScrumbleDict
!insert (dict, dict) into OnlyDict

!new Word('word')
!spelling := 'WORD'
!word.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (word, l) into Spelling; end;
!insert (dict, word) into ValidWord

!new Word('door')
!spelling := 'DOOR'
!door.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (door, l) into Spelling; end;
!insert (dict, door) into ValidWord

!new Word('stream')
!spelling := 'STREAM'
!stream.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (stream, l) into Spelling; end;
!insert (dict, stream) into ValidWord

!new Word('ate')
!spelling := 'ATE'
!ate.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (ate, l) into Spelling; end;
!insert (dict, ate) into ValidWord

!new Word('remote')
!spelling := 'REMOTE'
!remote.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (remote, l) into Spelling; end;
!insert (dict, remote) into ValidWord

!new Word('axe')
!spelling := 'AXE'
!axe.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (axe, l) into Spelling; end;
!insert (dict, axe) into ValidWord

!new Word('jeering')
!spelling := 'JEERING'
!jeering.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (jeering, l) into Spelling; end;
!insert (dict, jeering) into ValidWord

!new Word('ea')
!spelling := 'EA'
!ea.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (ea, l) into Spelling; end;
!insert (dict, ea) into ValidWord

!new Word('ex')
!spelling := 'EX'
!ex.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (ex, l) into Spelling; end;
!insert (dict, ex) into ValidWord

!new Word('subnet')
!spelling := 'SUBNET'
!subnet.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (subnet, l) into Spelling; end;
!insert (dict, subnet) into ValidWord

!new Word('remotes')
!spelling := 'REMOTES'
!remotes.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (remotes, l) into Spelling; end;
!insert (dict, remotes) into ValidWord

!new Word('cargo')
!spelling := 'CARGO'
!cargo.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (cargo, l) into Spelling; end;
!insert (dict, cargo) into ValidWord

!new Word('sour')
!spelling := 'SOUR'
!sour.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (sour, l) into Spelling; end;
!insert (dict, sour) into ValidWord

!new Word('cargos')
!spelling := 'CARGOS'
!cargos.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (cargos, l) into Spelling; end;
!insert (dict, cargos) into ValidWord

!new Word('helical')
!spelling := 'HELICAL'
!helical.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (helical, l) into Spelling; end;
!insert (dict, helical) into ValidWord

!new Word('flanked')
!spelling := 'FLANKED'
!flanked.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (flanked, l) into Spelling; end;
!insert (dict, flanked) into ValidWord

!new Word('flank')
!spelling := 'FLANK'
!flank.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (flank, l) into Spelling; end;
!insert (dict, flank) into ValidWord

!new Word('guinea')
!spelling := 'GUINEA'
!guinea.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (guinea, l) into Spelling; end;
!insert (dict, guinea) into ValidWord

!new Word('quoted')
!spelling := 'QUOTED'
!quoted.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (quoted, l) into Spelling; end;
!insert (dict, quoted) into ValidWord

!new Word('tibia')
!spelling := 'TIBIA'
!tibia.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (tibia, l) into Spelling; end;
!insert (dict, tibia) into ValidWord

!new Word('weapon')
!spelling := 'WEAPON'
!weapon.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (weapon, l) into Spelling; end;
!insert (dict, weapon) into ValidWord

!new Word('oh')
!spelling := 'OH'
!oh.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (oh, l) into Spelling; end;
!insert (dict, oh) into ValidWord

!new Word('retweet')
!spelling := 'RETWEET'
!retweet.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (retweet, l) into Spelling; end;
!insert (dict, retweet) into ValidWord

!new Word('rewet')
!spelling := 'REWET'
!rewet.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (rewet, l) into Spelling; end;
!insert (dict, rewet) into ValidWord

!new Word('fiddly')
!spelling := 'FIDDLY'
!fiddly.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (fiddly, l) into Spelling; end;
!insert (dict, fiddly) into ValidWord

!new Word('fe')
!spelling := 'FE'
!fe.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (fe, l) into Spelling; end;
!insert (dict, fe) into ValidWord

!new Word('it')
!spelling := 'IT'
!it.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (it, l) into Spelling; end;
!insert (dict, it) into ValidWord

!new Word('suicide')
!spelling := 'SUICIDE'
!suicide.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (suicide, l) into Spelling; end;
!insert (dict, suicide) into ValidWord

!new Word('hoo')
!spelling := 'HOO'
!hoo.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (hoo, l) into Spelling; end;
!insert (dict, hoo) into ValidWord

!new Word('hit')
!spelling := 'HIT'
!hit.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (hit, l) into Spelling; end;
!insert (dict, hit) into ValidWord

!new Word('od')
!spelling := 'OD'
!od.category := #NONE
!for c in spelling.characters() do l := new Letter(); l.letter := c; insert (od, l) into Spelling; end;
!insert (dict, od) into ValidWord

--------Users

!new User('u1')
!u1.id := 'u1'
!insert (scrumble, u1) into ScrumbleUsers
!new DateTime('u1DoB')
!insert (u1DoB, rightNow) into CurrentTime
!new Player('player1')
!insert (u1, player1) into UserRole
!player1.initialise('TestUser1', 'test1@email.com', u1DoB)

!player1.openApp()

!new User('u2')
!u2.id := 'u2'
!insert (scrumble, u2) into ScrumbleUsers
!new DateTime('u2DoB')
!insert (u2DoB, rightNow) into CurrentTime
!new Player('player2')
!insert (u2, player2) into UserRole
!player2.initialise('TestUser2', 'test2@email.com', u2DoB)

!player2.openApp()

--------Friend Request between Players 1 and 2

--!frReq1SentDate.initialise(2021, 10, 20, 18, 05, 13)
--!frReq1AddrDate.initialise(2021, 10, 21, 6, 05, 21)

!player1.sendReq(player2, #FRIEND)

-- Running the for loop is slow so initialize right now to 1 second before the
-- time you want then scrumble.clock.tick() once
--!for tick in Sequence{1..43194} do scrumble.clock.tick(); end
!rightNow.initialise(2021, 10, 21, 6, 05, 20)
!scrumble.clock.tick()
? rightNow.makeHumanReadable(rightNow.secondsSinceEposh)

!player2.addressReq(player2.rcvdReqs->any(r | r.reqSender = player1 and r.type = #FRIEND and r.status = #PENDING), true)

--------Chat between Players 1 and 2

!rightNow.initialise(2021, 10, 22, 12, 35, 05)
!scrumble.clock.tick()
? rightNow.makeHumanReadable(rightNow.secondsSinceEposh)

!new Chat('chatp1p2')
!new ChatState('chat1p1') between (chatp1p2, player1)
!chat1p1.lastOpened := new DateTime()
!insert (chat1p1.lastOpened, rightNow) into CurrentTime
!new ChatState('chat1p2') between (chatp1p2, player2)
!chat1p2.lastOpened := new DateTime()
!insert (chat1p2.lastOpened, rightNow) into CurrentTime

!player1.openChat(chatp1p2)
!for tick in Sequence{1..20} do clk.tick(); end
!chatp1p2.createMessage(player2, 'This is a test')

!player2.openChat(chatp1p2)
!for tick in Sequence{1..19} do clk.tick(); end
!chatp1p2.createMessage(player1, 'This is a test')

!for tick in Sequence{1..14} do clk.tick(); end

!player1.closeChat()
!player2.closeChat()

--------Match Request between Players 1 and 2

--!new DateTime('matchReq1SentDate')
--!insert (matchReq1SentDate, rightNow) into CurrentTime
--!matchReq1SentDate.initialise(2021, 10, 22, 12, 36, 12)

--!new DateTime('matchReq1AddrDate')
--!insert (matchReq1AddrDate, rightNow) into CurrentTime
--!matchReq1AddrDate.initialise(2021, 10, 22, 12, 37, 21)

--!new Period('matchReq1Period')
--!matchReq1Period.addStart(matchReq1AddrDate)

--!new MatchRequest('matchReq1')
--!matchReq1.id := 'matchReq1'
--!matchReq1.sentDate := matchReq1SentDate
--!matchReq1.activePeriod := matchReq1Period
--!matchReq1.type := #MATCH
--!matchReq1.matchType := #UNRANKED
--!matchReq1.timed := false
--!matchReq1.status := #ACCEPTED
--!insert (player1,matchReq1) into SentRequest
--!insert (player2,matchReq1) into RecievedRequest

--------Player 1 and 2 joining the queue

? rightNow.makeHumanReadable(rightNow.secondsSinceEposh)

!player1.joinQueue(#UNRANKED, false)
!player2.joinQueue(#UNRANKED, false)

--------Match between Player 1 and 2

!player1.openMatch(player1.matchHistory->last())
!player2.openMatch(player2.matchHistory->last())

-- At this point rightNow = 2021-10-22 12:35:59
-- Changing the time before this point will change the letters assigned to
-- each Rack meaning you'll have to make new words all over again
? rightNow.makeHumanReadable(rightNow.secondsSinceEposh)

? m1Rack1.tiles
!tSeq := OrderedSet{m1R5Tile, m1E5Tile, m1M2Tile, m1O3Tile, m1T1Tile, m1E9Tile}
!m1Rack1.triggerPlay(8, 8, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(8, 8, #HORIZONTAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..8} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1A8Tile, m1X1Tile}
!m1Rack2.triggerPlay(6, 9, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(6, 9, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..11} do clk.tick(); end
? m1Rack1.tiles
-- invalid play test
--!tSeq := OrderedSet{m1J1Tile, m1E11Tile, m1E2Tile, m1R2Tile, m1I1Tile, m1N4Tile, m1G2Tile}
!tSeq := OrderedSet{m1J1Tile, m1E11Tile, m1E2Tile, m1I1Tile, m1N4Tile, m1G2Tile}
!m1Rack1.triggerPlay(5, 8, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(5, 8, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..10} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1S4Tile, m1U2Tile, m1B1Tile, m1N2Tile, m1E6Tile, m1T4Tile}
!m1Rack2.triggerPlay(8, 14, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(8, 14, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..9} do clk.tick(); end
? m1Rack1.tiles
!tSeq := OrderedSet{m1C1Tile, m1A6Tile, m1R2Tile, m1O5Tile}
!m1Rack1.triggerPlay(11, 5, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(11, 5, #HORIZONTAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..10} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1S1Tile, m1O7Tile, m1U4Tile, m1R3Tile}
!m1Rack2.triggerPlay(11, 10, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(11, 10, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..20} do clk.tick(); end
? m1Rack1.tiles
!tSeq := OrderedSet{m1H2Tile, m1E1Tile, m1L2Tile, m1I4Tile, m1A7Tile, m1L3Tile}
!m1Rack1.triggerPlay(7, 5, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(7, 5, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..16} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1F1Tile, m1A9Tile, m1N1Tile, m1K1Tile}
!m1Rack2.triggerPlay(13, 4, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(13, 4, #HORIZONTAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..26} do clk.tick(); end
? m1Rack1.tiles
!tSeq := OrderedSet{m1G3Tile, m1U3Tile, m1I5Tile, m1N3Tile, m1A4Tile}
!m1Rack1.triggerPlay(8, 1, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(8, 1, #HORIZONTAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..12} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1Q1Tile, m1O6Tile, m1T6Tile, m1E12Tile, m1D2Tile}
!m1Rack2.triggerPlay(7, 2, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(7, 2, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..20} do clk.tick(); end
? m1Rack1.tiles
!tSeq := OrderedSet{m1I7Tile, m1B2Tile, m1I8Tile, m1A5Tile}
!m1Rack1.triggerPlay(8, 12, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(8, 12, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..12} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1W1Tile, m1E8Tile, m1A1Tile, m1P2Tile, m1O8Tile}
!m1Rack2.triggerPlay(3, 4, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(3, 4, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..15} do clk.tick(); end
? m1Rack1.tiles
!tSeq := OrderedSet{m1R1Tile, m1E3Tile, m1E4Tile, m1T3Tile}
!m1Rack1.triggerPlay(3, 2, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(3, 2, #HORIZONTAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..12} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1F2Tile, m1I3Tile, m1D3Tile, m1D4Tile, m1L4Tile, m1Y2Tile}
!m1Rack2.triggerPlay(2, 5, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(2, 5, #HORIZONTAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..17} do clk.tick(); end
? m1Rack1.tiles
!tSeq := OrderedSet{m1S2Tile, m1U1Tile, m1I2Tile, m1C2Tile, m1I9Tile, m1D1Tile}
!m1Rack1.triggerPlay(2, 13, #VERTICAL, tSeq)
? m1.getWordsSpeltByPlay(2, 13, #VERTICAL, tSeq, rightNow)
? m1.score

!for tick in Sequence{1..15} do clk.tick(); end
? m1Rack2.tiles
!tSeq := OrderedSet{m1H1Tile,m1O1Tile,m1O2Tile}
!m1Rack2.triggerPlay(1, 6, #HORIZONTAL, tSeq)
? m1.getWordsSpeltByPlay(1, 6, #HORIZONTAL, tSeq, rightNow)
? m1.score

-- !for tick in Sequence{1..} do clk.tick(); end
-- ? m1Rack1.tiles
-- !tSeq := OrderedSet{}
-- !m1Rack1.triggerPlay(5, 8, #VERTICAL, tSeq)
-- ? m1.getWordsSpeltByPlay(5, 8, #VERTICAL, tSeq, rightNow)
-- ? m1.score

-- !for tick in Sequence{1..} do clk.tick(); end
-- ? m1Rack2.tiles
-- !tSeq := OrderedSet{}
-- !m1Rack2.triggerPlay(8, 14, #VERTICAL, tSeq)
-- ? m1.getWordsSpeltByPlay(8, 14, #VERTICAL, tSeq, rightNow)
-- ? m1.score

--     1   2   3   4   5   6   7   8   9  10  11  12  13  14  15
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 1 |   |   |   |   |   | H | O | O |   |   |   |   |   |   |   | 1
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 2 |   |   |   |   | F | I | D | D | L | Y |   |   | S |   |   | 2
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 3 |   | R | E | W | E | T |   |   |   |   |   |   | U |   |   | 3
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 4 |   |   |   | E |   |   |   |   |   |   |   |   | I |   |   | 4
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 5 |   |   |   | A |   |   |   | J |   |   |   |   | C |   |   | 5
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 6 |   |   |   | P |   |   |   | E | A |   |   |   | I |   |   | 6
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 7 |   | Q |   | O | H |   |   | E | X |   |   |   | D |   |   | 7
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 8 | G | U | I | N | E | A |   | R | E | M | O | T | E | S |   | 8
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-- 9 |   | O |   |   | L |   |   | I |   |   |   | I |   | U |   | 9
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--10 |   | T |   |   | I |   |   | N |   |   |   | B |   | B |   | 10
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--11 |   | E |   |   | C | A | R | G | O | S |   | I |   | N |   | 11
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--12 |   | D |   |   | A |   |   |   |   | O |   | A |   | E |   | 12
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--13 |   |   |   | F | L | A | N | K |   | U |   |   |   | T |   | 13
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--14 |   |   |   |   |   |   |   |   |   | R |   |   |   |   |   | 14
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--15 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | 15
--   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
--     1   2   3   4   5   6   7   8   9  10  11  12  13  14  15

? m1Rack1.tiles
? m1Rack2.tiles
? m1.board.tileBag.tiles->size()

check
