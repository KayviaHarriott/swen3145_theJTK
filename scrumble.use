------------------------------------------------------------------------------
--! @authors: Jason Hunter, Kayvia Harriott, Tashna-Gail Williams
--! Created on: 2021-10-11
--! @version: 0.4.8
--! Last Updated: 2021-11-28
------------------------------------------------------------------------------

model scrumble

enum BlockStatus {BLOCKED, UNBLOCKED}
enum ChatStatus {OPEN, CLOSED}
enum MatchStatus {INPROGRESS, COMPLETE, ABANDONED}
enum MessageStatus {UNSEEN, SEEN}
enum PlayerStatus {ONLINE, OFFLINE, AWAY, PLAYING}
enum ReportStatus {UNRESOLVED, UNDER_REVIEW, RESOLVED}
enum RequestStatus {PENDING, ACCEPTED, REJECTED, RECINDED, LOST}

enum MatchType {RANKED, UNRANKED}
enum PlayType {PLAY, PASS, QUIT}
enum ReportType {BUG, PLAYER}
enum RequestType {FRIEND, MESSAGE, MATCH}

enum Category {ANIMAL, MUSIC, MOVIES, FOOD, BOOKS, COUNTRIES, NONE}
enum ProfileState {PRIVATE, PUBLIC}
enum PlayDirection {HORIZONTAL, VERTICAL}

--! @TODO:
--!     - Add attributes to represent the rest of the player's profile data
--!     - Rack might need an enum to indicate that a player has a specific
--!       match open so it doesn't generate notifs when the match is open and
--!       a play is made
--!     - Class to represent the match queue for players waiting to join a
--!       match. It would have a never ending loop constantly running to empty
--!       a queue of players and make matches. It would be observable by
--!       Player so a player can get updates when a match is made. We may need
--!       a queue for each type of match
--!     - If we can delete messages and reply to messages then we would add
--!       methods for those as well
--!     - If Datetime becomes observable then would it still be a datatype?
--!     - Figure out how to manage adding and removing words since you
--!       wouldn't want changes to affect past games
--!
--!     DESIGN PATTERN REFINEMENTS
--!         Observer Pattern
--!             In the observer pattern, observables update observers when
--!             they change creating the effect that the observer is
--!             "watching" the observable. So observables have a list of their
--!             observers and call a method in the observer to let them know
--!             things changed. The observer would then execute different
--!             operations to update anything else that depends on the state
--!             of the observable object.
--!
--!         Suggestions for our system:
--!             +------------------------+
--!             | observer    | observes |
--!             +-------------+----------+
--!             | leaderboard | match    |
--!             | player      | match    |
--!             | player      | request  |
--!             | match       | play     |
--!             | player      | chat     |
--!             | player      | report   |
--!             +-------------+----------+
--!
--!         Notes: - Leaderboard observes matches so that player may update
--!                  when a match ends
--!                - Player observes match for status updates
--!                - Player observes request so they may be notified when they
--!                  receive a request
--!                - Match observes play so play may advance the state of the
--!                  game (ie. update the bag, board, racks and score) when a
--!                  play is made and generate a notification
--!                - Player observes chat so chat may notify a player when a
--!                  new message is received
--!                - Player observes report so report may notify a player when
--!                  it's status changes
--!
--!         Singleton Pattern
--!             1 to one associations of the class with itself
--!
--!     ACL REFINEMENTS
--!         Role-Based ACL for Admins and users.
--!             Are we going to allow admins to play matches as well?

abstract class Identifiable
attributes
    id: String
end -- Identifiable

abstract class Observer
operations
    -- This is the method called by the observable to update the Observer
    --update(o: Observable)
end -- Observer Class

abstract class Observable
end -- Observable Class

class DateTime
attributes
    TO_SEC: Tuple(y: Integer, d: Integer, hr: Integer, min: Integer) init:
        Tuple{y = 31557600, d = 86400, hr = 3600, min = 60}
    -- 31557600 is the number of seconds in a year
    -- 86400 is the number of seconds in a day
    -- 3600 is the number of seconds in an hour
    -- 60 is the number of seconds in a minute

    EPOSH: Tuple(
        y: Integer, m: Integer, d: Integer,
        hr: Integer, min: Integer, sec: Integer
    ) init: Tuple{y = 2000, m = 1, d = 1, hr = 0, min = 0, sec = 0}

    -- Initialized to this system's eposh time 2000-01-01 00:00:00
    day: Integer init: EPOSH.d
    month: Integer init: EPOSH.m
    year: Integer init: EPOSH.y
    hour: Integer init: EPOSH.hr
    minute: Integer init: EPOSH.min
    second: Integer init: EPOSH.sec
    secondsSinceEposh: Integer derived:
        toSecondsSinceEposh(year, month, day, hour, minute, second)
operations
    -- Takes a duration in seconds and it into years, months, days
    -- hours, minutes and seconds
    makeHumanReadable(sec: Integer): Tuple(
    y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer) =
        let
            years = EPOSH.y + (sec div TO_SEC.y),
            leapDayCorrection = (years div 400) - (years div 100),
            remDays = sec.mod(TO_SEC.y) div TO_SEC.d + leapDayCorrection,
            daysOfEachMonth = if isLeapYear(years) then
                    Sequence{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                else
                    Sequence{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                endif,
            months = 1 + Sequence{1..12}->iterate(m2; ans: Integer = 0 |
                if (daysOfEachMonth->subSequence(1, m2)->sum() < remDays) then
                    ans + 1
                else
                    ans
                endif),
            days = remDays - daysOfEachMonth
                ->subSequence(1, months - 1)->sum(),
            hours = sec.mod(TO_SEC.y).mod(TO_SEC.d) div TO_SEC.hr,
            minutes = sec.mod(TO_SEC.y).mod(TO_SEC.d)
                .mod(TO_SEC.hr) div TO_SEC.min,
            seconds = sec.mod(TO_SEC.y).mod(TO_SEC.d)
                .mod(TO_SEC.hr).mod(TO_SEC.min)
        in Tuple{y = years, m = months, d = days,
            hr = hours, min = minutes, sec = seconds}

    pre argIsValid: sec > 0
    post resultIsValid: isValid(result.y, result.m, result.d,
        result.hr, result.min, result.sec)

    toSecondsSinceEposh(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer): Integer =
        let
            years = y - EPOSH.y,
            leapDayCorrection = (years div 400) - (years div 100),
            daysOfEachMonth = if isLeapYear(y) then
                    Sequence{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                else
                    Sequence{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                endif,
            days = d + Sequence{1..(m - 1)}->iterate(prevM; ans: Integer = 0 |
                ans + daysOfEachMonth->at(prevM)) + leapDayCorrection - 1
        in (years * TO_SEC.y) + (days * TO_SEC.d) +
            (hr * TO_SEC.hr) + (min * TO_SEC.min) + sec

    pre argsAreValid: isValid(y, m, d, hr, min, sec)
    post resultIsValid:
        let
            date = makeHumanReadable(result)
        in result >= 0 and y = date.y and m = date.m and d = date.d and
            hr = date.hr and min = date.min and sec = date.sec

    initialise(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer)
    begin
        self.year := y;
        self.month := m;
        self.day := d;
        self.hour := hr;
        self.minute := min;
        self.second := sec;
    end

    pre parametersHaveValidValues: isValid(y, m, d, hr, min, sec)
    post attributesCorrectlyUpdated:
        day = d and month = m and year = y and
        hour = hr and minute = min and second = sec

    ---------------------------------Accessors--------------------------------

    getYear(): Integer = year
    getMonth(): Integer = month
    getDay(): Integer = day

    getHour(): Integer = hour
    getMinute(): Integer = minute
    getSecond(): Integer = second

    getNow(): DateTime = now
    post resultNotNull: result <> null

    ---------------------------------Mutators---------------------------------

    setYear(y: Integer)
    begin self.initialise(y, self.month, self.day,
        self.hour, self.minute, self.second); end
    post yearCorrectlyUpdated: year = y

    setMonth(m: Integer)
    begin self.initialise(self.year, m, self.day,
        self.hour, self.minute, self.second); end
    post monthCorrectlyUpdated: month = m

    setDay(d: Integer)
    begin self.initialise(self.year, self.month, d,
        self.hour, self.minute, self.second); end
    post dayCorrectlyUpdated: day = d

    setHour(h: Integer)
    begin self.initialise(self.year, self.month, self.day,
        h, self.minute, self.second); end
    post mutationSuccess: hour = h

    setMinute(m: Integer)
    begin self.initialise(self.year, self.month, self.day,
        self.hour, m, self.second); end
    post mutationSuccess: minute = m

    setSecond(s: Integer)
    begin self.initialise(self.year, self.month, self.day,
        self.hour, self.minute, s); end
    post mutationSuccess: second = s

    --------------------------------Predicates--------------------------------

    -- returns true if all the attributes are not null, false otherwise
    isInitialised(): Boolean =
        day <> null and month <> null and year <> null and
        hour <> null and minute <> null and second <> null and
        secondsSinceEposh >= 0
    post returnValueIsAccurate:
        result = Set{day <> null, month <> null, year <> null,
            hour <> null, minute <> null, second <> null,
            secondsSinceEposh >= 0}
            ->forAll(t | t = true)

    -- returns true if self is before d, false otherwise
    before(d: DateTime): Boolean = secondsSinceEposh < d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueIsAccurate:
        result = (secondsSinceEposh < d.secondsSinceEposh) -- = true

    -- returns true if self has the same values as d, false otherwise
    equals(d: DateTime): Boolean = secondsSinceEposh = d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueConditions:
        result = (secondsSinceEposh < d.secondsSinceEposh)

    -- returns true if self is after d, false otherwise
    after(d: DateTime): Boolean = secondsSinceEposh > d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueIsAccurate:
        result = (secondsSinceEposh > d.secondsSinceEposh)

    -- returns true if y is a leap year, false otherwise
    isLeapYear(y: Integer): Boolean = y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)
    pre yearIsValid: y <> null and y >= 2000
    post returnValueIsAccurate: result = (y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)) -- = true

    secondValid(v: Integer): Boolean = v >= 0 and v < 60
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v < 60)

    minuteValid(v: Integer): Boolean = v >= 0 and v <= 59
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v <= 59)

    hourValid(v: Integer): Boolean = v >= 0 and v < 24
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v < 24)

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 1 and v <= 31)

    monthValid(v: Integer): Boolean = v >= 1 and v <= 12
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 1 and v <= 12)

    yearValid(v: Integer): Boolean = v >= 2000
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 2000)

    dayAndMonthValid(m: Integer, d: Integer): Boolean =
        (Set{4, 6, 9, 11}->includes(m) implies d <= 30) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d <= 31)
    pre dayIsValid: dayValid(d)
    pre monthIsValid: monthValid(m)
    post returnValueIsAccurate: result =
        ((Set{4, 6, 9, 11}->includes(m) implies d < 31) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d < 32))

    febValid(y: Integer, d: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28)
    pre dayIsValid: dayValid(d)
    pre yearIsValid: yearValid(y)
    post returnValueIsAccurate: result =
        ((isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28))

    isValid(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer): Boolean =
        dayValid(d) and monthValid(m) and yearValid(y) and
        dayAndMonthValid(m, d) and (m = 2 implies febValid(y, d)) and
        hourValid(hr) and minuteValid(min) and secondValid(sec)

    isSelfValid(): Boolean = isValid(year, month, day, hour, minute, second)

    --------------------------------Operations--------------------------------

    difference(d: DateTime): Integer =
        secondsSinceEposh - d.secondsSinceEposh
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post resultIsCorrect: result =
        (secondsSinceEposh - d.secondsSinceEposh)

    differenceInDays(d: DateTime): Real = (difference(d) / TO_SEC.d)
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post resultIsCorrect: result =
        ((secondsSinceEposh - d.secondsSinceEposh) / TO_SEC.d)
end -- DateTime Class

class Period
operations
    --------------------------------Predicates--------------------------------

    -- Returns true if the period has a start date or has a start and end date
    -- and the start date is before the end date
    isValid(startDate: DateTime, endDate: DateTime): Boolean =
        startDate <> null and startDate.isInitialised() and
        (endDate <> null implies startDate.before(endDate))
    pre startDateValid: startDate <> null implies startDate.isSelfValid()
    pre endDateValid: endDate <> null implies endDate.isSelfValid()
    post resultIsCorrect: result = (startDate <> null and
        startDate.isInitialised() and
        (endDate <> null implies startDate.before(endDate)))

    -- Returns true if the current period is valid
    isSelfValid(): Boolean = isValid(getStart(), getEnd())

    -- Returns true if the end date for the current period is before the start
    -- date of the period passed as an argument
    before(p: Period): Boolean = getEnd().before(p.getStart())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = getEnd().before(p.getStart())

    -- Returns true if the start date for the current period is after the end
    -- date of the period passed as an argument
    after(p: Period): Boolean = getStart().after(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = getStart().after(p.getEnd())

    -- Returns true if the start and end of both periods is equal
    equals(p:Period): Boolean = getStart().equals(p.getStart()) and
        getEnd().equals(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (getStart().equals(p.getStart()) and
        getEnd().equals(p.getEnd()))

    -- Returns true if the current period starts before and ends after
    -- the period passed as an argument
    contains(p: Period): Boolean = containsDate(p.getStart()) and
        containsDate(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (containsDate(p.getStart()) and
        containsDate(p.getEnd()))

    -- Returns true if the end date for the current period falls within the
    -- range of the period passed as an argument and the start date doesn't
    overlapsOnLeftOf(p: Period): Boolean =
        getStart().before(p.getStart()) and p.containsDate(getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (getStart().before(p.getStart()) and
        p.containsDate(getEnd()))

    -- Returns true if the start date for the current period falls within the
    -- range of the period passed as an argument and the end date doesn't
    overlapsOnRightOf(p: Period): Boolean =
        p.containsDate(getStart()) and getEnd().after(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (p.containsDate(getStart()) and
        getEnd().after(p.getEnd()))

    -- Returns true if the current period starts before and ends after
    -- the period passed as an argument
    containsDate(d: DateTime): Boolean = (not getStart().after(d)) and
        (getEnd() <> null implies (not getEnd().before(d)))
    pre selfAndArgsAreValid: isSelfValid() and d.isSelfValid()
    post noMutations: interval = interval@pre and  d = d@pre
    post resultIsCorrect: result = (getStart().before(d) and
        (getEnd() <> null implies getEnd().after(d)))

    ---------------------------------Accessors--------------------------------

    -- Returns the start date of the period
    getStart(): DateTime = interval->at(1)
    post noMutations: interval = interval@pre
    post resultIsCorrect: result = interval->at(1)

    -- Returns the end date of the period
    getEnd(): DateTime = interval->at(2)
    post noMutations: interval = interval@pre
    post resultIsCorrect: result = interval->at(2)

    ---------------------------------Mutators---------------------------------

    -- Adds a start date if no dates are assigned to the period
    addStart(s: DateTime)
    begin insert (self, s) into PeriodInterval; end
    pre selfNotInit: getStart() = null and getEnd() = null
    pre argIsValid: s.isSelfValid()
    post mutationSuccess: getStart() = s and getEnd() = interval@pre->at(2)
    post selfIsValid: isSelfValid()

    -- Adds an end date if a start date is specified
    addEnd(s: DateTime)
    begin insert (self, s) into PeriodInterval; end
    pre selfAndArgsAreValid: isSelfValid() and s.isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = s
    post selfStillValid: isValid(getStart(), getEnd())

    -- Removes start date if no end date is specified
    removeStart()
    begin delete (self, getStart()) from PeriodInterval end
    pre selfIsValid: isSelfValid()
    post selfNotInit: getStart() = null and getEnd() = null

    -- Removes the end date
    removeEnd()
    begin delete (self, getEnd()) from PeriodInterval end
    pre selfIsValid: isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = null

    -- Replaces start date with the new date
    replaceStart(s: DateTime)
    begin
        declare endDate: DateTime;
        endDate := getEnd();
        delete (self, getStart()) from PeriodInterval;
        delete (self, endDate) from PeriodInterval;

        insert (self, s) into PeriodInterval;
        insert (self, endDate) into PeriodInterval;
    end

    pre selfAndArgsAreValid: isSelfValid() and s.isSelfValid()
    post mutationSuccess: getStart() = s and getEnd() = interval@pre->at(2)
    post selfStillValid: isValid(getStart(), getEnd())

    -- Replaces the end date with the new date
    replaceEnd(s: DateTime)
    begin
        delete (self, getEnd()) from PeriodInterval;
        insert (self, s) into PeriodInterval;
    end

    pre argIsValid: s.isSelfValid()
    pre selfIsValid: isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = s
    post selfStillValid: isValid(getStart(), getEnd())

    --------------------------------Operations--------------------------------

    duration(): Integer =
        if getEnd() <> null then
            getEnd().difference(getStart())
        else
            getStart().now.difference(getStart())
        endif
    pre selfIsValid: isSelfValid()
    post resultIsCorrect: result =
        if getEnd() <> null then
            getEnd().difference(getStart())
        else
            getStart().now.difference(getStart())
        endif

    durationInDays(): Real =
        if getEnd() <> null then
            getEnd().differenceInDays(getStart())
        else
            getStart().getNow().differenceInDays(getStart())
        endif
    pre selfIsValid: isSelfValid()
    post resultIsCorrect: result =
        if getEnd() <> null then
            getEnd().differenceInDays(getStart())
        else
            getStart().getNow().differenceInDays(getStart())
        endif
end -- Period Class

class Player < Identifiable, Observer
attributes
    username: String
    email: String
    dob: DateTime
    score: Integer init: 500
    status: PlayerStatus
    state: ProfileState init: #PRIVATE
operations
    --getters (we'll have to restrict what may be obtained in the method I
    -- think)

    -- Generates notifications based on what event occured
    --update(o: Observable)

    -- Updates the player's score if a ranked match was completed or abandoned
    --updateHelperMatch(o: Match)
    -- for the body we could generate a decimal value based on the difference
    -- in the players' ranks, the time it took to end the game, average points
    -- per play, average time per play
    -- we could cap the amount your score increases to +/- 25 points

    -- update helper function for chat events
    --updateHelperChat(o: Chat)

    -- update helper function for request events
    --updateHelperRequest(o: Request)

    -- update helper function for report events
    --updateHelperReport(o: Report)

    -- update helper function for matchRequest events
    --updateHelperMatchReq(o: MatchRequest)

    -- Sends a message in a given chat
    --sendMsg(c: Chat, msg: String)

    -- Adds the player to the match queue
    joinQueue(q: Queue)
    begin
        new Join() between (q, self);
    end

    pre argIsValid: q <> null
    pre playerIsOnline: status = #ONLINE
    post joinSuccessful: ((queues->size() - queues@pre->size()) = 1) and
        (queues->size() = 1)

    -- Removes the player from the match queue
    leaveQueue()
    begin
        destroy self.queues->any(true);
    end

    pre playerIsInQueue: queues->size() = 1
    pre playerIsOnline: status = #ONLINE
    post leaveSuccessful: ((queues->size() - queues@pre->size()) = -1) and
        (queues->size() = 0)

    -- Sends a request to the specified player
    --sendReq(p: Player, t: RequestType)

    -- Updates the status of a received request
    --addressReq(req: Request, action: RequestStatus)

    -- Adds a player to the player's blocked list
    -- blockPlayer(p: Player)

    -- Creates a bug report
    --reportBug(msg: String)

    -- Creates a report against the specified player
    --reportBug(p: Player)

    -- Opens the specified chat (Should this take a player or the chat?)
    --openChat(c: Chat)

    -- Closes the specified chat
    --closeChat(c: Chat)

    -- Opens the specified match
    --openMatch(m: Match)

    -- Closes the specified match
    --closeMatch(m: Match)

    -- Executes actions that should occur once the player opens the app or
    -- logs in
    --openApp()

    -- Executes actions that should occur once the player closes the app
    -- or logs out
    --closeApp()
end -- Player Class

class Message < Identifiable
attributes
    status: MessageStatus init: #UNSEEN
    message: String
    sentDate: DateTime
    seenDate: DateTime
operations
    --getters

    -- Sets the message status to SEEN
    --view()
end -- Message Class

class Notification
attributes
        deliverytime: DateTime
    dismissed: Boolean init: false
operations
    -- Matks the message as dismissed
    -- dismiss()

    -- Opens the app to the relevant view then dismisses the notification
    --gotoAndDismiss()

    -- gotoAndDismiss helper for chat event notifications
    --gotoChatHelper

    -- gotoAndDismiss helper for match event notifications
    --gotoMatchHelper

    -- gotoAndDismiss helper for request event notifications
    --gotoRequestHelper

    -- gotoAndDismiss helper for report event notifications
    --gotoReportHelper
end

class Chat < Observable
operations
    -- Creates a new message
    --createMessage(msg: String)

    -- Marks all the newest received messages as seen
    --view(p: Player)
end -- Chat Class

associationclass ChatState
between
    Chat[*] role chatRooms
    Player[2] role participants
attributes
    status: ChatStatus init: #CLOSED
    lastOpened: DateTime
operations
    -- Sets the chat state to open
    --setOpen() -- view all unseen messages and set ChatStatus to OPEN

    -- Sets the chat state to closed
    --setClosed() -- set lastOpened date and set ChatStatus to CLOSED
end -- End ChatState Association Class

class Request < Identifiable, Observable
attributes
    status: RequestStatus init: #PENDING
    sentDate: DateTime
    activePeriod: Period
    type: RequestType
operations
    accept()
        begin
            self.status := #ACCEPTED;
        end
        pre: status = #PENDING;

    -- Mark the request as rejected
    reject()
        begin
            self.status := #REJECTED;
        end
        pre: status = #PENDING;

    -- Mark the request as recinded
    recind()
        begin
                self.status := #RECINDED;
        end
        pre: status = #PENDING;

    -- Mark the request as lost
    block()
        begin
                self.status := #LOST;
        end
        pre: status = #PENDING;
end -- Request Class

class MatchRequest < Request
attributes
    matchType: MatchType
    timed: Boolean
operations
    -- Mark the request as accepted and creates a new match
    --accept()
end -- MatchRequest Class

associationclass Block
between
    Player[*] role player
    Player[*] role blocked
attributes
    date: DateTime
    status: BlockStatus init: #BLOCKED
operations
    -- Mark a player as blocked
    --block()

    -- Mark a player as unblocked
    --unblock()
end -- Block Association Class

class Report < Observable
attributes
    type: ReportType
    status: ReportStatus init: #UNRESOLVED
operations
    --getters

    -- Mark the report as under review
    --review()

    -- Mark the report as resolved
    --resolve()
end -- Report Class

-------------------------------------Game-------------------------------------

class Queue
operations
    --
end -- Queue Class

associationclass Join
between
    Queue[*] role queues
    Player[*] role players
attributes
    matchType: MatchType
    timed: Boolean
    joinedAt: DateTime
operations
    --
end -- Join Association Class

associationclass Rack
between
    Player[2] role players
    Match[*] role matchHistory ordered
operations
    -- Makes a play
    triggerPlay(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile))
    -- Essentially a wrapper for the play method in match
    pre playerIsInGame: players.status = #PLAYING
    pre argsAreValid: Set{sRow, sCol, dir}->excludes(null) and
        tileSeq->size() > 0 and tiles->includesAll(tileSeq)
    post tilesRemoved: tiles->excludesAll(tileSeq)

    -- Passes a turn
    triggerPass()
    pre playerIsInGame: players.status = #PLAYING
    post: true

    -- Forfeits the game
    triggerQuit()
    pre playerIsInGame: players.status = #PLAYING
    post: true
end -- Rack Association Class

class Play < Identifiable, Observable
attributes
    type: PlayType
    -- The main word is the word in the same row/column where the tiles were
    -- placed. The main word does not have to start where the first tile
    -- was placed
    startRow: Integer -- row of the first letter of the main word
    startCol: Integer -- column of the first letter of the main word
    direction: PlayDirection
    score: Integer derived = calcScore()
    time: DateTime
    multiplier: Real derived = calcMultiplier()
operations
    -- Initializes the play
    init(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile), t: PlayType)
    -- Essentially a wrapper for the executePlay method in match
    pre argsAreValid: t = #PLAY implies
        Set{sRow, sCol, dir}->excludes(null) and tileSeq->size() > 0
    post attributesSet: startRow = sRow and startCol = sCol and
        direction = dir and type = t and time <> null and
        time.equals(time.now)

    -- Calculates the points accumulated by the placement of the tiles on the
    -- board
    calcScore(): Integer =
        let
            activeTiles = rack.tiles->union(match.board.slots.tile)->asSet(),
            flatScore = words->iterate(w; ans:Integer = 0 |
                    ans + w.letters->iterate(l; ws:Integer = 0 |
                        ws + activeTiles
                            ->any(t | t.letter.letter = l.letter).points
                    )
                )
        in (flatScore * multiplier).floor
    pre isAPlay: type = #PLAY
    post: true

    calcMultiplier(): Real =
        if words.category->excluding(#NONE)
        ->includes(match.category) then
            1.5
        else
            1
        endif
    pre isAPlay: type = #PLAY
    post: true
end -- Play Class

class Board
end -- Board Class

class Slot
attributes
    filledAt: DateTime
operations
    --getters and setters
    getTile(): Tile = tile
    getTileString(): String = getTile().getLetterString()

    isEmpty(): Boolean = tile->isEmpty()
end -- Slot Class

class Tile
attributes
    points: Integer
operations
    getLetter(): Letter = letter
    getLetterString(): String = getLetter().getLetter()
    getPoints(): Integer = points
end -- Tile Class

class Letter
attributes
    letter: String
operations
    getLetter(): String = letter
    equals(l: Letter): Boolean = (getLetter() = l.getLetter())
    pre argIsValid: l <> null
end -- Letter Class

class TileBag
operations
    -- Randomly picks a tile from the bag
    --remove
end -- TileBag Class

class Word
attributes
    String: Word
    category: Category init: #NONE
operations
    -- Returns a String that represents the word
    getWord(): String = letters->iterate(l; ans: String = '' |
        ans + l.getLetter())

    equals(ws: String): Boolean = getWord().equalsIgnoreCase(ws)
    pre argIsValid: ws <> null

    --protected setters
end -- Word Class

class Dictionary
operations
    -- Searches for the word that matches the arguement passed and returns it
    -- returns null otherwise
    lookup(ws: String): Word = words->any(w | w.equals(ws))
    pre argIsValid: ws <> null

    --protected setters
end -- Dictionary Class

class Match < Identifiable, Observer, Observable
attributes
    type: MatchType
    timed: Boolean
    duration: Period
    category: Category
    status: MatchStatus init: #INPROGRESS
    score: Integer derived = playHistory->iterate(p; ans: Integer = 0 |
                                if playHistory->indexOf(p).mod(2) = 1 then
                                    ans + p.score
                                else
                                    ans - p.score
                                endif)
operations
    --getters
    --update(o: Observable)

    -- Checks if the player is currently has the match open and creates a
    -- notification if they don't or signals to the players that the match
    -- is complete
    --updateHelperPlay(o: Play)

    executePass(r: Rack)
    -- Creates a play with type pass
    pre argIsValid: r <> null
    post playMade:
            let
                lp = playHistory->last()
            in lp.type = #PASS and lp.time.equals(lp.time.now) and
                (playHistory->size() - playHistory@pre->size()) = 1

    executeQuit(r: Rack)
    -- Creates a play with type pass
    pre argIsValid: r <> null
    post playMade:
            let
                lp = playHistory->last()
            in lp.type = #QUIT and lp.time.equals(lp.time.now) and
                (playHistory->size() - playHistory@pre->size()) = 1

    executePlay(r: Rack, sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile))
    -- Places the tiles on the board, calculates the score and bonus of the
    -- play
    pre playIsValid: playHelperIsPlayValid(sRow, sCol, dir, tileSeq->size())
    post playMade:
            let
                lp = playHistory->last()
            in lp.type = #PLAY and lp.time.equals(lp.time.now) and
                (playHistory->size() - playHistory@pre->size()) = 1
    post tilesPlaced:
        if dir = #HORIZONTAL then
            Sequence{sCol..15}->iterate(c; ans: Set(Tile) = Set{} |
                ans->including(board.slots[sRow, c].getTile())
            )->includesAll(tileSeq)
        else --if dir = #VERTICAL then
            Sequence{sRow..15}->iterate(r; ans: Set(Tile) = Set{} |
                ans->including(board.slots[r, sCol].getTile())
            )->includesAll(tileSeq)
        endif

    playHelperAllTilesFit(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        if dir = #HORIZONTAL then
            Sequence{sCol..15}->iterate(c; ans: Integer = 0 |
                if board.slots[sRow, c].isEmpty() then
                    ans + 1
                else ans endif
            ) >= tcnt
        else --if dir = #VERTICAL then
            Sequence{sRow..15}->iterate(r; ans: Integer = 0 |
                if board.slots[r, sCol].isEmpty() then
                    ans + 1
                else ans endif
            ) >= tcnt
        endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol, tcnt}) and
        dir <> null

    playHelperPlayIntersects(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        if dir = #HORIZONTAL then
            Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                ans or
                (board.slots[sRow, sCol + o - 1].isEmpty() implies
                    (not Set{board.slots[sRow - 1, sCol + o - 1].tile,
                    board.slots[sRow + 1, sCol + o - 1].tile}->isEmpty()))
            ) or board.slots[sRow, sCol + tcnt].tile <> null
        else --if dir = #VERTICAL then
            Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                ans or
                (board.slots[sRow + o - 1, sCol].isEmpty() implies
                    (not Set{board.slots[sRow + o - 1, sCol - 1].tile,
                    board.slots[sRow + o - 1, sCol + 1].tile}->isEmpty()))
            ) or board.slots[sRow + tcnt, sCol].tile <> null
        endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol, tcnt}) and
        dir <> null

    playHelperIsPlayValid(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        playHelperAllTilesFit(sRow, sCol, dir, tcnt) and
        ((playHistory->size() > 0 and
            playHelperPlayIntersects(sRow, sCol, dir, tcnt)) or
        (playHistory->size() = 0 and sRow = 8 and sCol = 8 and
                dir <> null and tcnt > 0))
end -- Match Class

class Leaderboard < Observer
operations
    --getters

    --update(o: Observable)

    -- Updates the players' ranks once a ranked match is complete
    --updateHelperMatch(o: Match)
end -- Leaderboard Class

associationclass Rank
between
    Leaderboard[1]
    Player[*] role players ordered
attributes
    placement: Integer
operations
    getRank(): Integer = placement
end -- Rank Association Class

---------------------------------Associations---------------------------------

association Watches between
    Observer[*]
    Observable[*]
end -- Watches Association

association CurrentTime between
    DateTime[*]
    DateTime[0..1] role now
end -- CurrentTime Association

association PeriodInterval between
    Period[*]
    DateTime[0..2] role interval ordered
end -- PeriodInterval Association

association OnlyLboard between
    Leaderboard[1] role lboard1
    Leaderboard[1] role lboard2
end -- OnlyLboard Association

association OnlyDict between
    Dictionary[1] role dict1
    Dictionary[1] role dict2
end -- OnlyDict Association



association Signal between
    Notification[*] role notifs
    Observable[1] role event
end -- Signal Association

association Notify between
    Notification[*] role notifs
    Player[1]
end -- Signals Association

composition PlayerChat between
    Chat[1] role chat
    Message[*] role messages ordered
end -- End PlayerChat Composition

association SentRequest between
    Player[1] role reqSender
    Request[*] role sentReqs
end -- End SentRequest Association

association RecievedRequest between
    Player[1] role reqRcvr
    Request[*] role rcvdReqs
end -- End RecievedRequest Association

association RequestMatch between
    MatchRequest[1] role matchReq
    Match[0..1]
end -- End RequestMatch Association

association SentMessage between
    Player[1] role msgSender
    Message[*] role sentMsgs
end -- End SentMessage Association

association RecievedMessage between
    Player[1] role msgRcvr
    Message[*] role rcvdMsgs
end -- End RecievedMessage Association

association Claim between
    Player[1]
    Report[*] role claims
end -- Claim Association

association Reported between
    Report[*] role reports
    Player[0..1] role reported --directed
end -- Reported Association


association MatchGameBoard between
    Match[1]
    Board[1]
end -- End MatchGameBoard Association

composition Grid between
    Board[1] qualifier (row: Integer, col: Integer)
    Slot[1] role slots
end -- End Grid Composition

aggregation Fill between
    Slot[0..1]
    Tile[0..1]
end -- End Fill Aggregation

association LetterOptions between
    TileBag[1]
    Board[1]
end -- End LetterOptions Association

aggregation Stock between
    TileBag[0..1]
    Tile[*] role tiles
end -- End Stock Aggregation

association WordCheck between
    Match[*] role matches
    Dictionary[1]
end -- End WordCheck Association

association ValidWord between
    Dictionary[1]
    Word[*] role words
end -- End ValidWord Association

association Spelling between
    Word[*] role words
    Letter[*] role letters ordered
end -- End Spelling Association

association Spelt between
    Play[*] role plays
    Word[*] role words
end -- End Spelt Association

association Plays between
    Match[1]
    Play[*] role playHistory ordered
end -- End Plays Association

aggregation Hold between
    Rack[0..1]
    Tile[0..9] role tiles
end -- End Hold Aggregation

association Played between
    Rack[1]
    Play[*] role plays
end -- End Played Association

association Use between
    Play[0..1]
    Tile[0..9] role tiles ordered
end -- End Use Association

association Mark between
    Tile[*] role tiles
    Letter[1]
end -- End Mark Association

----------------------------------Constraints---------------------------------

constraints
context Identifiable
    -- Each item has a unique id
    inv uniqueIDs: Identifiable.allInstances->forAll(i1, i2 |
        i1 <> i2 implies i1.id <> i2.id)
-- End Identifiable Constraints

--context Observer
--    -- Objects cannot observe themselves
--    inv noSelfObserving: observable->excludes(self)
---- End Observer Constraints

context DateTime
    inv dateIsValid: isSelfValid()

    -- There must only be one "today" in the system
    -- #DOUBLE-CHECK
    inv onlyOneCurrentTime:
        let
            now = DateTime.allInstances.now->asSet()->excluding(null)
        in (DateTime.allInstances->size() > 1 implies now->size() = 1) and
            now->forAll(t | t.oclIsTypeOf(DateTime))
-- End DateTime Constraints

context Period
    -- All Periods are valid
    inv allPeriodsAreValid: isSelfValid()
-- End Period Constraints

context Player
    -- Each Player has a unique username
    inv uniqueUsernames: Player.allInstances->forAll(p1, p2 |
        p1 <> p2 implies p1.username <> p2.username)

    -- Matches must be ordered
    inv matchesAreOrdered: matchHistory->forAll(m |
        let
            i = matchHistory->indexOf(m),
            prevMatches = matchHistory->subOrderedSet(1, i - 1)
        in matchHistory->first() <> m implies
            prevMatches->forAll(prevM |
                prevM.duration.getStart().before(m.duration.getStart())
            )
    )

    -- Blocked players can't be your friends
    inv notFriendAndBlocked:
        let
            allReqs = sentReqs->union(rcvdReqs),
            acceptedFrReqs = allReqs->select(req | req.type = #FRIEND and
                req.status = #ACCEPTED),
            friends = acceptedFrReqs.reqSender->union(acceptedFrReqs.reqRcvr)
                ->asSet()->excluding(self),
            blockedLst = block[player]
                ->select(b | b.status = #BLOCKED).blocked
        in friends->excludesAll(blocked)

    -- Cannot send requests to yourself
    inv noSelfReqsBlocks: sentReqs.reqRcvr->excludes(self) and
        blocked->excludes(self)

    -- All pending requests from players you block become lost and requests
    -- sent to them become recinded
    inv noPendingReqsWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not sentReqs->union(rcvdReqs)->exists(req |
                Set{req.reqSender, req.reqRcvr}->includes(b.blocked) and
                req.status = #PENDING))

    -- Players must not encounter players they have blocked in any match
    inv noMatchesWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not matchHistory->exists(m |
                m.players->includes(b.blocked) and
                m.duration.getStart().after(b.date))
        )

    -- There must not be any pending friend or message requests between a
    -- given pair of players if there exists an accepted request of the same
    -- type between them
    inv noPendingFriendOrMsgReqsIfAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type)),
            pending = frAndMsgReqs->select(req | req.status = #PENDING),
            accepted = frAndMsgReqs->select(req | req.status = #ACCEPTED)
        in pending->forAll(p | accepted->forAll(a |
            p.type = a.type implies
                (Set{p.reqSender, p.reqRcvr} -
                    Set{a.reqSender, a.reqRcvr})->size() > 0
        ))

    -- For a given pair or players, there may not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv noActiveMsgReqIfFriendReqAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                req.status = #ACCEPTED),
            msgReqs = allReqs->select(req | req.type = #MESSAGE and
                Set{#PENDING, #ACCEPTED}->includes(req.status))
        in frReqs->forAll(f | not msgReqs->exists(m |
            Set{f.reqSender, f.reqRcvr} = Set{m.reqSender, m.reqRcvr}
        ))

    -- For a given pair or players, there must not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv onlyOneAcceptedMsgOrFriendReqPerPair:
        let
            acceptedReqs = sentReqs->union(rcvdReqs)->select(req |
                req.status = #ACCEPTED and
                Set{#FRIEND,#MESSAGE}->includes(req.type))
        in acceptedReqs->forAll(a1 | not acceptedReqs->exists(a2 |
            a1 <> a2 and a1.type = a2.type and
                Set{a1.reqSender, a1.reqRcvr} = Set{a2.reqSender, a2.reqRcvr}
        ))

    -- Can only exchange match requests among friends
    inv onlyFriendsExchangeMatchReqs:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                Set{#ACCEPTED, #RECINDED}->includes(req.status)),
            matchReqs = allReqs->select(req | req.type = #MATCH)
        in matchReqs->forAll(mr | frReqs->exists(fr |
            Set{fr.reqSender, fr.reqRcvr} = Set{mr.reqSender, mr.reqRcvr} and
                fr.activePeriod.containsDate(mr.sentDate)
        ))

    -- Can only chat if one player has accepted a message or friend request
    -- from the other player
    inv onlyChatIfRequestAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type) and
                Set{#ACCEPTED, #RECINDED}->includes(req.status))
        in rcvdMsgs->forAll(m | frAndMsgReqs->exists(req |
            Set{req.reqSender, req.reqRcvr} = Set{m.msgSender, m.msgRcvr} and
                req.activePeriod.containsDate(m.sentDate)
        ))

    -- Enforcing this invariant would go against allowing players to go
    -- offline during a match.
    ---- players in match must have status in game
    --inv playerStatusConsistent:
    --    if matchHistory->any(m | m.status = #INPROGRESS) <> null then
    --        status = #PLAYING
    --    else
    --        status <> #PLAYING
    --    endif

    -- Can't play more than one match at a time
    inv onlyPlayingOneOrNoMatches:
        matchHistory->select(m | m.status = #INPROGRESS)->size() <= 1

    -- Players may only join up to one queue at a time
    inv onlyInOneQueue: queues->size() <= 1
-- End Player Constraints

context Chat
    -- Chats can only have 2 participants
    inv onlyTwoParticipants:
        let
            senders = messages.msgSender->asSet(),
            recipients = messages.msgRcvr->asSet()
        in participants->includesAll(senders) and
            participants->includesAll(recipients)

    -- Messages must be ordered
    inv messagesAreOrdered: messages->forAll(m |
        let
            i = messages->indexOf(m),
            previousMsgs = messages->subOrderedSet(1, i - 1)
        in messages->first() <> m implies
            previousMsgs->forAll(prevM | prevM.sentDate.before(m.sentDate)))
-- End Chat Constraints

context ChatState
    -- All messages from the other player before lastOpened date must be seen
    inv onlyMsgsAfterLastOpenedUnseen:
        chatRooms.messages->forAll(m |
            participants->excludes(m.msgSender) implies (
                (m.status = #UNSEEN and m.sentDate.after(lastOpened)) or
                (m.status = #SEEN and (not m.seenDate.after(lastOpened)))
            )
        )

    -- Can't send messages after closing the chat
    inv noSentMsgsAfterChatClosed: status = #CLOSED implies
        (not chatRooms.messages->exists(m |
            participants->includes(m.msgSender) and
            lastOpened.before(m.sentDate)))
-- End ChatState Constraints

context Message
    -- Each message must have a date
    inv hasDate: sentDate.oclIsKindOf(DateTime)

    -- Messages must have a body
    inv noEmptyMsgs: message.size() > 0

    -- Messages may only be seen after they have been sent
    inv validSeenDate: (status = #UNSEEN and seenDate = null) or
        (status = #SEEN and seenDate <> null and seenDate.after(sentDate))
-- End Message Constraints

context Request
    -- Each request must have a sent date
    inv hasSentDate: sentDate.oclIsKindOf(DateTime)

    -- Each accepted request must have an active period that starts after it
    -- was sentand must not have an end date that is set once the request is
    -- recinded
    inv validAcceptedReq: status = #ACCEPTED implies
        (activePeriod <> null and activePeriod.getStart().after(sentDate) and
        activePeriod.getEnd() = null)

    -- For each type of request, ther can only be one pending request between
    -- each unique pair of players.
    inv onlyOnePendingReqPerPlayerPair:
        let
            pending = Request.allInstances->select(req |
                req.status = #PENDING)
        in pending->forAll(r1, r2 |
            (r1 <> r2 and r1.type = r2.type) implies (
                (r1.reqSender <> r2.reqSender and r1.reqRcvr <> r2.reqRcvr) or
                (r1.reqSender <> r2.reqRcvr and r1.reqSender <> r2.reqRcvr))
        )
-- End Request Constraints

context MatchRequest
    -- All match requests have the type #MATCH
    inv matchReqTypeIsMatchReq: type = #MATCH

    -- Only accepted match requests may refer to a match
    inv noMatchUnlessAccepted:
        if status = #ACCEPTED then
            match->size() = 1
        else
            match->size() = 0
        endif

    -- Players may not request ranked matches
    inv noRankedMatchRequests: matchType <> #RANKED

    -- Accepted match type must match requested match type
    inv matchDataMatchesMatchReqData: status = #ACCEPTED implies
        (matchType = match.type and timed = match.timed and
        activePeriod.getStart() = match.duration.getStart())
-- End MatchRequest Constraints

context Report
    -- Only Player reports may be associated with more than one player
    inv onlyPlayerReportsHave2Players:
        if type = #PLAYER then
            reported->size() = 1
        else
            reported->size() = 0
        endif
-- End Report Constraints


context Join
    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: matchType = #RANKED implies timed
-- End Join Constraints

context Rack
    -- No empty spaces unless there are no more tiles in the tileBag
    inv noEmptySpaceUnlessLetterBagEmpty: tiles->size() = 9 or
        (tiles->size() < 9 and matchHistory.board.tileBag.tiles->size() = 0)
-- End Rack Constraints

context Play
    -- Plays must have a direction
    inv hasDirection: direction <> null

    -- Words must intersect or be spelt right alongside existing words
    -- or from the center of the board if all slots are empty
    inv intersectsWithAnotherWord:
        (type = #PLAY and match.playHistory->first() <> self) implies
            (let
                grid = match.board,
                r = startRow,
                c = startCol,
                tcnt = tiles->size()
            in if direction = #HORIZONTAL then
                    Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                        ans or
                        (grid.slots[r, c + o - 1].isEmpty() implies
                            (not Set{grid.slots[r - 1, c + o - 1].tile,
                            grid.slots[r + 1, c + o - 1].tile}->isEmpty()))
                    ) or grid.slots[r, c + tcnt].tile <> null
                else --if direction = #VERTICAL then
                    Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                        ans or
                        (grid.slots[r + o - 1, c].isEmpty() implies
                            (not Set{grid.slots[r + o - 1, c - 1].tile,
                            grid.slots[r + o - 1, c + 1].tile}->isEmpty()))
                    ) or grid.slots[r + tcnt, c].tile <> null
                endif
            )

    -- Plays do not extend beyond the board
    inv allTilesOnBoard: type = #PLAY implies
        (let
            grid = match.board
        in if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(c; ans: Integer = 0 |
                    if not grid.slots[startRow, c].isEmpty() and
                    grid.slots[startRow, c].filledAt.equals(time) then
                        ans + 1
                    else ans endif
                ) >= tiles->size()
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(r; ans: Integer = 0 |
                    if not grid.slots[r, startCol].isEmpty() and
                    grid.slots[r, startCol].filledAt.equals(time) then
                        ans + 1
                    else ans endif
                ) >= tiles->size()
            endif
        )

    -- Passed plays or match quits cant have any tiles
    inv passAndQuitHaveNoTiles: Set{#PASS, #QUIT}->includes(type) implies
        tiles->isEmpty()

    -- Only valid words may be spelt and only words spelt may be linked to
    -- a play
    inv allWordsSpeltAreValidAndOnlySpeltWordsLinked: type = #PLAY implies
        (let
            grid = match.board,

            -- All the slots that were filled by tiles provided by the rack
            -- this turn
            mainWordSlots = if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(
                c; ans: Sequence(Integer) = Sequence{} |
                    if (not grid.slots[startRow, c].isEmpty()) and
                    grid.slots[startRow, c].filledAt.equals(time) then
                        ans->append(c)
                    else ans endif
                )
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(
                r; ans: Sequence(Integer) = Sequence{} |
                    if (not grid.slots[r, startCol].isEmpty()) and
                    grid.slots[r, startCol].filledAt.equals(time) then
                        ans->append(r)
                    else ans endif
                )
            endif,

            mainWord = if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(c; ans: String = '' |
                    let
                        s = grid.slots[startRow, c]
                    in if not s.isEmpty() and
                        ((startCol + ans.size()) = c) then
                            ans + s.getTileString()
                        else ans endif
                )
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(r; ans: String = '' |
                    let
                        s = grid.slots[r, startCol]
                    in if not s.isEmpty() and
                        ((startRow + ans.size()) = r) then
                            ans + s.getTileString()
                        else ans endif
                )
            endif,

            secondaryWords = if direction = #HORIZONTAL then
                mainWordSlots->iterate(c; ans: Set(String) = Set{} |
                    let
                        word = Sequence{1..(startRow-1)}->reverse()->iterate(
                            r; top: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startRow - top.size()) = r)) then
                                        s.getTileString() + top
                                    else top endif
                            ) +
                            Sequence{startRow..15}->iterate(
                            r; bot: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startRow + bot.size()) = r)) then
                                        bot + s.getTileString()
                                    else bot endif
                            )
                    in if word.size() > 1 then
                            ans->including(word)
                        else ans endif
                )
            else --if direction = #VERTICAL then
                mainWordSlots->iterate(r; ans: Set(String) = Set{} |
                    let
                        word = Sequence{1..(startCol-1)}->reverse()->iterate(
                            c; left: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startCol - left.size()) = c)) then
                                        s.getTileString() + left
                                    else left endif
                            ) +
                            Sequence{startCol..15}->iterate(
                            c; right: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startCol + right.size()) = c)) then
                                        right + s.getTileString()
                                    else right endif
                            )
                    in if word.size() > 1 then
                            ans->including(word)
                        else ans endif
                )
            endif,

            allSpeltWords = secondaryWords->including(mainWord),

            allValidWords = match.dictionary.words
                ->iterate(w; wSet:Set(String) = Set{} |
                    wSet->including(w.getWord())
                ),

            allLinkedWords = words
                ->iterate(w; wSet:Set(String) = Set{} |
                    wSet->including(w.getWord())
                )
        in allValidWords->includesAll(allSpeltWords) and
            allSpeltWords->includesAll(allLinkedWords)
        )
-- End Play Constraints

context Board
    -- Must have 15 by 15 slots
    inv boardGridIsValid:
        Sequence{1..15}->iterate(r; ans: Set(Slot) = Set{} |
            ans->union(Sequence{1..15}->iterate(c; ans: Set(Slot) = Set{} |
                ans->including(slots[r, c])
            ))
        )->includesAll(slots)
-- End Board Constraints

context Tile
    -- Ensure Tiles have a valid point value
    inv validPoints: points > 0 and points <= 10

    -- Ensure that tiles are held by only one object at a time
    inv onlyInOnePlace:
        Set{tileBag, rack, slot}->excluding(null)->size() = 1
-- End Tile Constraints

context Slot
    -- Each slot must have a filledAt time if not empty
    inv hadFilledAtTimeIfFilled: (isEmpty() and filledAt = null) or
        ((not isEmpty()) and filledAt <> null)
-- End Slot Constraints

context Letter
    -- Ensure that the letter is valid
    inv validLetter: Set{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z'}->includes(letter)
-- End Letter Constraints

context Dictionary
    -- Only one dictionary for the lifecycle of the system
    inv onlyOneDictionaryInstance: Dictionary.allInstances->size() <= 1

    -- No duplicate words
    inv uniqueWords: words->forAll(w1, w2 |
            w1 <> w2 implies (not w1.equals(w2.getWord()))
        )
-- End Dictionary Constraints

context Match
    -- Each match must have a duration
    inv hasDuration: duration.oclIsKindOf(Period)

    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: type = #RANKED implies timed

    -- Plays must be ordered
    inv playsAreOrdered: playHistory->forAll(p |
        let
            i = playHistory->indexOf(p),
            previousPlays = playHistory->subOrderedSet(1, i - 1)
        in playHistory->first() <> p implies
            previousPlays->forAll(prevP | prevP.time.before(p.time)))

    -- First word must be spelt in the center
    inv firstPlayStartsAtCentre:
        let
            firstPlay = playHistory->first()
        in (firstPlay.startRow = 8 and firstPlay.startCol = 8)

    -- Plays must alternate between players, ie the game should be turn based
    inv playsAlternateBetweenPlayers:
        let
            player1 = playHistory->at(1).rack.players,
            player2 = playHistory->at(2).rack.players
        in playHistory->forAll(p |
            if playHistory->indexOf(p).mod(2) = 1 then
                player1 = p.rack.players
            else
                player2 = p.rack.players
            endif
        )

    -- Ensure all Tiles with the same letter have the same score
    inv consistentTilePointValues:
        let
            bagTiles = board.tileBag.tiles,
            rackTiles = rack.tiles,
            boardTiles = board.slots.tile,
            allTiles = bagTiles->union(rackTiles->union(boardTiles))
                ->excluding(null)
        in allTiles->forAll(t1, t2|
            t1.getLetter().equals(t2.getLetter()) implies
            t1.getPoints() = t2.getPoints())

    -- must be a fixed set of tiles in circulation for a given match
    inv fixedNumberOfLettersInMatch:
        let
            bagLetters = board.tileBag.tiles.letter->asSet(),
            rackLetters = rack.tiles.letter->asSet(),
            boardLetters = board.slots.tile.letter->asSet(),
            allTiles = bagLetters->union(rackLetters->union(boardLetters))
                ->excluding(null),
            count = allTiles->iterate(
                char; cnt:Tuple(a: Integer, b: Integer, c: Integer,
                d: Integer, e: Integer, f: Integer, g: Integer, h: Integer,
                i: Integer, j: Integer, k: Integer, l: Integer, m: Integer,
                n: Integer, o: Integer, p: Integer, q: Integer, r: Integer,
                s: Integer, t: Integer, u: Integer, v: Integer, w: Integer,
                x: Integer, y: Integer, z: Integer) =
                Tuple{a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0,
                h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0,
                p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0,
                x = 0, y = 0, z = 0} |
                    Tuple{
                    a = if char.letter = 'A' then cnt.a + 1 else cnt.a endif,
                    b = if char.letter = 'B' then cnt.b + 1 else cnt.b endif,
                    c = if char.letter = 'C' then cnt.c + 1 else cnt.c endif,
                    d = if char.letter = 'D' then cnt.d + 1 else cnt.d endif,
                    e = if char.letter = 'E' then cnt.e + 1 else cnt.e endif,
                    f = if char.letter = 'F' then cnt.f + 1 else cnt.f endif,
                    g = if char.letter = 'G' then cnt.g + 1 else cnt.g endif,
                    h = if char.letter = 'H' then cnt.h + 1 else cnt.h endif,
                    i = if char.letter = 'I' then cnt.i + 1 else cnt.i endif,
                    j = if char.letter = 'J' then cnt.j + 1 else cnt.j endif,
                    k = if char.letter = 'K' then cnt.k + 1 else cnt.k endif,
                    l = if char.letter = 'L' then cnt.l + 1 else cnt.l endif,
                    m = if char.letter = 'M' then cnt.m + 1 else cnt.m endif,
                    n = if char.letter = 'N' then cnt.n + 1 else cnt.n endif,
                    o = if char.letter = 'O' then cnt.o + 1 else cnt.o endif,
                    p = if char.letter = 'P' then cnt.p + 1 else cnt.p endif,
                    q = if char.letter = 'Q' then cnt.q + 1 else cnt.q endif,
                    r = if char.letter = 'R' then cnt.r + 1 else cnt.r endif,
                    s = if char.letter = 'S' then cnt.s + 1 else cnt.s endif,
                    t = if char.letter = 'T' then cnt.t + 1 else cnt.t endif,
                    u = if char.letter = 'U' then cnt.u + 1 else cnt.u endif,
                    v = if char.letter = 'V' then cnt.v + 1 else cnt.v endif,
                    w = if char.letter = 'W' then cnt.w + 1 else cnt.w endif,
                    x = if char.letter = 'X' then cnt.x + 1 else cnt.x endif,
                    y = if char.letter = 'Y' then cnt.y + 1 else cnt.y endif,
                    z = if char.letter = 'Z' then cnt.z + 1 else cnt.z endif}
                )
        in (count.a = 9 and count.b = 2 and count.c = 2 and count.d = 4 and
            count.e = 12 and count.f = 2 and count.g = 3 and count.h = 2 and
            count.i = 9 and count.j = 1 and count.k = 1 and count.l = 4 and
            count.m = 2 and count.n = 6 and count.o = 8 and count.p = 2 and
            count.q = 1 and count.r = 6 and count.s = 4 and count.t = 6 and
            count.u = 4 and count.v = 2 and count.w = 2 and count.x = 1 and
            count.y = 2 and count.z = 1)

    -- Players must be similar rank
    inv similarRank:
        players.rank->forAll(p1, p2 |
            (type = #RANKED and (p1.placement - p2.placement).abs() <= 100) or
            (matchReq->size() = 0 implies
                (p1.placement - p2.placement).abs() <= 200)
        )

    -- Once a match ends no additional plays can be made
    inv allPlaysWithinMatchDuration: playHistory->forAll(p |
        duration.containsDate(p.time))

    -- Ensures that the end date for a match corresponds with the final play
    -- if the match is finished or that there is no end date if the match is
    -- still going
    inv matchEndValid:
        let
            lp = playHistory->last(),
            dur = duration.duration()
        in (Set{#COMPLETE, #ABANDONED}->excludes(status) and
                duration.getEnd() = null) or
            (duration.getEnd() = lp.time and
                ((status = #ABANDONED and lp.type = #QUIT) or
                (status = #COMPLETE and
                    (score.abs() >= 100 or
                    (timed and dur > 0 and dur < 300))) --5 min
                )
            )

    -- Checks that no matches last longer than 30 days
    inv noIndefiniteMatches: not Match.allInstances->exists(m |
        (not m.timed) and (m.status = #INPROGRESS) and
        (m.duration.durationInDays() > 30))
-- End Match Constraints

context Leaderboard
    -- Only one Leaderboard for the lifetime of the system
    inv onlyOneLeaderboardInstance: Leaderboard.allInstances->size() <= 1

    -- All ranks are ordered
    inv ranksAreAccurateAndOrdered:
        rank->forAll(r |
            let
                i = rank->indexOf(r),
                higherRanks = rank->subOrderedSet(1, i - 1)
            in rank->first() <> r implies
                higherRanks->forAll(upperR |
                    (upperR.placement < r.placement and
                        upperR.players.score > r.players.score) or
                    (upperR.placement = r.placement and
                        upperR.players.score = r.players.score)
                ) and
                higherRanks.placement->asSet()->excludes(r.placement) implies
                    r.placement = i
        )
-- End Leaderboard Constraints

-- End All Constraints
