model scrumble --name of model

enum PlayerStatus {ONLINE, OFFLINE, AWAY, PLAYING}
enum ProfileState {PRIVATE, PUBLIC}
enum MatchType {RANKED, UNRANKED}
enum Category {ANIMAL, MUSIC, MOVIES, FOOD, BOOKS, COUNTRIES, NONE}
enum PlayType {PLAY, PASS, QUIT}
enum RequestStatus {PENDING, ACCEPTED, REJECTED, RECINDED, LOST}
enum MatchStatus {INPROGRESS, COMPLETE, ABANDONED}
enum RequestType {FRIEND, MESSAGE, MATCH}
enum BlockStatus {BLOCKED, UNBLOCKED}

-- #TODO
--     no rank restriction on requested matches
--     fix order checking constraints
--     remove endTime attribute
--     double check the date checking for valid match requests
--     match must be created if accepted
--     change message request to match request
--     change noUntimedRankedMatchRequests to noUntimedRankedMatches
--     add no ranked match requests/ only unranked match requests
--     can't send message requests to friends
--     not matched with blocked players
--     Fix match type matches requested match type
--     no empty messages
--     players cant interact with themselves
--     Add classes to handle game support (claim, claim status enum,
--         claims can be reporting players or bug reports)
--     Add attributes to represent the rest of the player's profile data

-- #DESIGN PATTERN REFINEMENTS
--     Observer Pattern
--         In the observer pattern, observables update observers when they
--         change creating the effect that the observer is "watching" the
--         observable. So observables have a list of theit observers and
--         call a method in the observer to let them know things changed.
--         The observer would then execute different operations to update
--         anything else that depends on the state of the observable object.

--     Suggestions for our system:
--         +------------------------+
--         | observer    | observes |
--         +-------------+----------+
--         | leaderboard | match    |
--         | player      | match    |
--         | match       | play     |
--         | chat        | message  |
--         +-------------+----------+

--     Note: Player observes match for status updates
--     Note: If we have notifications then the notification class would observe
--           anything that generated notifications

--     Singleton Pattern
--         1 to one associations of the class with itself

-- #ACL REFINEMENTS
--     Role-Based ACL for Admins and users.
--         Are we going to allow admins to play matches as well?

class Identifiable
attributes
    id: String
end -- Identifiable

--from Class
class Date
attributes
    day: Integer init: 1
    month: Integer init: 1
    year: Integer init: 1900
operations
    initialise(d: Integer, m: Integer, y: Integer)
    begin
        self.day := d;
        self.month := m;
        self.year := y;
    end

    pre parametersHaveValidValues: isValid(d, m, y)
    post attributesCorrectlyUpdated: 
        day = d and month = m and year = y

    -- Accessors
    getDay(): Integer = day
    getMonth(): Integer = month
    getYear(): Integer = year

    -- Mutators
    setDay(d: Integer)
    begin self.day := d; end
    pre newDateIsValid: isValid(d, month, year)
    post dayCorrectlyUpdated: day = d

    setMonth(m: Integer)
    begin self.month := m; end
    pre newDateIsValid: isValid(day, m, year)
    post monthCorrectlyUpdated: month = m

    setYear(y: Integer)
    begin self.year := y; end
    pre newDateIsValid: isValid(day, month, y)
    post yearCorrectlyUpdated: year = y

    -- returns true if all the attributes are not null, false otherwise
    isInitialised(): Boolean = day <> null and month <> null and
        year <> null
    post returnValueIsAccurate:
        result = Set{day <> null, month <> null, year <> null}->forAll(t | t = true)

    -- returns true if self is before d, false otherwise
    before(d: Date): Boolean = ((year < d.year) or
        (year = d.year and month < d.month) or
        (year = d.year and month = d.month and day < d.day))
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueIsAccurate:
        result = ((year < d.year) or
            (year = d.year and month < d.month) or
            (year = d.year and month = d.month and day < d.day)) = true

    -- returns true if self has the same values as d, false otherwise
    equals(d: Date): Boolean = day = d.day and month = d.month and
        year = d.year
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueConditions:
        result = Set{day = d.day, month = d.month, year = d.year}->forAll(t | t = true)

    -- returns true if self is after d, false otherwise
    after(d: Date): Boolean = (not equals(d)) and (not before(d))
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isValid(day, month, year) and
        isValid(d.day, d.month, d.year)
    post returnValueIsAccurate:
        result = Set{not equals(d), not before(d)}->forAll(t | t = true)

    -- returns true if y is a leap year, false otherwise
    isLeapYear(y: Integer): Boolean = 
        if (y.mod(400) = 0 or (y.mod(100) > 0 and y.mod(4) = 0)) then
                true
            else
                false
            endif
    pre yearIsValid: y <> null and y > 1900
    post returnValueIsAccurate: result = (y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)) = true

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v >= 1 and v <= 31

    monthValid(v: Integer): Boolean = v >= 1 and v <= 12
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v >= 1 and v <= 12

    yearValid(v: Integer): Boolean = v > 1900
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = v > 1900

    dayAndMonthValid(d: Integer, m: Integer): Boolean =
        (Set{4, 6, 9, 11}->includes(m) implies d <= 30) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d <= 31)
    pre dayIsValid: dayValid(d)
    pre monthIsValid: monthValid(m)
    post returnValueIsAccurate: result =
        (Set{4, 6, 9, 11}->includes(m) implies d < 31) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d < 32)

    febValid(d: Integer, y: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and 
        (not isLeapYear(y) implies d <= 28)
    pre dayIsValid: dayValid(d)
    pre yearIsValid: yearValid(y)
    post returnValueIsAccurate: result =
        (isLeapYear(y) implies d <= 29) and 
        (not isLeapYear(y) implies d <= 28)

    isValid(d: Integer, m: Integer, y: Integer): Boolean =
        dayValid(d) and monthValid(m) and yearValid(y) and
        dayAndMonthValid(d, m) and (m = 2 implies febValid(d, y))
end -- Date

class Player < Identifiable
attributes
    username: String
    email: String
    dob: Date
    score: Integer -- derived
    status: PlayerStatus
    state: ProfileState
end -- Player

class Message < Identifiable
attributes
    message: String
    date: Date --should be time
end -- Message

class Chat
end -- Chat

class Request < Identifiable
attributes
    status: RequestStatus init: #PENDING
    sentDate: Date
    addressedDate: Date
    recindedDate: Date
    type: RequestType
kend -- Request

class MatchRequest < Request
attributes
    matchType: MatchType
    timed: Boolean
end -- MatchRequest

associationclass Block
between
    Player[*] role player
    Player[*] role blocked
attributes
    date: Date
    status: BlockStatus
end -- Block

-------------------Game-------------------

associationclass Rack
between
    Player[2] role players
    Match[*] role matchHistory
end -- Rack

class Play < Identifiable
attributes
    type: PlayType
    startRow: Integer
    startCol: Integer
    endRow: Integer
    endCol: Integer
    score: Integer --/score: Integer
    time: Integer -- Time in seconds between match start and this play
    bonusApplied: Boolean
end -- Play

class Board
attributes
end -- Board

class Slot
attributes
    row: Integer
    column: Integer
end -- Slot

class Tile
attributes
    points: Integer
end -- Tile

class Letter
attributes
    letter: String
end -- Letter

class LetterBag
end -- LetterBag

class Word
attributes
    String: Word
    category:  Category
end -- Word

class Dictionary
end -- Dictionary

class Match < Identifiable
attributes
    type: MatchType
    timed: Boolean
    time: Integer -- Elapsed seconds
    endTime: Integer -- seconds
    date: Date
    category: Category
    status: MatchStatus
end -- Match

class Leaderboard
end -- Leaderboard

associationclass Rank
between
    Leaderboard[1]
    Player[*] role players ordered
attributes
    placement: Integer
end -- Rank

---------------Associations---------------

composition PlayerChat between
    Chat[1] role chat
    Message[*] role messages ordered
end

association ChatRooms between
    Chat[*] role chatRooms
    Player[2] role participants
end

association SentRequest between
    Player[1] role reqSender
    Request[*] role sentReqs
end

association RecievedRequest between
    Player[1] role reqRcvr
    Request[*] role rcvdReqs
end

association RequestMatch between
    MatchRequest[1] role matchReq
    Match[0..1]
end

association SentMessage between
    Player[1] role msgSender
    Message[*] role sentMsgs
end

association RecievedMessage between
    Player[1] role msgRcvr
    Message[*] role rcvdMsgs
end



association Observes between
    Leaderboard[1] role observer
    Match[*] role watches
end

association MatchGameBoard between
    Match[1]
    Board[1]
end

composition Grid between
    Board[1]
    Slot[*] role slots
end

aggregation Fill between
    Slot[1]
    Tile[0..1]
end

association LetterOptions between
    LetterBag[1] 
    Board[1]
end

aggregation Stock between
    LetterBag[1]
    Tile[*] role tiles
end

association WordCheck between
    Match[*] role matches
    Dictionary[1]
end

association ValidWord between
    Dictionary[1]
    Word[*] role words
end

association Spelling between
    Word[*] role words
    Letter[*] role letters ordered
end

association Spelt between
    Play[*] role plays
    Word[*] role words
end

association Plays between
    Match[1]
    Play[*] role playHistory ordered
end

aggregation Holds between 
    Rack[1]
    Tile[0..9] role tiles
end

association Played between
    Rack[1]
    Play[*] role plays
end

association Uses between
    Play[1]
    Tile[0..9] role tiles ordered
end

association Marked between
    Tile[*] role tiles
    Letter[1]
end

----------------Constraints---------------

constraints
context Identifiable
    -- Each item has a unique id
    inv uniqueIDs: Identifiable.allInstances->forAll(i1, i2 |
        i1 <> i2 implies i1.id <> i2.id)
-- End Identifiable Constraints

context Date
    inv dateIsValid: isValid(day, month, year)
-- End Date Constraints

context Player
    -- Each Player has a unique username
    inv uniqueUsernames: Player.allInstances->forAll(p1, p2 |
        p1 <> p2 implies p1.username <> p2.username)

    -- Blocked players can't be your friends
    inv notFriendAndBlocked:
        let
            fReqAccepted = sentReqs->select(req |
                req.type = #FRIEND and req.status = #ACCEPTED).reqRcvr,
            acceptedFReq = rcvdReqs->select(req |
                req.type = #FRIEND and req.status = #ACCEPTED).reqRcvr,
            friends = fReqAccepted->union(acceptedFReq)
        in friends->excludesAll(blocked)

    -- Cannot send requests to yourself
    inv noSelfRequests: sentReqs.reqRcvr->excludes(self)

    -- Can't receive requests from blocked players
    inv notReceiveRequestsFromBlocked:
        let
            blocks = block[player]->select(b | b.status = #BLOCKED)
        in blocks->forAll(b |
            let
                requests = rcvdReqs->select(r |
                    r.sentDate.after(b.date) and r.reqSender = b.blocked)
            in requests->forAll(req | req.status = #LOST)
        )

    -- Can't send requests to blocked players
    inv notSendRequestsToBlocked:
        let
            blocks = block[player]->select(b | b.status = #BLOCKED)
        in blocks->forAll(b | sentReqs->select(r |
            r.sentDate.after(b.date) and r.reqRcvr = b.blocked)->isEmpty()
        )

    -- Can only exchange match requests among friends
    inv onlyFriendsExchangeMatchRequests:
        let
            frReqsAccepted = sentReqs->select(req | req.type = #FRIEND and
                Set{#ACCEPTED, #RECINDED}->includes(req.status)),
            acceptedFrReqs = rcvdReqs->select(req | req.type = #FRIEND and
                Set{#ACCEPTED, #RECINDED}->includes(req.status))
        in rcvdReqs->select(req | req.type = #MATCH)->forAll(mr |
            (frReqsAccepted.reqRcvr->includes(mr.reqSender) and
            frReqsAccepted->select(req | req.reqRcvr = mr.reqSender)->iterate(req; ans:Boolean = false |
                ans or ((req.status = #ACCEPTED and mr.sentDate.after(req.addressedDate)) or
                    (req.status = #RECINDED and mr.sentDate.after(req.addressedDate) and
                        mr.sentDate.before(req.recindedDate)))
                )
            ) or
            (acceptedFrReqs.reqSender->includes(mr.reqSender) and
            acceptedFrReqs->select(req | req.reqSender = mr.reqSender)->iterate(req; ans:Boolean = false |
                ans or ((req.status = #ACCEPTED and mr.sentDate.after(req.addressedDate)) or
                    (req.status = #RECINDED and mr.sentDate.after(req.addressedDate) and
                        mr.sentDate.before(req.recindedDate)))
                )
            )
        )

    -- Can only chat if one player has accepted a message or friend request
    -- from the other player
    inv onlyChatIfRequestAccepted:
        let
            reqsAccepted = sentReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type) and
                Set{#ACCEPTED, #RECINDED}->includes(req.status)),
            acceptedReqs = rcvdReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type) and
                Set{#ACCEPTED, #RECINDED}->includes(req.status))
        in rcvdMsgs->forAll(m |
            (reqsAccepted.reqRcvr->includes(m.msgSender) and
            reqsAccepted->select(req | req.reqRcvr = m.msgSender)->iterate(req; ans:Boolean = false |
                ans or ((req.status = #ACCEPTED and m.date.after(req.addressedDate)) or
                    (req.status = #RECINDED and m.date.after(req.addressedDate) and
                        m.date.before(req.recindedDate)))
                )
            ) or
            (acceptedReqs.reqSender->includes(m.msgSender) and
            acceptedReqs->select(req | req.reqSender = m.msgSender)->iterate(req; ans:Boolean = false |
                ans or ((req.status = #ACCEPTED and m.date.after(req.addressedDate)) or
                    (req.status = #RECINDED and m.date.after(req.addressedDate) and
                        m.date.before(req.recindedDate)))
                )
            )
        )

    -- players in match must have status in game
    inv playerStatusConsistent:
        matchHistory->select(m | m.status = #INPROGRESS)->size() > 0 implies
        status = #PLAYING

    -- Can't play more than one match at a time
    inv onlyPlayingOneOrNoMatches:
        matchHistory->select(m | m.status = #INPROGRESS)->size() <= 1

    -- Ensure correct rankings are always assigned
    inv rankIsCorrect:
        Player.allInstances->forAll(p | p <> self implies (
            (p.rank.placement > rank.placement and p.score > score) or
            (p.rank.placement = rank.placement and p.score = score) or
            (p.rank.placement < rank.placement and p.score < score)))
-- End Player Constraints

context Chat
    -- Chats can only have 2 participants
    inv onlyTwoParticipants:
        let
            senders = messages.msgSender->asSet(),
            recipients = messages.msgRcvr->asSet()
        in participants->includesAll(senders) and 
            participants->includesAll(recipients)

    -- Messages must be ordered
    inv messagesAreOrdered: messages->forAll(m |
        let
            i = messages->indexOf(m),
            previousMsgs = messages->subOrderedSet(0, i)
        in messages->first() <> m implies
            previousMsgs->forAll(prevM | prevM.date.before(m.date)))
-- End Chat Constraints

context Request
    -- For each type of request, senders can only have one pending request
    -- per receiver
    inv onlyOnePendingReqPerSenderReceiverReqTypeTuple:
        let
            pending = Request.allInstances->select(req | req.status = #PENDING)
        in pending->forAll(r1, r2 | r1 <> r2 implies
            (r1.reqSender <> r2.reqSender or r1.reqRcvr <> r2.reqRcvr))

    -- Can only have one friend or message request pending per sender-receiver
    -- paring
    inv onlyOnePendingMsgFrReqPerPair:
        let
            pending = Request.allInstances->select(req | req.status = #PENDING and
                Set{#FRIEND, #MESSAGE}->includes(req.type))
        in pending->forAll(r1, r2 |
            r1.reqSender <> r2.reqRcvr or r1.reqRcvr <> r2.reqSender)

    -- Can only accept one friend or message request
    inv onlyOneAcceptedFriendOrMessageRequest:
        let
            pending = Request.allInstances->select(req | req.status = #ACCEPTED and
                Set{#FRIEND, #MESSAGE}->includes(req.type))
        in pending->forAll(r1, r2 | r1 <> r2 implies
            (r1.reqSender <> r2.reqSender or r1.reqRcvr <> r2.reqRcvr))

    -- Can't send any new friend or message requests to a player if
    -- they already accepted the last one
    inv noPendingRequestsIfAccepted:
        let
            frAndMsgReqs = Request.allInstances->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type)),
            pending = frAndMsgReqs->select(req | req.status = #PENDING),
            accepted = frAndMsgReqs->select(req | req.status = #ACCEPTED)
        in pending->forAll(p | accepted->forAll(a | 
            p.reqSender <> a.reqSender or p.reqRcvr <> a.reqRcvr))
-- End Request Constraints

context MatchRequest
    -- All message requests have the type #MESSAGE
    inv messageReqTypeIsMsgReq:
        MatchRequest.allInstances->forAll(mr | mr.type = #MESSAGE)

    -- Only accepted match requests may refer to a match
    inv noMatchUnlessAccepted:
        MatchRequest.allInstances->forAll(mr |
            (mr.status = #ACCEPTED and mr.match->size() = 1) or mr.match->size() = 0)

    -- Accepted match type must match requested match type
    inv matchTypeMatchesRequestedMatchType:
        MatchRequest.allInstances->forAll(mr |
            mr.status = #ACCEPTED implies
                (mr.matchType = mr.match.type) and mr.timed and mr.match.timed
        )

    -- Only unranked matches may be untimed
    inv noUntimedRankedMatchRequests: (matchType = #RANKED) implies timed
-- End MatchRequest Constraints

context Play
    -- Plays can only go in one direction
    inv oneDirection:
        (startRow = endRow and (endCol - startCol) >= 0) or
        (startCol = endCol and (endRow - startRow) >= 0)

    -- Words must intersect or be spelt right alongside existing words
    -- or from the center of the board if all slots are empty
    inv intersectsWithAnotherWord:
        (startRow = endRow and match.board.slots->select(s |
            (Set{startRow - 1, startRow + 1}->includes(s.row) and
                s.column >= startCol and s.column <= endCol)
            or
            (s.row = startRow and
                Set{startCol - 1, endCol + 1}->includes(s.column))
            ).tile->notEmpty()
        ) or
        (startCol = endCol and match.board.slots.select(s |
            (Set{startCol - 1, startCol + 1}->includes(s.column) and
                s.row >= startRow and s.column <= endRow)
            or
            (s.column = startCol and
                Set{startRow - 1, endRow + 1}->includes(s.row))
            ).tile->notEmpty()
        )

    -- Passed plays or match quits cant have any tiles
    inv passedPlayHasNoTiles: Set{#PASS, #QUIT}->includes(type) implies tiles->isEmpty()

    -- Only valid words may be spelt
    inv allWordsSpeltAreValidAndOnlySpeltWordsAreLinked:
        if type = #PLAY then
            if startRow = endRow then
                let
                    allSlots = match.board.slots,

                    -- Get all slots in the play range and slots adjoining each end
                    mainWordSlots = allSlots->select(s | s.row = startRow and
                        s.column >= (startCol - 1) and s.column <= (endCol + 1))->sortedBy(s | s.column),

                    mainWord = mainWordSlots->iterate(s; word:String = ''|
                        if s.tile->isEmpty() then
                            if s.column >= startCol and s.column <= endCol then
                                let
                                    slotIndex = mainWordSlots->indexOf(s),
                                    visitedSlots = mainWordSlots->subSequence(0, slotIndex),
                                    nextLetter = visitedSlots->iterate(ws; ans:Integer = 0 |
                                        if ws.tile->isEmpty() then ans + 1 else ans endif)
                                in word.concat(tiles->at(nextLetter).letter.letter)
                            else word endif
                        else
                            word.concat(s.tile.letter.letter)
                        endif
                    ),

                    secondaryWordsStart = mainWordSlots->select(s |
                        let
                            adjAbove = allSlots->select(as |
                                as.row = (s.row - 1) and as.column = s.column),
                            adjBelow = allSlots->select(as |
                                as.row = (s.row + 1) and as.column = s.column)
                        in s.tile->isEmpty() and s.column >= startCol and s.column <= endCol and
                            (adjAbove.tile->isEmpty() and adjBelow.tile->notEmpty()) or
                            (adjBelow.tile->isEmpty() and adjAbove.tile->notEmpty())
                    ),

                    secondaryWords = secondaryWordsStart.iterate(s; wordLst:Set(String) = Set{} |
                        let
                            complete = false,

                            above = allSlots->select(as | as.row = (s.row - 1) and
                                as.column = s.column).tile->notEmpty(),

                            wordSlots = allSlots->select(ws |
                                if above and ws.column = s.column then
                                    ws.row >= s.row
                                else
                                    ws.row <= s.row
                                endif
                            )->sortedBy(ws | ws.row),

                            wordSlots = if above then wordSlots->reverse() else wordSlots endif
                        in wordLst->including(wordSlots->iterate(ws; word:String = '' |
                            let
                                complete = ws.tile->isEmpty()
                            in
                                if not complete then
                                    if not above then
                                        word.concat(ws.tile.letter.letter)
                                    else
                                        ws.tile.letter.letter.concat(word)
                                    endif
                                else word endif
                        ))
                    ),

                    allSpeltWords = secondaryWords->including(mainWord),

                    allValidWords = match.dictionary.words->iterate(w; wSet:Set(String) = Set{} |
                        wSet->including(w.letters->iterate(l; wordStr:String = '' |
                            wordStr.concat(l.letter)
                        ))
                    ),

                    allLinkedWords = words->iterate(w; wSet:Set(String) = Set{} |
                        wSet->including(w.letters->iterate(l; wordStr:String = '' |
                            wordStr.concat(l.letter)
                        ))
                    )
                in allValidWords->includesAll(allSpeltWords) and
                    allSpeltWords->includesAll(allLinkedWords)
            else false endif
            or
            if startCol = endCol then
                let
                    allSlots = match.board.slots,

                    -- Get all slots in the play range and slots adjoining each end
                    mainWordSlots = allSlots->select(s | s.column = startCol and
                        s.row >= (startRow - 1) and s.row <= (endRow + 1))->sortedBy(s | s.row),

                    mainWord = mainWordSlots->iterate(s; word:String = ''|
                        if s.tile->isEmpty() then
                            if s.row >= startRow and s.row <= endRow then
                                let
                                    slotIndex = mainWordSlots->indexOf(s),
                                    visitedSlots = mainWordSlots->subSequence(0, slotIndex),
                                    nextLetter = visitedSlots->iterate(ws; ans:Integer = 0 |
                                        if ws.tile->isEmpty() then ans + 1 else ans endif)
                                in word.concat(tiles->at(nextLetter).letter.letter)
                            else word endif
                        else
                            word.concat(s.tile.letter.letter)
                        endif
                    ),

                    secondaryWordsStart = mainWordSlots->select(s |
                        let
                            adjAbove = allSlots->select(as |
                                as.column = (s.column - 1) and as.row = s.row),
                            adjBelow = allSlots->select(as |
                                as.column = (s.column + 1) and as.row = s.row)
                        in s.tile->isEmpty() and s.row >= startRow and s.row <= endRow and
                            (adjAbove.tile->isEmpty() and adjBelow.tile->notEmpty()) or
                            (adjBelow.tile->isEmpty() and adjAbove.tile->notEmpty())
                    ),

                    secondaryWords = secondaryWordsStart.iterate(s; wordLst:Set(String) = Set{} |
                        let
                            complete = false,

                            above = allSlots->select(as | as.column = (s.column - 1) and
                                as.row = s.row).tile->notEmpty(),

                            wordSlots = allSlots->select(ws |
                                if above and ws.row = s.row then
                                    ws.column >= s.column
                                else
                                    ws.column <= s.column
                                endif
                            )->sortedBy(ws | ws.column),

                            wordSlots = if above then wordSlots->reverse() else wordSlots endif
                        in wordLst->including(wordSlots->iterate(ws; word:String = '' |
                            let
                                complete = ws.tile->isEmpty()
                            in
                                if not complete then
                                    if not above then
                                        word.concat(ws.tile.letter.letter)
                                    else
                                        ws.tile.letter.letter.concat(word)
                                    endif
                                else word endif
                        ))
                    ),

                    allSpeltWords = secondaryWords->including(mainWord),

                    allValidWords = match.dictionary.words->iterate(w; wSet:Set(String) = Set{} |
                        wSet->including(w.letters->iterate(l; wordStr:String = '' |
                            wordStr.concat(l.letter)
                        ))
                    ),

                    allLinkedWords = words->iterate(w; wSet:Set(String) = Set{} |
                        wSet->including(w.letters->iterate(l; wordStr:String = '' |
                            wordStr.concat(l.letter)
                        ))
                    )
                in allValidWords->includesAll(allSpeltWords) and
                    allSpeltWords->includesAll(allLinkedWords)
            else false endif
        else true endif

    -- Verify that a bonus is to be applied
    inv bonusCorrectlyFlagged:
        words.category->includes(match.category) and bonusApplied

    -- Score calculation verification
    inv scoreCorrectlyCalculated:
        let
            multiplier = if bonusApplied then 1.5 else 1 endif,
            tiles = rack.tiles->union(match.board.slots.tile)->asSet(),
            flatScore = words->iterate(w; ans:Integer = 0 |
                    ans + w.letters->iterate(l; ws:Integer = 0 |
                        ws + tiles->select(t | t.letter.letter = l.letter)->asSequence()->at(0).points
                    )
                )
        in score = if bonusApplied then (flatScore * multiplier) else flatScore endif
-- End Play Constraints

context Board
    -- Must have 15 by 15 slots
    inv boardSizeIsValid: slots->forAll(s |
        s.row > 0 and s.row <= 15 and s.column > 0 and s.column <= 15)
-- End Board Constraints

context Tile
    -- Ensure Tiles have a valid point value
    inv validPoints: points > 0 and points <= 10
-- End Tile Constraints

context Letter
    -- Ensure that the letter is valid
    inv validLetter: Set{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z'
    }->includes(letter)
-- End Letter Constraints

context Word
    -- No duplicate words
    inv uniqueWords: Word.allInstances->forAll(w1, w2 |
            if w1 <> w2 then
                let
                    word1 = w1.letters->iterate(l; word:String = '' |
                        word.concat(l.letter)),
                    word2 = w2.letters->iterate(l; word:String = '' |
                        word.concat(l.letter))
                in not word1.equalsIgnoreCase(word2)
            else true endif
        )
-- End Word Constraints

context Dictionary
    -- Only one dictionary for the lifecycle of the system
    inv onlyOneDictionaryInstance: Dictionary.allInstances->size() <= 1
-- End Dictionary Constraints

context Match
    -- Only unranked matches may be untimed
    inv noUntimedRankedMatchRequests: (type = #RANKED) implies timed

    -- Plays must be ordered
    inv playsAreOrdered: playHistory->forAll(p |
        let
            i = playHistory->indexOf(p),
            previousPlays = playHistory->subOrderedSet(0, i)
        in playHistory->first() <> p implies
            previousPlays->forAll(prevP | prevP.time < p.time))

    -- First word must be spelt in the center
    inv firstPlayStartsAtCentre:
        let
            firstPlay = playHistory->first()
        in (firstPlay.startRow = 8 and firstPlay.startCol = 8)

    -- Plays must alternate between players, ie the game should be turn based
    inv playsAlternateBetweenPlayers:
        let
            player1 = playHistory->at(0).rack.players,
            player2 = playHistory->at(1).rack.players
        in playHistory->iterate(p; result:Boolean = true |
                if playHistory->indexOf(p).mod(2) = 0 then
                    result = result and (player1 = p)
                else
                    result = result and (player2 = p)
                endif
            )

    -- Ensure all Tiles with the same letter have the same score
    inv consistentTilePointValues:
        let
            bagTiles = board.letterBag.tiles,
            rackTiles = rack.tiles,
            boardTiles = board.slots.tile,
            allTiles = bagTiles->union(rackTiles->union(boardTiles))
        in allTiles->forAll(t1, t2|
            t1.letter.letter = t2.letter.letter implies t1.points = t2.points)

    -- must be a fixed set of tiles in circulation for a given match
    inv fixedNumberOfLettersInMatch:
        let
            bagLetters = board.letterBag.tiles.letter,
            rackLetters = rack.tiles.letter,
            boardLetters = board.slots.tile.letter,
            allTiles = bagLetters->union(rackLetters->union(boardLetters)),
            a = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('A') then cnt + 1 else cnt endif),
            b = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('B') then cnt + 1 else cnt endif),
            c = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('C') then cnt + 1 else cnt endif),
            d = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('D') then cnt + 1 else cnt endif),
            e = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('E') then cnt + 1 else cnt endif),
            f = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('F') then cnt + 1 else cnt endif),
            g = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('G') then cnt + 1 else cnt endif),
            h = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('H') then cnt + 1 else cnt endif),
            i = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('I') then cnt + 1 else cnt endif),
            j = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('J') then cnt + 1 else cnt endif),
            k = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('K') then cnt + 1 else cnt endif),
            l = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('L') then cnt + 1 else cnt endif),
            m = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('M') then cnt + 1 else cnt endif),
            n = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('N') then cnt + 1 else cnt endif),
            o = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('O') then cnt + 1 else cnt endif),
            p = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('P') then cnt + 1 else cnt endif),
            q = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Q') then cnt + 1 else cnt endif),
            r = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('R') then cnt + 1 else cnt endif),
            s = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('S') then cnt + 1 else cnt endif),
            t = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('T') then cnt + 1 else cnt endif),
            u = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('U') then cnt + 1 else cnt endif),
            v = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('V') then cnt + 1 else cnt endif),
            w = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('W') then cnt + 1 else cnt endif),
            x = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('X') then cnt + 1 else cnt endif),
            y = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Y') then cnt + 1 else cnt endif),
            z = allTiles->iterate(char; cnt:Integer = 0 |
                if char.letter.equalsIgnoreCase('Z') then cnt + 1 else cnt endif)
        in (a = 9 and b = 2 and c = 2 and d = 4 and e = 12 and f = 2 and
            g = 3 and h = 2 and i = 9 and j = 1 and k = 1 and l = 4 and
            m = 2 and n = 6 and o = 8 and p = 2 and q = 1 and r = 6 and
            s = 4 and t = 6 and u = 4 and v = 2 and w = 2 and x = 1 and
            y = 2 and z = 1)

    -- Players must be similar rank
    inv similarRank:
        players.rank->forAll(p1, p2 |
            (type = #RANKED and (p1.placement - p2.placement).abs() <= 100) or
            (p1.placement - p2.placement).abs() <= 200)

    -- Once a player quits the match must end
    inv matchEndIfQuit:
        (playHistory->select(p | p.type = #QUIT)->size() <= 1 implies
            playHistory->last().type = #QUIT) and
        playHistory->last().type = #QUIT implies status = #ABANDONED

    -- Once a match ends no additional plays can be made
    inv noPlaysAfterMatchEnd:
        status = #ABANDONED implies playHistory->last().type = #QUIT and
        status = #COMPLETE implies playHistory->forAll(p | p.time < endTime)

    -- Matches can't last longer than 5 min
    inv matchEndTimeValid:
        status = #COMPLETE implies (endTime > 0 and endTime < 300) -- 5 minutes
-- End Match Constraints

context Leaderboard
    -- Only one Leaderboard for the lifetime of the system
    inv onlyOneLeaderboardInstance: Leaderboard.allInstances->size() <= 1
-- End Leaderboard Constraints
end