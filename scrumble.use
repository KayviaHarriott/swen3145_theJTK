------------------------------------------------------------------------------
--! @authors: Jason Hunter, Kayvia Harriott, Tashna-Gail Williams
--! Created on: 2021-10-11
--! @version: 0.5.7
--! Last Updated: 2021-12-01 17:13:05
------------------------------------------------------------------------------

model scrumble

------------------------------------------------------------------------------
-- Enumerations
------------------------------------------------------------------------------

enum Action {
    viewPlayerProfile,
    sendFriendRequest,
    sendMessageRequest,
    sendMatchRequest,
    sendMessage,

    addWord,
    deprecateWord,
    banPlayer,
    openReport,
    closeReport
}

enum BlockStatus {BLOCKED, UNBLOCKED}
enum ChatStatus {OPEN, CLOSED}
enum MatchStatus {INPROGRESS, COMPLETE, ABANDONED}
enum MessageStatus {UNSEEN, SEEN}
enum PlayerStatus {ONLINE, OFFLINE, AWAY, PLAYING, BANNED}
enum ReportStatus {UNRESOLVED, UNDER_REVIEW, RESOLVED}
enum RequestStatus {PENDING, ACCEPTED, REJECTED, RECINDED, LOST}
enum WordStatus {VALID, DEPRECATED}

enum MatchType {RANKED, UNRANKED}
enum PlayType {PLAY, PASS, QUIT}
enum ReportType {BUG, PLAYER}
enum RequestType {FRIEND, MESSAGE, MATCH}

enum Category {ANIMAL, MUSIC, MOVIES, FOOD, BOOKS, COUNTRIES, NONE}
enum ProfileState {PRIVATE, PUBLIC}
enum PlayDirection {HORIZONTAL, VERTICAL}

--! @TODO:
--!     - Add in permission checks in pre conditions for restricted operations
--!     - Add attributes to represent the rest of the player's profile data
--!     - Figure out how to manage adding and removing words since you
--!       wouldn't want changes to affect past games
--!     - Add pre and post conditions to check that the friends role of a
--!       player is properly updated when friend requests are accepted or
--!       recinded as well as the permissions granted are updated accordingly

------------------------------------------------------------------------------
-- Classes
------------------------------------------------------------------------------

-------------------------------Abstract Classes-------------------------------

abstract class Identifiable
attributes
    id: String
end -- Identifiable

abstract class Observer
operations
    --! update doc
    --! @brief This is the method called by the observable to update the
    --!        Observer
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    begin end
    -- #TODO Pre and Post
    pre argIsValid: o <> null
    post noPost: true
end -- Observer Class

abstract class Observable
operations
    --! notify doc
    --! @brief Loops through all the observers and calls update for each of
    --!        them
    notify()
    begin
        for o in self.observer do
            o.update(self);
        end;
    end
    pre hasObservers: not observer->isEmpty()
    post noPost: true
end -- Observable Class

-----------------------------------Datatypes----------------------------------

class DateTime
attributes
    TO_SEC: Tuple(y: Integer, d: Integer, hr: Integer, min: Integer) init:
        Tuple{y = 31557600, d = 86400, hr = 3600, min = 60}
    -- 31557600 is the number of seconds in a year
    -- 86400 is the number of seconds in a day
    -- 3600 is the number of seconds in an hour
    -- 60 is the number of seconds in a minute

    EPOSH: Tuple(
        y: Integer, m: Integer, d: Integer,
        hr: Integer, min: Integer, sec: Integer
    ) init: Tuple{y = 2000, m = 1, d = 1, hr = 0, min = 0, sec = 0}

    -- Initialized to this system's eposh time 2000-01-01 00:00:00
    day: Integer init: EPOSH.d
    month: Integer init: EPOSH.m
    year: Integer init: EPOSH.y
    hour: Integer init: EPOSH.hr
    minute: Integer init: EPOSH.min
    second: Integer init: EPOSH.sec
    secondsSinceEposh: Integer derived:
        toSecondsSinceEposh(year, month, day, hour, minute, second)
operations
    --! makeHumanReadable doc
    --! @brief Takes a duration in seconds and it into years, months, days
    --!        hours, minutes and seconds
    --!
    --! @param Integer sec The number of seconds since the eposh time
    --! @return Tuple(y: Integer, m: Integer, d: Integer,
    --!         hr: Integer, min: Integer, sec: Integer)
    makeHumanReadable(sec: Integer): Tuple(
    y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer) =
        let
            yearsSince = sec div TO_SEC.y,
            leapDayCorrection = (yearsSince div 400) - (yearsSince div 100),
            years = EPOSH.y + yearsSince,
            remDays = sec.mod(TO_SEC.y) div TO_SEC.d + leapDayCorrection + 1,
            daysOfEachMonth = if isLeapYear(years) then
                    Sequence{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                else
                    Sequence{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                endif,
            months = 1 + Sequence{1..12}->iterate(m2; ans: Integer = 0 |
                if (daysOfEachMonth->subSequence(1, m2)->sum() < remDays) then
                    ans + 1
                else
                    ans
                endif),
            days = remDays - (if months > 1 then
                    daysOfEachMonth->subSequence(1, months - 1)->sum()
                else 0 endif),
            hours = sec.mod(TO_SEC.y).mod(TO_SEC.d) div TO_SEC.hr,
            minutes = sec.mod(TO_SEC.y).mod(TO_SEC.d)
                .mod(TO_SEC.hr) div TO_SEC.min,
            seconds = sec.mod(TO_SEC.y).mod(TO_SEC.d)
                .mod(TO_SEC.hr).mod(TO_SEC.min)
        in Tuple{y = years, m = months, d = days,
            hr = hours, min = minutes, sec = seconds}

    pre argIsValid: sec > 0
    post resultIsValid: isValid(result.y, result.m, result.d,
        result.hr, result.min, result.sec)

    --! toSecondsSinceEposh doc
    --! @brief Converts the human-readable date to the number of seconds
    --!        since the eposh time
    --!
    --! @param Integer y The year of the time to be converted
    --! @param Integer m The month of the time to be converted
    --! @param Integer d The day of the time to be converted
    --! @param Integer hr The hour of the time to be converted
    --! @param Integer min The minute of the time to be converted
    --! @param Integer sec The second of the time to be converted
    --! @return Integer
    toSecondsSinceEposh(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer): Integer =
        let
            years = y - EPOSH.y,
            leapDayCorrection = (years div 400) - (years div 100),
            daysOfEachMonth = if isLeapYear(y) then
                    Sequence{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                else
                    Sequence{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                endif,
            days = d + Sequence{1..(m - 1)}->iterate(prevM; ans: Integer = 0 |
                ans + daysOfEachMonth->at(prevM)) + leapDayCorrection - 1
        in (years * TO_SEC.y) + (days * TO_SEC.d) +
            (hr * TO_SEC.hr) + (min * TO_SEC.min) + sec

    pre argsAreValid: isValid(y, m, d, hr, min, sec)
    post resultIsValid:
        let
            date = makeHumanReadable(result)
        in result >= 0 and y = date.y and m = date.m and d = date.d and
            hr = date.hr and min = date.min and sec = date.sec

    --! initialise doc
    --! @brief Initialises the datetime instance
    --!
    --! @param Integer y The year to set the datetime to
    --! @param Integer m The month to set the datetime to
    --! @param Integer d The day to set the datetime to
    --! @param Integer hr The hour to set the datetime to
    --! @param Integer min The minute to set the datetime to
    --! @param Integer sec The second to set the datetime to
    initialise(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer)
    begin
        self.year := y;
        self.month := m;
        self.day := d;
        self.hour := hr;
        self.minute := min;
        self.second := sec;
    end

    pre parametersHaveValidValues: isValid(y, m, d, hr, min, sec)
    post attributesCorrectlyUpdated:
        day = d and month = m and year = y and
        hour = hr and minute = min and second = sec

    ---------------------------------Accessors--------------------------------

    getYear(): Integer = year
    getMonth(): Integer = month
    getDay(): Integer = day

    getHour(): Integer = hour
    getMinute(): Integer = minute
    getSecond(): Integer = second

    getNow(): DateTime = now
    post resultNotNull: result <> null

    ---------------------------------Mutators---------------------------------

    setYear(y: Integer)
    begin self.initialise(y, self.month, self.day,
        self.hour, self.minute, self.second); end
    post yearCorrectlyUpdated: year = y

    setMonth(m: Integer)
    begin self.initialise(self.year, m, self.day,
        self.hour, self.minute, self.second); end
    post monthCorrectlyUpdated: month = m

    setDay(d: Integer)
    begin self.initialise(self.year, self.month, d,
        self.hour, self.minute, self.second); end
    post dayCorrectlyUpdated: day = d

    setHour(h: Integer)
    begin self.initialise(self.year, self.month, self.day,
        h, self.minute, self.second); end
    post mutationSuccess: hour = h

    setMinute(m: Integer)
    begin self.initialise(self.year, self.month, self.day,
        self.hour, m, self.second); end
    post mutationSuccess: minute = m

    setSecond(s: Integer)
    begin self.initialise(self.year, self.month, self.day,
        self.hour, self.minute, s); end
    post mutationSuccess: second = s

    setToNow()
    begin self.initialise(self.now.year, self.now.month, self.now.day,
        self.now.hour, self.now.minute, self.now.second); end
    post mutationSuccess: self.equals(now)

    -- Moves the time forward by the specified number of seconds
    advance(sec: Integer)
    begin
        declare d: Tuple(y: Integer, m: Integer, d: Integer,
            hr: Integer, min: Integer, sec: Integer);
        d := self.makeHumanReadable(self.secondsSinceEposh + sec);

        self.year := d.y;
        self.month := d.m;
        self.day := d.d;
        self.hour := d.hr;
        self.minute := d.min;
        self.second := d.sec;
    end

    pre argIsValid: sec >= 0
    post mutationSuccess: toSecondsSinceEposh(year, month, day,
        hour, minute, second) = secondsSinceEposh

    -- Moves the time forward by the specified number of days
    advanceDays(d: Integer)
    begin self.advance(self.TO_SEC.d * d) end
    pre argIsValid: d >= 0
    post noPost: true

    --------------------------------Predicates--------------------------------

    -- returns true if all the attributes are not null, false otherwise
    isInitialised(): Boolean =
        day <> null and month <> null and year <> null and
        hour <> null and minute <> null and second <> null and
        secondsSinceEposh >= 0
    post returnValueIsAccurate:
        result = Set{day <> null, month <> null, year <> null,
            hour <> null, minute <> null, second <> null,
            secondsSinceEposh >= 0}
            ->forAll(t | t = true)

    -- returns true if self is before d, false otherwise
    before(d: DateTime): Boolean = secondsSinceEposh < d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueIsAccurate:
        result = (secondsSinceEposh < d.secondsSinceEposh) -- = true

    -- returns true if self has the same values as d, false otherwise
    equals(d: DateTime): Boolean = secondsSinceEposh = d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueConditions:
        result = (secondsSinceEposh < d.secondsSinceEposh)

    -- returns true if self is after d, false otherwise
    after(d: DateTime): Boolean = secondsSinceEposh > d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueIsAccurate:
        result = (secondsSinceEposh > d.secondsSinceEposh)

    -- returns true if y is a leap year, false otherwise
    isLeapYear(y: Integer): Boolean = y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)
    pre yearIsValid: y <> null and y >= 2000
    post returnValueIsAccurate: result = (y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)) -- = true

    secondValid(v: Integer): Boolean = v >= 0 and v < 60
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v < 60)

    minuteValid(v: Integer): Boolean = v >= 0 and v <= 59
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v <= 59)

    hourValid(v: Integer): Boolean = v >= 0 and v < 24
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v < 24)

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 1 and v <= 31)

    monthValid(v: Integer): Boolean = v >= 1 and v <= 12
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 1 and v <= 12)

    yearValid(v: Integer): Boolean = v >= 2000
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 2000)

    dayAndMonthValid(m: Integer, d: Integer): Boolean =
        (Set{4, 6, 9, 11}->includes(m) implies d <= 30) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d <= 31)
    pre dayIsValid: dayValid(d)
    pre monthIsValid: monthValid(m)
    post returnValueIsAccurate: result =
        ((Set{4, 6, 9, 11}->includes(m) implies d < 31) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d < 32))

    febValid(y: Integer, d: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28)
    pre dayIsValid: dayValid(d)
    pre yearIsValid: yearValid(y)
    post returnValueIsAccurate: result =
        ((isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28))

    isValid(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer): Boolean =
        dayValid(d) and monthValid(m) and yearValid(y) and
        dayAndMonthValid(m, d) and (m = 2 implies febValid(y, d)) and
        hourValid(hr) and minuteValid(min) and secondValid(sec)

    isSelfValid(): Boolean = isValid(year, month, day, hour, minute, second)

    equalsNow(): Boolean = self.equals(self.now)
    pre nowExists: not now->isEmpty()

    --------------------------------Operations--------------------------------

    difference(d: DateTime): Integer =
        secondsSinceEposh - d.secondsSinceEposh
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post resultIsCorrect: result =
        (secondsSinceEposh - d.secondsSinceEposh)

    differenceInDays(d: DateTime): Real = (difference(d) / TO_SEC.d)
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post resultIsCorrect: result =
        ((secondsSinceEposh - d.secondsSinceEposh) / TO_SEC.d)
end -- DateTime Class

class Period
operations
    --------------------------------Predicates--------------------------------

    -- Returns true if the period has a start date or has a start and end date
    -- and the start date is before the end date
    isValid(startDate: DateTime, endDate: DateTime): Boolean =
        startDate <> null and startDate.isInitialised() and
        (endDate <> null implies startDate.before(endDate))
    pre startDateValid: startDate <> null implies startDate.isSelfValid()
    pre endDateValid: endDate <> null implies endDate.isSelfValid()
    post resultIsCorrect: result = (startDate <> null and
        startDate.isInitialised() and
        (endDate <> null implies startDate.before(endDate)))

    -- Returns true if the current period is valid
    isSelfValid(): Boolean = isValid(getStart(), getEnd())

    -- Returns true if the end date for the current period is before the start
    -- date of the period passed as an argument
    before(p: Period): Boolean = getEnd().before(p.getStart())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = getEnd().before(p.getStart())

    -- Returns true if the start date for the current period is after the end
    -- date of the period passed as an argument
    after(p: Period): Boolean = getStart().after(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = getStart().after(p.getEnd())

    -- Returns true if the start and end of both periods is equal
    equals(p:Period): Boolean = getStart().equals(p.getStart()) and
        getEnd().equals(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (getStart().equals(p.getStart()) and
        getEnd().equals(p.getEnd()))

    -- Returns true if the current period starts before and ends after
    -- the period passed as an argument
    contains(p: Period): Boolean = containsDate(p.getStart()) and
        containsDate(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (containsDate(p.getStart()) and
        containsDate(p.getEnd()))

    -- Returns true if the end date for the current period falls within the
    -- range of the period passed as an argument and the start date doesn't
    overlapsOnLeftOf(p: Period): Boolean =
        getStart().before(p.getStart()) and p.containsDate(getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (getStart().before(p.getStart()) and
        p.containsDate(getEnd()))

    -- Returns true if the start date for the current period falls within the
    -- range of the period passed as an argument and the end date doesn't
    overlapsOnRightOf(p: Period): Boolean =
        p.containsDate(getStart()) and getEnd().after(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (p.containsDate(getStart()) and
        getEnd().after(p.getEnd()))

    -- Returns true if the current period starts before and ends after
    -- the period passed as an argument
    containsDate(d: DateTime): Boolean = (not getStart().after(d)) and
        (getEnd() <> null implies (not getEnd().before(d)))
    pre selfAndArgsAreValid: isSelfValid() and d.isSelfValid()
    post noMutations: interval = interval@pre and  d = d@pre
    post resultIsCorrect: result = (getStart().before(d) and
        (getEnd() <> null implies getEnd().after(d)))

    ---------------------------------Accessors--------------------------------

    -- Returns the start date of the period
    getStart(): DateTime = interval->at(1)
    post noMutations: interval = interval@pre
    post resultIsCorrect: result = interval->at(1)

    -- Returns the end date of the period
    getEnd(): DateTime = interval->at(2)
    post noMutations: interval = interval@pre
    post resultIsCorrect: result = interval->at(2)

    ---------------------------------Mutators---------------------------------

    -- Adds a start date if no dates are assigned to the period
    addStart(s: DateTime)
    begin insert (self, s) into PeriodInterval; end
    pre selfNotInit: getStart() = null and getEnd() = null
    pre argIsValid: s.isSelfValid()
    post mutationSuccess: getStart() = s and getEnd() = interval@pre->at(2)
    post selfIsValid: isSelfValid()

    -- Adds an end date if a start date is specified
    addEnd(s: DateTime)
    begin insert (self, s) into PeriodInterval; end
    pre selfAndArgsAreValid: isSelfValid() and s.isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = s
    post selfStillValid: isValid(getStart(), getEnd())

    -- Removes start date if no end date is specified
    removeStart()
    begin delete (self, getStart()) from PeriodInterval end
    pre selfIsValid: isSelfValid()
    post selfNotInit: getStart() = null and getEnd() = null

    -- Removes the end date
    removeEnd()
    begin delete (self, getEnd()) from PeriodInterval end
    pre selfIsValid: isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = null

    -- Replaces start date with the new date
    replaceStart(s: DateTime)
    begin
        declare endDate: DateTime;
        endDate := getEnd();
        delete (self, getStart()) from PeriodInterval;
        delete (self, endDate) from PeriodInterval;

        insert (self, s) into PeriodInterval;
        insert (self, endDate) into PeriodInterval;
    end

    pre selfAndArgsAreValid: isSelfValid() and s.isSelfValid()
    post mutationSuccess: getStart() = s and getEnd() = interval@pre->at(2)
    post selfStillValid: isValid(getStart(), getEnd())

    -- Replaces the end date with the new date
    replaceEnd(s: DateTime)
    begin
        delete (self, getEnd()) from PeriodInterval;
        insert (self, s) into PeriodInterval;
    end

    pre argIsValid: s.isSelfValid()
    pre selfIsValid: isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = s
    post selfStillValid: isValid(getStart(), getEnd())

    --------------------------------Operations--------------------------------

    duration(): Integer =
        if getEnd() <> null then
            getEnd().difference(getStart())
        else
            getStart().now.difference(getStart())
        endif
    pre selfIsValid: isSelfValid()
    post resultIsCorrect: result =
        if getEnd() <> null then
            getEnd().difference(getStart())
        else
            getStart().now.difference(getStart())
        endif

    durationInDays(): Real =
        if getEnd() <> null then
            getEnd().differenceInDays(getStart())
        else
            getStart().getNow().differenceInDays(getStart())
        endif
    pre selfIsValid: isSelfValid()
    post resultIsCorrect: result =
        if getEnd() <> null then
            getEnd().differenceInDays(getStart())
        else
            getStart().getNow().differenceInDays(getStart())
        endif
end -- Period Class

---------------------------------Domain Level---------------------------------

class Scrumble
end -- Scrumble Class

class Clock < Observable
attributes
    time: DateTime
operations
    --! tick doc
    --! @brief advances the clock by 1 second and updates all the time
    --!        sensitive objects in the system
    tick()
    begin
        self.time.advance(1);
        for o in self.observer do
            if (o.oclIsTypeOf(Match) = true) then
                o.oclAsType(Match).update(self);
            end;
        end;
    end

    pre noPre: true
    post noPost: true
end -- Clock Class

class User < Identifiable
operations
    -- wrappers for the capabilities/operations of all types of users
    -- (Players and admins)
end -- User Class

--------------------------------------ACL-------------------------------------

class Role
attributes
    --
operations
    --
end -- Role Class

class Permission
attributes
    action: Action
operations
    --getter
end -- Permission Class

--------------------------------Administration--------------------------------

class Admin < Role
attributes
    --
operations
    --! reviewReport doc
    --! @brief Sets the status of the report to #UNDER_REVIEW
    --!
    --! @param Report r The report to update the status of
    reviewReport(r: Report)
    pre argIsValid: r <> null
    pre isUnresolved: r.getStatus() = #UNRESOLVED
    post mutationSuccess: r.getStatus() = #UNDER_REVIEW

    --! resolveReport doc
    --! @brief Sets the status of the report as resolved
    --!
    --! @param Report r The report to update the status of
    resolveReport(r: Report)
    begin
        r.status := #RESOLVED
    end
    pre argIsValid: r <> null
    pre isUnderReview: r.getStatus() = #UNDER_REVIEW
    post mutationSuccess: r.getStatus() = #RESOLVED

    --! addWord doc
    --! @brief Creates a new word and adds it to the dictionary
    --!
    --! @param Letter w Sequence of letters that make up the word
    --! @param Category cat Category of word added
    addWord(w: Sequence(Letter), cat: Category, dict: Dictionary)
    begin
        declare word: Word, k: ValidWord;
        --word := w
        word.category := cat;
        --k :=  new ValidWord between (w, dict);
        --new Rank (p.user.id + 'Rank') between (self, p);
        --self.refresh();
    end
    -- #TODO Pre and Post

    --! depricatedWord doc
    --! @brief Sets a word as depricated
    --!
    --! @param Word w The word to be deprecated
    --! @return type
    --! @throws conditon
    deprecateWord(w: Word)
    begin
        w.status := #DEPRECATED;
    end
    pre wordExists: w <> null --should be check in dictionary?
    post : w.status = #DEPRECATED;
    -- #TODO Pre and Post

    --! banPlayer doc
    --! @brief Bans a player
    --!
    --! @param Player p Player to be banned
    banPlayer(p: Player)
    begin
        p.status := #BANNED;
    end
    pre : p <> null
    post : p.status = #BANNED;
    -- Sets their status to banned
    -- #TODO Pre and Post
end -- Admin Class

------------------------------Player Interactions-----------------------------

class RequestFactory
operations
    --! getReq doc
    --! @brief Creates and returns the desired request type
    --!
    --! @param RequestType t The type of request to be created
    --! @param Player sender The player sending the request
    --! @param Player rcvr The player receiving the request
    --! @return Request
    getReq(t: RequestType, sender: Player, rcvr: Player): Request
    begin
        declare r: Request;

        if t = #MATCH then
            r := new MatchRequest();
        else
            r := new Request();
        end;

        insert (sender, r) into SentRequest;
        insert (rcvr, r) into RecievedRequest;

        insert (sender, r) into Watches;
        insert (rcvr, r) into Watches;

        r.init(t);
        result := r;
    end
    pre argsAreValid: t <> null
    post validResult: (t = #MATCH and result.oclIsTypeOf(MatchRequest)) or
        (t <> #MATCH and result.oclIsTypeOf(Request))
end -- RequestFactory Class

class Player < Observer, Role
attributes
    username: String
    email: String
    dob: DateTime
    lastSeen: DateTime
    score: Integer init: 500
    status: PlayerStatus init: #OFFLINE
    state: ProfileState init: #PRIVATE
operations
    --! initialise doc
    --! @brief Initializes the player
    --!
    --! @param String u The player's username
    --! @param String e The player's email address
    --! @param DateTime d The player's date of birth
    initialise(u: String, e: String, d: DateTime)
    begin
        self.username := u;
        self.email := e;
        self.dob := d;
        self.lastSeen := new DateTime();
        insert (self.lastSeen, self.user.scrumble.clock.time)
            into CurrentTime;
        self.user.scrumble.leaderboard.add(self);
        insert (self, self.user.scrumble.clock) into Watches;
    end

    pre argsAreValid: u.size() > 0 and e.size() > 5 and d <> null
    pre userLinkedToScrumble: user.scrumble <> null
    pre usernameIsUnique:
        let
            allPlayers = user.scrumble.users.role->select(r |
                r.oclIsTypeOf(Player) = true)
        in allPlayers->collect(p | p.oclAsType(Player).username)->asSet()
            ->excludes(u)
    post attributesSet: username = u and email = e and dob = d
    post hasNewRank: rank.oclIsNew() = true

    --getters (we'll have to restrict what may be obtained in the method I
    -- think)

    --! update doc
    --! @brief Generates notifications based on what event occured
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    begin
        if (o.oclIsTypeOf(Chat) = true) then
            self.updateHelperChat(o.oclAsType(Chat));
        else if (o.oclIsTypeOf(Clock)) then
            self.updateHelperClock(o.oclAsType(Clock));
        else if (o.oclIsTypeOf(Request)) then
            self.updateHelperRequest(o.oclAsType(Request));
        else if (o.oclIsTypeOf(Report)) then
            self.updateHelperReport(o.oclAsType(Report));
        else if (o.oclIsTypeOf(MatchRequest)) then
            self.updateHelperMatchRequest(o.oclAsType(MatchRequest));
        end; end; end; end; end;
    end

    pre argIsValid: o <> null
    post noPost: true

    --! updateHelperClock doc
    --! @brief Notifies the player that the game clock has updated and updates
    --!        their status accordingly
    --!
    --! @param Clock o The game clock
    updateHelperClock(o: Clock)
    begin
        -- If the player has been online but inactive for more than 5 minutes
        if self.status = #ONLINE and
            self.user.scrumble.clock.time.difference(self.lastSeen) > 300
        then
            self.status := #AWAY;
        end;
    end

    pre noPre: true
    post statusUpdatedCorrectly: (status@pre = #ONLINE and
        user.scrumble.clock.time.difference(self.lastSeen) > 300) implies
        status = #AWAY

    --! updateHelperMatch doc
    --! @brief Notifies the player of a match event if they don't have the
    --!        match opened
    --!
    --! @param Match o The match that called the update method
    updateHelperMatch(o: Match)
    begin
        declare n: Notification;
        -- check if match is closed
        if (o.rack->any(r | r.players = self).matchOpen = false) then
            n := new Notification();
            n.init(self, o);
        end;
    end

    pre noPre: true
    post notifCreated:
        let
            diff = notifs - notifs@pre
        in (o.rack->any(r | r.players = self).matchOpen = false) implies
            (diff->forAll(n | n.oclIsNew() = true and n.event = o) and
            diff->size() = 1)

    --! updateHelperChat doc
    --! @brief update helper function for chat events
    --!
    --! @param Chat o The Chat that called the update method
    updateHelperChat(o: Chat)
    begin
        declare n: Notification;
        -- check if chat is closed
        if (o.chatState->any(cs | cs.participants = self).status = #CLOSED)
        then
            n := new Notification();
            n.init(self, o);
        end;
    end

    -- I'm not so sure if it's a good idea to restrict it to running if the
    -- chat is closed. By the way that select returns a set of ChatStates not
    -- just one and enforcing that the size be 0 means that they can't have
    -- any chats at all open for the method to run (ie they can't receive
    -- notifs if they have any one of their chats open)
    pre closedChat: chatState
        ->select(cs | cs.status = #OPEN)->size() = 0 -- chat must be closed
    post notifCreated:
        let
            diff = notifs - notifs@pre
        in (o.chatState->any(cs | cs.participants = self).status = #CLOSED)
            implies
                (diff->forAll(n | n.oclIsNew() = true and n.event = o) and
                diff->size() = 1)


    --! updateHelperRequest doc
    --! @brief update helper function for request events
    --!
    --! @param Request o The Request that called the update method
    updateHelperRequest(o: Request)
    begin
        declare r: Request;
        -- Generate a notification if the receiving player isn't online
    end
    pre noPre: true
    post noPost: true
    -- #TODO Pre and Post

    --! updateHelperReport doc
    --! @brief update helper function for report events
    --!
    --! @param Report o The Report that called the update method
    updateHelperReport(o: Report)
    begin
        declare re: Report;
        --re.init(o.type, o.description, self);
    end
    -- #TODO Pre and Post
    pre noPre: true
    post noPost: true

    --! updateHelperMatchReq doc
    --! @brief update helper function for matchRequest events
    --!
    --! @param MatchRequest o The MatchRequest that called the update method
    updateHelperMatchRequest(o: MatchRequest)
    begin
        --declare
    end
    -- #TODO Pre and Post
    pre noPre: true
    post noPost: true

    ---------------------------------Accessors--------------------------------

    getUsername(): String = username
    getEmail(): String = email
    getScore(): Integer = score
    getStatus(): PlayerStatus = status

    ---------------------------------Mutators---------------------------------

    updateLastSeen()
    begin
        self.lastSeen.setToNow();
        if self.status = #AWAY then
            self.status := #ONLINE;
        end;
    end
    pre notOffline: status <> #OFFLINE
    post lastSeenUpdated: lastSeen.equalsNow()

    --------------------------------Operations--------------------------------

    --! changeProfileState doc
    --! @brief Changes player profile state
    --! @param ProfileState s The state to change the profile to
    changeProfileState(s : ProfileState)
    begin
        self.state := s;
    end  
    pre argIsValid: s <> null
    post stateUpdated: self.state = s

    --! openApp doc
    --! @brief Executes actions that should occur once the player opens the
    --!        app or logs in
    openApp()
    begin
        self.status := #ONLINE;
        self.updateLastSeen();
    end
    pre notOnline: status = #OFFLINE
    post statusUpdated: status = #ONLINE

    --! closeApp doc
    --! @brief Executes actions that should occur once the player closes the
    --!        app or logs out
    closeApp()
    begin
        self.updateLastSeen();
        self.status := #OFFLINE;
    end
    pre isNotOffline: status <> #OFFLINE
    post statusUpdated: status = #OFFLINE

    --! openChat doc
    --! @brief Opens the specified chat
    --!
    --! @param Chat c The chat to be opened
    openChat(c: Chat)
    begin
        self.updateLastSeen();
        self.chatState->any(cs | cs.chatRooms = c).setOpen();
    end
    pre playerIsOnline: status <> #OFFLINE
    pre argIsValid: c <> null
    pre noChatOpen: not chatState->exists(cs | cs.status = #OPEN)
    post onlySpecifiedChatOpen: chatState
        ->any(cs | cs.status = #OPEN).chatRooms = c

    --! closeChat doc
    --! @brief Closes the currently opened chat
    closeChat()
    begin
        self.updateLastSeen();
        self.chatState->any(cs | cs.status = #OPEN).setClosed();
    end
    pre playerIsOnline: status <> #OFFLINE
    pre chatOpen: chatState->one(cs | cs.status = #OPEN)
    post chatProperlyClosed:
        let
            openedChat = chatState
                ->any(cs | cs.status@pre = #OPEN).chatRooms
        in chatState->one(cs |
            openedChat = cs.chatRooms and cs.status = #CLOSED
            and cs.lastOpened.equalsNow())

    --! openMatch doc
    --! @brief Opens the specified match
    --!
    --! @param Match m The match to be opened
    openMatch(m: Match)
    begin
        self.updateLastSeen();
        self.status := #PLAYING;
        self.rack->any(r | r.matchHistory = m).matchOpen := true;
    end
    pre argIsValid: m <> null
    pre matchClosed: rack->any(r | r.matchHistory = m).matchOpen = false
    pre notInGame: status = #ONLINE or status = #AWAY
    post inGame: status = #PLAYING
    post matchOpened: rack->any(r | r.matchHistory = m).matchOpen = true

    --! closeMatch doc
    --! @brief Closes the specified match
    --!
    --! @param Match m The match to be opened
    closeMatch(m: Match)
    begin
        self.updateLastSeen();
        self.status := #ONLINE;
        self.rack->any(r | r.matchHistory = m).matchOpen := false;
    end
    pre argIsValid: m <> null
    pre matchOpened: rack->any(r | r.matchHistory = m).matchOpen = true
    pre inGame: status = #PLAYING
    post notInGame: status = #ONLINE
    post matchClosed: rack->any(r | r.matchHistory = m).matchOpen = false

    -- #TODO Methods to set the status to away

    --! joinQueue doc
    --! @brief Adds the player to the match queue
    --!
    --! @param MatchType mType The type of match the player wants to play
    --! @param Boolean timed If the match should be timed or not
    joinQueue(mType: MatchType, timed: Boolean)
    begin
        declare q: Queue, j: Join;
        self.updateLastSeen();

        q := self.user.scrumble.queues->any(mq |
            mq.matchType = mType and mq.timed = timed);
        j := new Join() between (q, self);
        j.init();
        q.matchmaking();
    end
    pre argIsValid: mType <> null and timed <> null
    pre noUntimedRankedMatches: mType = #RANKED implies timed
    pre playerIsOnline: status = #ONLINE or status = #AWAY
    pre playerNotInQueue: not queues->exists(q |
        q.matchType = mType and q.timed = timed)
    post joinSuccessful:
        let
            q = user.scrumble.queues->any(mq |
                mq.matchType = mType and mq.timed = timed),
            newJoin = join->any(j | j.queues = q),
            lastMatch = matchHistory->last()
        in ((q.players@pre->including(self) = q.players) and
            newJoin.joinedAt.equalsNow() and (newJoin.oclIsNew() = true))
            or
            (matchHistory@pre->including(lastMatch) = matchHistory and
            (lastMatch.oclIsNew() = true))

    --! leaveQueue doc
    --! @brief Removes the player from the match queue they are currently in
    --!
    --! @param Queue q The queue the player wants to leave
    leaveQueue(q: Queue)
    begin
        self.updateLastSeen();
        destroy self.join->any(j | j.queues = q);
    end
    pre playerIsInQueue: queues->includes(q)
    pre playerIsOnline: status = #ONLINE or status = #AWAY
    post leaveSuccessful: queues@pre->excluding(q) = queues

    --! sendMsg doc
    --! @brief Sends a message in the specified chat
    --!
    --! @param Chat c The chat to send the message in
    --! @param String msg The message to be sent
    sendMsg(c: Chat, msg: String)
    begin
        self.updateLastSeen();
        c.createMessage(self, msg);
    end
    pre playerIsOnline: status <> #OFFLINE
    pre argsAreValid: c <> null and msg.size() > 0
    pre participantsNotBlocked:
        c.participants->forAll(p1, p2 |
            p1 <> p2 implies p1.blocked->excludes(p2))
    post msgSent:
        let
            newMsg = c.messages->last()
        in newMsg.oclIsNew() and
            c.messages@pre->including(newMsg) = c.messages and
            newMsg.getBody() = msg and
            newMsg.sentDate.equalsNow()

    --! sendReq doc
    --! @brief Sends a request to the specified player
    --!
    --! @param Player p The player to send the request to
    --! @param RequestType t The type of request to be sent
    sendReq(p: Player, t: RequestType)
    begin
        declare r: Request;
        self.updateLastSeen();
        r := self.user.scrumble.rFactory.getReq(t, self, p);
    end
    pre playerIsOnline: status = #ONLINE or status = #AWAY
    pre argsAreValid: p <> null and t <> null
    pre noExistingPendingReqOfSameType:
        let
            allReqs = sentReqs->union(rcvdReqs),
            pending = allReqs->select(r | r.status = #PENDING and r.type = t)
        in not pending->exists(pReq |
            Set{pReq.reqSender, pReq.reqRcvr} = Set{self, p})
    post reqSent:
        let
            newReq = sentReqs->select(req | req.oclIsNew())
        in newReq->size() = 1 and
            sentReqs@pre->union(newReq) = sentReqs and
            p.rcvdReqs@pre->union(newReq) = p.rcvdReqs and
            newReq->one(req | req.sentDate.equalsNow() and
                req.status = #PENDING or req.status = #LOST)

    --! addressReq doc
    --! @brief Updates the status of a received request
    --!
    --! @param Request req The received request to be addressed
    --! @param Boolean action Boolean representing accepting (true) or
    --!                   rejecting (false) the request
    addressReq(req: Request, action: Boolean)
    begin
        self.updateLastSeen();
        if action = true then
            req.acceptReq();
            if req.type = #FRIEND then
                insert (self, req.reqSender) into FriendList;
                insert (req.reqSender, self) into FriendList;
            end;
        else
            req.rejectReq();
        end;
    end
    pre playerIsOnline: status = #ONLINE or status = #AWAY
    pre argsAreValid: req <> null and action <> null
    pre reqIsPending: req.status = #PENDING
    pre noExistingAcceptedReqOfSameType:
        let
            allReqs = sentReqs->union(rcvdReqs),
            accepted = allReqs->select(r | r.status = #ACCEPTED and
                r.type = req.type)
        in not accepted->exists(a |
            Set{a.reqSender, a.reqRcvr} = Set{req.reqSender, req.reqRcvr})
    post reqAddressed: (action and req.status = #ACCEPTED) or
        ((not action) and req.status = #REJECTED)
    post activePeriodSet: req.activePeriod <> null and
        req.activePeriod.getStart().equalsNow()
    post friendListsUpdated: req.type = #FRIEND implies
        (req.reqSender.friends@pre->including(self) =
            req.reqSender.friends
        and
        friends@pre->including(req.reqSender) = friends)

    --! blockPlayer doc
    --! @brief Adds a player to the player's blocked list
    --!
    --! @param Player p The player to be blocked
    blockPlayer(p: Player)
    begin
        declare
            b: Block,
            d: DateTime,
            bList: Set(Player);
        self.updateLastSeen();

        -- Check that blocked list doesn't have player
        bList := self.block[player]
            ->select(b | b.status = #BLOCKED).blocked->asSet();
        if bList->excludes(p) then
            b := new Block() between (self, p);
            d := new DateTime();
            b.date := d;
        end;

        b := self.block[player]->any(b | b.blocked = p);
        b.block();
    end
    pre argIsValid: p <> null
    pre playerIsOnline: status <> #OFFLINE
    pre playerIsNotBlocked:
        let
            b = block[player]->any(b | b.blocked = p)
        in b = null or b.status = #UNBLOCKED
    post playerBlocked: block[player]->exists(b |
        b.blocked = p and b.status = #BLOCKED and
        b.date.equalsNow())

    --! unblockPlayer doc
    --! @brief Unblocks a player
    --!
    --! @param Player p The player to be unblocked
    unblockPlayer(p: Player)
    begin
        declare b: Block;
        self.updateLastSeen();
        b := self.block[player]->any(b | b.blocked = p);
        b.unblock();
    end
    pre argIsValid: p <> null
    pre playerIsOnline: status <> #OFFLINE
    pre playerBlocked: block[player]->exists(b |
        b.blocked = p and b.status = #BLOCKED)
    post playerUnblocked: block[player]->exists(b|
        b.blocked = p and b.status = #UNBLOCKED)

    --! reportBug doc
    --! @brief Creates a bug report
    --!
    --! @param String msg A description of the bug being reported
    reportBug(msg: String)
    pre playerIsOnline: status <> #OFFLINE
    pre argIsValid: msg.size() > 0
    post bugReported:
        let
            newClaim = claims->select(c | c.oclIsNew())
        in newClaim->size() = 1 and
            claims@pre->union(newClaim) = claims and
            newClaim->one(c | c.getDesc() = msg and c.reported->isEmpty())

    --! reportPlayer doc
    --! @brief Creates a report against the specified player
    --!
    --! @param Player p The player to be reported
    --! @param String msg The reason for reporting the player
    reportPlayer(p: Player, msg: String)
    pre playerIsOnline: status <> #OFFLINE
    pre argIsValid: p <> null and msg.size() > 0
    post playerReported:
        let
            newClaim = claims->select(c | c.oclIsNew())
        in newClaim->size() = 1 and
            claims@pre->union(newClaim) = claims and
            newClaim->one(c |
                c.getDesc() = msg and Set{p} = c.reported->asSet())
statemachines
    psm playerStates
    states
        start: initial
        offline [status = #OFFLINE]
        online [status = #ONLINE]
        away [status = #AWAY]
        playing [status = #PLAYING]
        banned: final [status = #BANNED]
    transitions
        start -> offline {create}

        offline -> online {openApp()}
        offline -> banned

        online -> online {updateLastSeen()}
        online -> offline {closeApp()}
        online -> playing {openMatch()}
        online -> away {updateHelperClock()}
        online -> banned

        away -> online {updateLastSeen()}
        away -> offline {closeApp()}
        away -> playing {openMatch()}
        away -> away {updateHelperClock()}
        away -> banned

        playing -> online {closeMatch()}
        playing -> offline {closeApp()}
        playing -> banned
    end
end -- Player Class

class Message < Identifiable
attributes
    status: MessageStatus init: #UNSEEN
    message: String
    sentDate: DateTime
    seenDate: DateTime
operations
    --! init doc
    --! @brief Initialises the message
    --!
    --! @param String msg The message body
    init(msg: String)
    begin
        declare now: DateTime;
        self.id := self.msgSender.user.id + self.msgRcvr.user.id + 'msg' +
            self.chat.messages->select(m |
                m.msgSender = self.msgSender)->size().toString();
        self.message := msg;
        self.sentDate := new DateTime();

        now := self.msgSender.user.scrumble.clock.time;
        insert (self.sentDate, now) into CurrentTime;
        self.sentDate.setToNow();
    end
    pre argIsValid: msg.size() > 0
    post attributesSet: sentDate.equalsNow() and message = msg

    --! getBody doc
    --! @brief Returns the body/contents of the message
    --!
    --! @return String
    getBody(): String = message

    --! view doc
    --! @brief Sets the message status to SEEN
    view()
    begin
        self.status := #SEEN;
        self.seenDate := new DateTime();
        insert (self.seenDate, self.sentDate.now) into CurrentTime;
        self.seenDate.setToNow();
    end

    pre msgUnseen: status = #UNSEEN
    post statusUpdated: status = #SEEN
statemachines
    psm msgStates
    states
        start: initial
        unseen [status = #UNSEEN]
        seen: final [status = #SEEN]
    transitions
        start -> unseen {create}
        unseen -> seen {view()}
    end
end -- Message Class

class Notification
attributes
    deliverytime: DateTime
    dismissed: Boolean init: false
operations
    --! init doc
    --! @brief Initializes the notification instance
    --!
    --! @param Player p The player to be notified
    --! @param Observable o The object involved in the event
    init(p: Player, o: Observable)
    begin
        insert (self, p) into Notify;
        insert (self, o) into Signal;

        self.deliverytime := new DateTime();
        insert (self.deliverytime, p.user.scrumble.clock.time)
            into CurrentTime;
        self.deliverytime.setToNow();
    end

    pre argsAreValid: p <> null and o <> null
    post initSuccess: player = p and event = o and deliverytime.equalsNow()

    --! dismiss doc
    --! @brief Marks the notification as dismissed
    dismiss()
    begin self.dismissed := true; end
    pre noPre: true
    post noPost: true

    --! gotoAndDismiss doc
    --! @brief Opens the app to the relevant view then dismisses the
    --!        notification
    gotoAndDismiss()
    -- #TODO Pre and Post

    --! gotoChatHelper doc
    --! @brief gotoAndDismiss helper for chat event notifications
    gotoChatHelper()
    -- #TODO Pre and Post

    --! gotoMatchHelper doc
    --! @brief gotoAndDismiss helper for match event notifications
    gotoMatchHelper()
    -- #TODO Pre and Post

    --! gotoRequestHelper doc
    --! @brief gotoAndDismiss helper for request event notifications
    gotoRequestHelper()
    -- #TODO Pre and Post

    --! gotoReportHelper doc
    --! @brief gotoAndDismiss helper for report event notifications
    gotoReportHelper()
    -- #TODO Pre and Post
statemachines
    psm notificationStates
    states
        unseen: initial [dismissed = false]
        seen: final [dismissed = true]
    transitions
        unseen -> seen {dismiss()}
    end
end

class Chat < Observable
operations
    --! createMessage doc
    --! @brief Creates a new message in the chat
    --!
    --! @param Player sender The player sending the message
    --! @param String msg The message to be sent
    createMessage(sender: Player, msg: String)
    begin
        declare
            rcvr: Player,
            now: DateTime,
            m: Message;

        rcvr := self.participants->any(p | p <> sender);
        now := sender.user.scrumble.clock.time;

        m := new Message();
        insert (self, m) into PlayerChat;
        insert (sender, m) into SentMessage;
        insert (rcvr, m) into RecievedMessage;
        m.init(msg);

        if self.chatState->any(cs | cs.participants = rcvr).status = #OPEN
        then
            m.view();
        else -- If chat is closed
            rcvr.update(self);
        end;
    end

    pre isOpen: chatState.status->includes(#OPEN)
    pre argIsValid: sender <> null and msg.size() > 0
    post msgCreated:
        let
            newMsg = messages->last()
        in newMsg.oclIsNew() and
            messages@pre->including(newMsg) = messages and
            newMsg.getBody() = msg and
            newMsg.sentDate.equalsNow()

    --! view doc
    --! @brief Marks all the newest received messages as seen and dismissed
    --!        any linked notifications that have not been dismissed
    --!
    --! @param Player p The player trying to view the messages
    view(p: Player)
    begin
        declare msgs: OrderedSet(Message);
        msgs := self.messages->select(m |
            m.status = #UNSEEN and m.msgSender <> p);

        for m in msgs do
            m.view();
        end;
    end

    pre isOpen: chatState->one(cs |
        cs.participants->includesAll(Set{p}) and cs.status = #OPEN)
    pre argIsValid: p <> null
    post noUnseenMsgs: not messages->exists(m |
        m.status = #UNSEEN and m.msgSender <> p)
end -- Chat Class

associationclass ChatState
between
    Chat[*] role chatRooms
    Player[2] role participants
attributes
    status: ChatStatus init: #CLOSED
    lastOpened: DateTime
operations
    --! setOpen doc
    --! @brief Sets the chat state to #OPEN
    --!
    --! view all unseen messages and set ChatStatus to OPEN
    setOpen()
    begin
        self.status := #OPEN;
        self.chatRooms.view(self.participants);
    end
    pre notOpen: status = #CLOSED
    post openned: status = #OPEN
    post latestMsgsSeen: not chatRooms.messages->exists(m |
        m.status = #UNSEEN and participants <> m.msgSender)

    --! setClosed doc
    --! @brief Sets the chat state to #CLOSED
    --!
    --! set lastOpened date and set ChatStatus to CLOSED
    setClosed()
    begin
        self.status := #CLOSED;
        self.lastOpened.setToNow();
    end
    pre openned: status = #OPEN
    post closed: status = #CLOSED
    post lastOpenedSet: lastOpened.equalsNow()
    post allMsgsUpToCloseAreSeen: not chatRooms.messages->exists(m |
        m.status = #UNSEEN and m.sentDate.before(lastOpened) and
        participants <> m.msgSender)
end -- End ChatState Association Class

class Request < Identifiable, Observable
attributes
    status: RequestStatus init: #PENDING
    sentDate: DateTime
    activePeriod: Period
    type: RequestType
operations
    --! init doc
    --! @brief Initialises the request
    --!
    --! @param RequestType t The type of request being made
    init(t: RequestType)
    begin
        self.sentDate := new DateTime();
        insert (self.sentDate, self.reqSender.user.scrumble.clock.time)
            into CurrentTime;
        self.sentDate.setToNow();
        self.type := t;

        if self.reqSender.blocked->includes(self.reqRcvr) or
            self.reqRcvr.blocked->includes(self.reqSender)
        then
            self.blockReq();
        end;
    end
    pre argIsValid: t <> null
    post attributesSet: sentDate.equalsNow() and type = t
        and activePeriod = null

    --! isSenfValid doc
    --! @brief Returns true if the request state is valid
    --!
    --! 1. ACCEPTED request must have an active period with a start but no
    --!    end time and the start time is after the sent time
    --! 2. The active period starts after the request was sent and must not
    --!    have an end time
    --! 3. PENDING, REJECTED and LOST requests have no active period
    --! 4. RECINDED requests have an active period with as start and end time
    --!    and the start time is after the sent time
    --!
    --! @return Boolean
    isSelfValid(): Boolean =
        (status = #ACCEPTED and
            activePeriod <> null and activePeriod.isSelfValid() and
            activePeriod.getStart().after(sentDate) and
            activePeriod.getEnd() = null) or
        (Set{#PENDING, #REJECTED, #LOST}->includes(status) and
            activePeriod = null) or
        (status = #RECINDED and
            activePeriod <> null and activePeriod.isSelfValid() and
            activePeriod.getStart().after(sentDate) and
            activePeriod.getEnd() <> null)
    pre noPre: true
    post noPost: true

    --! acceptReq doc
    --! @brief Mark the request as accepted
    acceptReq()
    begin
        declare d: DateTime;
        self.status := #ACCEPTED;

        d := new DateTime();
        insert (d, self.sentDate.now) into CurrentTime;
        d.setToNow();

        self.activePeriod := new Period();
        self.activePeriod.addStart(d);

        self.notify();
    end
    pre isPending: status = #PENDING
    pre isValid: isSelfValid()
    post statusUpdated: status = #ACCEPTED
    post isStillValid: isSelfValid()
    post periodActivated: activePeriod.getStart().equalsNow()

    --! rejectReq doc
    --! @brief Mark the request as rejected
    rejectReq()
    begin self.status := #REJECTED; end
    pre isPending: status = #PENDING
    pre isValid: isSelfValid()
    post isStillValid: isSelfValid()
    post statusUpdated: status = #REJECTED

    --! recindReq doc
    --! @brief Mark the request as recinded
    recindReq()
    begin
        declare d: DateTime;
        self.status := #RECINDED;

        d := new DateTime();
        insert (d, self.sentDate.now) into CurrentTime;
        d.setToNow();

        self.activePeriod.addEnd(d);
    end
    pre isAccepted: status = #ACCEPTED
    pre isValid: isSelfValid()
    post isStillValid: isSelfValid()
    post statusUpdated: status = #RECINDED
    post periodDeactivated: activePeriod.getEnd().equalsNow()

    --! blockReq doc
    --! @brief Mark the request as lost
    blockReq()
    begin self.status := #LOST; end
    pre isPending: status = #PENDING
    pre isValid: isSelfValid()
    post isStillValid: isSelfValid()
    post statusUpdated: status = #LOST
statemachines
    psm requestStates
    states
        start: initial
        pending [status = #PENDING]
        accepted [status = #ACCEPTED]
        rejected: final [status = #REJECTED]
        recinded: final [status = #RECINDED]
        lost: final [status = #LOST]
    transitions
        start -> pending {create}
        pending -> accepted {acceptReq()}
        pending -> rejected {rejectReq()}
        pending -> lost {blockReq()}
        accepted -> recinded {recindReq()}
    end
end -- Request Class

class MatchRequest < Request
attributes
    matchType: MatchType
    timed: Boolean
operations
    --! acceptReq doc
    --! @brief Mark the request as accepted and creates a new match
    acceptReq()
    begin
        declare d: DateTime, m: Match;
        self.status := #ACCEPTED;

        d := new DateTime();
        insert (d, self.sentDate.now) into CurrentTime;
        d.setToNow();

        self.activePeriod := new Period();
        self.activePeriod.addStart(d);
        m := self.reqSender.user.scrumble.mFactory.getMatch(self.reqRcvr,
            self.reqSender, self.matchType, self.timed);

        self.notify();
    end
    pre noPre: true
    post newMatchCreated: match <> null and
        match.oclIsNew() = true
end -- MatchRequest Class

associationclass Block
between
    Player[*] role player
    Player[*] role blocked
attributes
    date: DateTime
    status: BlockStatus init: #BLOCKED
operations
    --! block doc
    --! @brief Mark a player as blocked
    block()
    begin
        self.status := #BLOCKED;
        self.date := new DateTime();
        --insert (self.date, now) into CurrentTime;
        self.date.setToNow();
    end

    -- #TODO Pre and Post
    --pre noPre: true
    --post noPost: true

    --! unblock doc
    --! @brief Mark a player as unblocked
    unblock()
    begin self.status := #UNBLOCKED; end
    --pre noPre: true
    --post noPost: true
    -- #TODO Pre and Post


end -- Block Association Class

class Report < Observable
attributes
    type: ReportType
    status: ReportStatus init: #UNRESOLVED
    description: String
operations
    --! init doc
    --! @brief Initializes the report
    --! @param ReportType repType The type of report to be made
    --! @param String desc A description of the bug/reason for reporting a
    --!                    player
    --! @param Player p The player to be reported
    init(repType: ReportType, desc: String, p: Player)
    pre argsAreValid: repType <> null and desc.size() > 0 and
        ((repType = #PLAYER and p <> null) or
        (repType <> #PLAYER and p = null))
    post initSuccess: type = repType and description = desc and
        reported = p and status = #UNRESOLVED

    --! getStatus doc
    --! @brief Returns the status of the report
    --!
    --! @return ReportStatus
    getStatus(): ReportStatus = status

    --! getDesc doc
    --! @brief Returns the description of the report
    --!
    --! @return String
    getDesc(): String = description

    --! open doc
    --! @brief Marks the report as underReview
    open()
    begin self.status := #UNDER_REVIEW; end
    pre reportUnresolved: status = #UNRESOLVED
    post mutationSuccess: status = #UNDER_REVIEW

    --! close doc
    --! @brief Marks the report as resolved
    close()
    begin self.status := #RESOLVED; end
    pre reportUnresolved: status = #UNDER_REVIEW
    post mutationSuccess: status = #RESOLVED
statemachines
    psm reportStates
    states
        start: initial
        unresolved [status = #UNRESOLVED]
        underReview [status = #UNDER_REVIEW]
        resolved: final [status = #RESOLVED]
    transitions
        start -> unresolved {create}
        unresolved -> underReview {open()}
        underReview -> resolved {close()}
    end
end -- Report Class

-------------------------------------Game-------------------------------------

class MatchBuilder
operations
    --! categoryGenerator doc
    --! @brief Pseudo-randomly returns a match category based on the current
    --!        time
    --!
    --! @return Category
    categoryGenerator(): Category =
        let
            categories = Sequence{#ANIMAL, #MUSIC, #MOVIES, #FOOD, #BOOKS,
                #COUNTRIES, #NONE},
            catCnt = categories->size(),
            dividend = scrumble.clock.time.secondsSinceEposh,
            quotient = dividend div catCnt,
            random = (quotient.mod(catCnt) + dividend.mod(catCnt))
                .mod(catCnt) + 1
        in categories->at(random)

    --! default doc
    --! @brief Default actions to be taken for all matches created
    --!
    --! @param Player p1 The first player to link to the match
    --! @param Player p2 The second player to link to the match
    --! @param Match m The match to setup
    default(p1: Player, p2: Player, m: Match)
    begin
        declare
            b: Board,
            s: Slot,
            tb: TileBag,
            boardSize: Sequence(Integer),
            lval: Sequence(String),
            lcnt: Sequence(Integer),
            tpt: Sequence(Integer),
            l: Letter,
            t: Tile,
            pR: Rack,
            pLst: Sequence(Player),
            rand: Integer;

        insert (m, self.scrumble.dictionary) into WordCheck;
        insert (self.scrumble.leaderboard, m) into Watches;
        insert (p1, m) into Watches;
        insert (p2, m) into Watches;
        insert (m, self.scrumble.clock) into Watches;

        b := new Board(m.id + 'Board');
        insert (m, b) into MatchGameBoard;
        boardSize := Sequence{1..15};
        for r in boardSize do
            for c in boardSize do
                s := new Slot(m.id + 'bR' + r.toString()
                    + 'C' + c.toString());
                insert (b{r, c}, s) into Grid;
            end;
        end;

        tb := new TileBag(m.id + 'Bag');
        insert (tb, b) into LetterOptions;
        lval := Sequence{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
            'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
            'X', 'Y', 'Z'};
        lcnt := Sequence{9, 2, 2, 4, 12, 2, 3, 2, 9, 1, 1, 4, 2, 6, 8, 2, 1,
            6, 4, 6, 4, 2, 2, 1, 2, 1};
        tpt  := Sequence{ 1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10,
            1, 1, 1, 1, 4, 4, 8, 4, 10};
        for i in Sequence{1..lval->size()} do
            l := new Letter(m.id + lval->at(i));
            l.letter := lval->at(i);
            for j in Sequence{1..lcnt->at(i)} do
                t := new Tile(m.id + lval->at(i) + j.toString() + 'Tile');
                t.points := tpt->at(i);
                insert (t, l) into Mark;
                insert (tb, t) into Stock;
            end;
        end;

        pLst := Sequence{p1, p2};
        for i in Sequence{1..pLst->size()} do
            rand := self.scrumble.clock.time.secondsSinceEposh
                .mod(pLst->size()) + 1;
            pR := new Rack(m.id + 'Rack' + i.toString())
                between (pLst->at(rand), m);
            pR.drawTiles();
            pLst := pLst->excluding(pLst->at(rand));
        end;
    end

    pre argsAreValid: p1 <> null and p2 <> null and p1 <> p2 and m <> null
    post noPost: true

    --! buildRankedMatch doc
    --! @brief Creates a ranked match and initializes all the relevant
    --!        components
    --!
    --! @param Player p1 The first player to link to the match
    --! @param Player p2 The second player to link to the match
    --! @return Match
    buildRankedMatch(p1: Player, p2: Player): Match
    begin
        declare m: Match;
        m := new Match('m' + (self.scrumble.matches->size() + 1).toString());
        insert (self.scrumble, m) into ScrumbleMatches;
        m.init(#RANKED, true, self.categoryGenerator());
        self.default(p1, p2, m);
        result := m;
    end

    pre argsAreValid: p1 <> null and p2 <> null and p1 <> p2
    post consistentTilePointValues: result.tilePointsAreValid()
    post fixedNumberOfLettersInMatch: result.tileCountIsValid()

    --! buildUnrankedTimedMatch doc
    --! @brief Creates an unranked timed match and initializes all the
    --!        relevant components
    --!
    --! @param Player p1 The first player to link to the match
    --! @param Player p2 The second player to link to the match
    --! @return Match
    buildUnrankedTimedMatch(p1: Player, p2: Player): Match
    begin
        declare m: Match;
        m := new Match('m' + (self.scrumble.matches->size() + 1).toString());
        insert (self.scrumble, m) into ScrumbleMatches;
        m.init(#UNRANKED, true, self.categoryGenerator());
        self.default(p1, p2, m);
        result := m;
    end

    pre argsAreValid: p1 <> null and p2 <> null and p1 <> p2
    post consistentTilePointValues: result.tilePointsAreValid()
    post fixedNumberOfLettersInMatch: result.tileCountIsValid()

    --! buildUnrankedUntimedMatch doc
    --! @brief Creates an unranked untimed match and initializes all the
    --!        relevant components
    --!
    --! @param Player p1 The first player to link to the match
    --! @param Player p2 The second player to link to the match
    --! @return Match
    buildUnrankedUntimedMatch(p1: Player, p2: Player): Match
    begin
        declare m: Match;
        m := new Match('m' + (self.scrumble.matches->size() + 1).toString());
        insert (self.scrumble, m) into ScrumbleMatches;
        m.init(#UNRANKED, false, self.categoryGenerator());
        self.default(p1, p2, m);
        result := m;
    end

    pre argsAreValid: p1 <> null and p2 <> null and p1 <> p2
    post consistentTilePointValues: result.tilePointsAreValid()
    post fixedNumberOfLettersInMatch: result.tileCountIsValid()
end -- MatchBuilder Class

class MatchFactory
operations
    getMatch(p1: Player, p2: Player, type: MatchType, timed: Boolean): Match
    begin
        if type = #RANKED then
            result := self.mBuilder.buildRankedMatch(p1, p2);
        else if type = #UNRANKED then
            if timed = true then
                result := self.mBuilder.buildUnrankedTimedMatch(p1, p2);
            else
                result := self.mBuilder.buildUnrankedUntimedMatch(p1, p2);
            end;
        end; end;
    end
    pre noPre: true
    post noPost: true
end -- MatchFactory Class

class Queue < Observable
attributes
    matchType: MatchType
    timed: Boolean
operations
    --! init doc
    --! @brief Initializes the queue
    --!
    --! @param Type <var> Description
    init(mType: MatchType, t: Boolean)
    begin
        self.matchType := mType;
        self.timed := t;
    end

    pre argsAreValid: mType <> null and t <> null
    pre noUntimedRankedMatches: mType = #RANKED implies t
    post attributesSet: (matchType = mType) and (timed = t)

    --! matchmaking doc
    --! @brief Triggers the creation of matches between players in the queue
    matchmaking()
    begin
        declare
            m: Match,
            p1: Player,
            p2: Player,
            p1Blocked: Set(Player),
            p2Blocked: Set(Player),
            rankDiff: Integer,
            allPlayers: Sequence(Player);

        allPlayers := self.join
            ->sortedBy(j | j.joinedAt.secondsSinceEposh).players;
        for i in Sequence{1..allPlayers->size()} do
            for j in Sequence{(i+1)..allPlayers->size()} do
                p1 := allPlayers->at(i);
                p2 := allPlayers->at(j);

                p1Blocked := p1.block[player]
                    ->select(b | b.status = #BLOCKED).blocked->asSet();
                p2Blocked := p2.block[player]
                    ->select(b | b.status = #BLOCKED).blocked->asSet();

                if p1Blocked->excludes(p2) and p2Blocked->excludes(p1) then
                    rankDiff := (p1.rank.placement - p2.rank.placement).abs();
                    if (self.matchType = #RANKED and rankDiff <= 100) or
                        (self.matchType <> #RANKED and rankDiff <= 200)
                    then
                        destroy self.join->any(j | j.players = p1);
                        destroy self.join->any(j | j.players = p2);
                        m := self.scrumble.mFactory.getMatch(p1, p2,
                            self.matchType, self.timed);
                        p1.update(self);
                        p2.update(self);
                    end;
                end;
            end;
        end;
    end

    pre playersInQueue: players->size() >= 1
    --post: check that the queue is empty or the remaining players are
    -- unmatchable
    post newMatchesValid:
        scrumble.matches->select(m | m.oclIsNew() = true)->forAll(m |
            let
                p1 = m.players->any(true),
                p2 = m.players->any(p | p <> p1),
                p1Blocked = p1.block[player]
                    ->select(b | b.status = #BLOCKED).blocked,
                p2Blocked = p2.block[player]
                    ->select(b | b.status = #BLOCKED).blocked,

                rankDiff = (p1.rank.placement - p2.rank.placement).abs()
            in p1Blocked->excludes(p2) and p2Blocked->excludes(p1) and
                ((m.type = #RANKED and rankDiff <= 100) or
                    (m.type <> #RANKED and rankDiff <= 200))
        )
end -- Queue Class

associationclass Join
between
    Queue[*] role queues
    Player[*] role players
attributes
    joinedAt: DateTime
operations
    --! init doc
    --! @brief Initializes the Join instance
    init()
    begin
        self.joinedAt := new DateTime();
        insert (self.joinedAt, self.queues.scrumble.clock.time)
            into CurrentTime;
        self.joinedAt.setToNow();
    end

    -- Not sure if checking that the roles aren't empty is a valid
    -- precondition
    pre noPre: true
    post attributesSet: joinedAt.equalsNow()
end -- Join Association Class

associationclass Rack
between
    Player[2] role players ordered
    Match[*] role matchHistory ordered
attributes
    matchOpen: Boolean init: false
operations
    --! drawTiles doc
    --! @brief Tells the match instance to gets a random set of tiles to fill
    --!        the empty slots in the rack
    drawTiles()
    begin self.matchHistory.getTiles(self); end
    pre noPre: true
    pre noPost: true

    --! triggerPlay doc
    --!
    --! Essentially a wrapper for the executePlay method in match
    --!
    --! @brief starts the process of making a play
    triggerPlay(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile))
    begin
        self.matchHistory.executePlay(self, sRow, sCol, dir, tileSeq);
    end
    pre playerIsInCurrentMatch: matchOpen = true
    pre argsAreValid: Set{sRow, sCol, dir}->excludes(null) and
        tileSeq->size() > 0 and tiles->includesAll(tileSeq)
    post tilesRemoved: tiles->excludesAll(tileSeq)

    --! triggerPass doc
    --!
    --! Essentially a wrapper for the executePass method in match
    --!
    --! @brief Starts the process of passing a turn
    triggerPass()
    begin
        self.matchHistory.executePass(self);
    end
    pre playerIsInCurrentMatch: matchOpen = true
    post noPost: true

    --! triggerQuit doc
    --!
    --! Essentially a wrapper for the executeQuit method in match
    --!
    --! @brief Starts the process of forfeiting the game
    triggerQuit()
    begin
        self.matchHistory.executeQuit(self);
    end
    pre playerIsInCurrentMatch: matchOpen = true
    post noPost: true
end -- Rack Association Class

class Play < Identifiable
attributes
    type: PlayType
    -- The main word is the word in the same row/column where the tiles were
    -- placed. The main word does not have to start where the first tile
    -- was placed
    startRow: Integer -- row of the first letter of the main word
    startCol: Integer -- column of the first letter of the main word
    direction: PlayDirection
    score: Integer derived = calcScore()
    time: DateTime
    multiplier: Real derived = calcMultiplier()
operations
    --! init doc
    --! @brief Initializes the play
    --!
    --! The main word of a play is the word that lies in the same row/column
    --! as all the tiles places on the board for that play
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param OrderedSet(Tile) tileSeq The set of tiles to be used to make
    --!                                 the play
    --! @param PlayType t The type of play being made
    init(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile), t: PlayType, pTime: DateTime)
    begin
        self.id := self.match.id + 'p' +
            (self.match.playHistory->size() + 1).toString();
        self.type := t;
        self.startRow := sRow;
        self.startCol := sCol;
        self.direction := dir;
        self.time := pTime;
    end

    pre argsAreValid: t = #PLAY implies
        Set{sRow, sCol, dir}->excludes(null) and tileSeq->size() > 0
    pre linkedToMatch: match <> null
    post attributesSet: startRow = sRow and startCol = sCol and
        direction = dir and type = t and time <> null and
        time.equalsNow()

    --! calcScore doc
    --! @brief Calculates the points accumulated by the placement of the tiles
    --!        on the board
    --!
    --! @return Integer
    calcScore(): Integer =
        let
            activeTiles = rack.tiles->union(match.board.slots.tile)->asSet(),
            flatScore = words->iterate(w; ans:Integer = 0 |
                    ans + w.letters->iterate(l; ws:Integer = 0 |
                        ws + activeTiles
                            ->any(t | t.letter.letter = l.letter).points
                    )
                )
        in if type = #PLAY then
                (flatScore * multiplier).floor
            else 0 endif
    pre noPre: true
    post noPost: true

    --! calcMultiplier doc
    --! @brief Determines the score multiplier for the play
    --!
    --! @return Real
    calcMultiplier(): Real =
        if type = #PLAY then
            -- category multiplier
            (if words.category->excluding(#NONE)
            ->includes(match.category) then
                1.5
            else 1 endif) *

            -- skill multiplier
            (if tiles->size() > 4 then
                if match.timed = true then
                    if words.length()->max() >= 6 then
                        1.5
                    else 1 endif
                else -- if match.timed = false then
                    let
                        i = match.playHistory->indexOf(self),
                        prevPTime =
                            if self = match.playHistory->first() then
                                match.duration.getStart()
                            else
                                match.playHistory->at(i - 1).time
                            endif,
                        pTime = time.difference(prevPTime)
                    in if pTime < 15 then
                        1.5
                    else 1 endif
                endif
            else 1 endif)
        else 0 endif
    pre noPre: true
    post noPost: true
end -- Play Class

class Board
operations
    --! getSlot doc
    --! @brief Returns the slot at the row and column specified
    --!
    --! It appears as though there is a bug in specifying qualifiers using
    --! variables in SOIL so this method was written to work around that. See
    --! the executePlay() method in match for details
    --!
    --! @param Integer r The row the slot is in
    --! @param Integer c The column the slot is in
    --! @return Slot
    getSlot(r: Integer, c: Integer): Slot = slots[r, c]
    pre argsAreValid: Set{1..15}->includesAll(Set{r, c})
    post noPost: true
end -- Board Class

class Slot
attributes
    filledAt: DateTime derived = tile.play.time
operations
    --! getTile doc
    --! @brief Returns the tile in the slot
    --!
    --! @return Tile
    getTile(): Tile = tile

    --! getTileString doc
    --! @brief Returns the letter on the tile in the slot as a string
    --!
    --! @return String
    getTileString(): String = getTile().getLetterString()

    --! fill doc
    --! @brief Places a Tile into the slot
    --!
    --! @param Tile t The tile to be placed in the slot
    fill(t: Tile)
    begin insert (self, t) into Fill; end
    pre argIsValid: t <> null and t.play.match = board.match
    pre isEmpty: tile = null
    pre tileNotHeldByAnything:
        Set{t.slot, t.rack, t.tileBag}->excluding(null)->size() = 0
    post slotFilled: tile = t

    --! isEmpty doc
    --! @brief Returns true if the slot does not contain a tile
    --! @return Boolean
    isEmpty(): Boolean = tile->isEmpty()
end -- Slot Class

class Tile
attributes
    points: Integer
operations
    --! getLetter doc
    --! @brief Returns the letter on the Tile
    --!
    --! @return Letter
    getLetter(): Letter = letter

    --! getLetterString doc
    --! @brief Returns the letter on the Tile as a string
    --!
    --! @return String
    getLetterString(): String = getLetter().getLetter()

    --! getPoints doc
    --! @brief Returns the point value of the Tile
    --!
    --! @return Integer
    getPoints(): Integer = points
--statemachines
--    psm placementState
--    states
--        start: initial
--        bag [tileBag <> null and rack = null and slot = null]
--        rack [tileBag = null and rack <> null and slot = null]
--        board: final [tileBag = null and rack = null and slot <> null]
--    transitions
--        start -> bag
--        bag -> rack
--        rack -> board
--    end
end -- Tile Class

class Letter
attributes
    letter: String
operations
    --! getLetter doc
    --! @brief Returns the string value of the letter
    --!
    --! @return String
    getLetter(): String = letter

    --! equals doc
    --! @brief Returns true if the string value of both letters is the same
    --!
    --! @return Boolean
    equals(l: Letter): Boolean = (getLetter() = l.getLetter())
    pre argIsValid: l <> null
end -- Letter Class

class TileBag
operations
    --! random doc
    --! @brief Generates pseudo random number based on the current time to be
    --!        used to pick the next tile to draw
    --!
    --! @return Integer
    random(): Integer =
        let
            tcnt = tiles->size(),
            dividend = board.match.scrumble.clock.time.secondsSinceEposh,
            quotient = dividend div tcnt
        in if tcnt > 0 then
                (quotient.mod(tcnt) + dividend.mod(tcnt)).mod(tcnt) + 1
            else -1 endif
    post validNum: result >= 1 and result <= tiles->size()

    --! remove doc
    --! @brief Randomly picks a tile from the bag
    --!
    --! @param Integer tcnt The maximum number of tiles to be removed
    --! @return Sequence(Tiles)
    remove(tcnt: Integer): Set(Tile)
    begin
        declare t: Tile,
            removedTiles: Set(Tile),
            tBefore: Set(Tile);

        tBefore := self.tiles;
        for i in Sequence{1..tcnt} do
            if self.tiles->size() > 0 then
                t := self.tiles->asSequence()->at(self.random());
                delete (self, t) from Stock;
            end;
        end;
        result := tBefore - self.tiles;
    end

    pre argIsValid: tcnt >= 1 and tcnt <= 9
    post tilesRemoved: (result = (tiles@pre - tiles)) and
        result->size() <= tcnt
end -- TileBag Class

class Word
attributes
    category: Category
    status: WordStatus init: #VALID
operations
    --! getWord doc
    --! @brief Returns a String that represents the word
    --!
    --! @return String
    getWord(): String = letters->iterate(l; ans: String = '' |
        ans + l.getLetter())
    pre noPre: true
    post noPost: true

    --! equals doc
    --! @brief Returns true if the string values of both words is equal
    --!        (ignoring the case of the characters)
    --!
    --! @param String ws The string to compare the string form of the word to
    --! @return Boolean
    equals(ws: String): Boolean = getWord().equalsIgnoreCase(ws)
    pre argIsValid: ws <> null
    post noPost: true

    --! length doc
    --! @brief Returns the length of the word
    --!
    --! @return Integer
    length(): Integer = letters->size()
    pre noPre: true
    post noPost: true

    --protected setters
end -- Word Class

class Dictionary
operations
    --! lookup doc
    --! @brief Searches for the word that matches the arguement passed and
    --!        returns it, returns null otherwise
    --!
    --! @param String ws The word to be searched for in the dictionary
    --! @return Word
    lookup(ws: String): Word = words->any(w | w.equals(ws))
    pre argIsValid: ws <> null

    --protected setters
end -- Dictionary Class

class Match < Identifiable, Observable, Observer
attributes
    type: MatchType
    timed: Boolean
    duration: Period
    category: Category
    status: MatchStatus init: #INPROGRESS
    score: Integer init: 0
operations
    --! init doc
    --! @brief Initializes the match
    --!
    --! Sets all the attributes of the match and creates the board
    --!
    --! @param MatchType matchType The type of match to be created
    --! @param Boolean matchTimed Whether the match is timed or not
    --! @param Category cat The special category to be applied
    init(matchType: MatchType, matchTimed: Boolean, cat: Category)
    begin
        declare d: DateTime;
        self.id := 'm' + self.scrumble.matches->size().toString();
        self.type := matchType;
        self.timed := matchTimed;
        self.category := cat;

        d := new DateTime();
        insert (d, self.scrumble.clock.time) into CurrentTime;
        d.setToNow();
        self.duration := new Period();
        self.duration.addStart(d);
    end

    pre argsAreValid: matchType <> null and matchTimed <> null and
        (matchType = #RANKED implies matchTimed) and cat <> null
    pre linkedToScrumble: scrumble <> null
    post isInitialised: type = matchType and timed = matchTimed and
        category = cat and status = #INPROGRESS and score = 0 and
        duration.getStart().equalsNow() and duration.isSelfValid()

    --! notify doc
    --! @brief Loops through all the observers and calls update for each of
    --!        them
    notify()
    begin
        if not (self.status = self.calcStatus() and
            self.score = self.calcSlider())
        then
            self.status := self.calcStatus();
            self.score := self.calcSlider();

            for o in self.observer do
                if (o.oclIsTypeOf(Leaderboard) = true) then
                    if self.status <> #INPROGRESS then
                        o.oclAsType(Leaderboard).update(self);
                    end;
                else if (o.oclIsTypeOf(Player) = true) then
                    o.oclAsType(Player).update(self);
                end; end;
            end;
        end;
    end

    pre noPre: true
    post noPost: true

    --! update doc
    --! @brief This is the method called by the observable to update the
    --!        Observer
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    begin
        declare d: DateTime;

        if self.status = #INPROGRESS then
            self.status := self.calcStatus();
            self.score := self.calcSlider();

            if self.status <> #INPROGRESS then
                d := new DateTime();
                insert (d, self.scrumble.clock.time) into CurrentTime;
                d.setToNow();
                self.duration.addEnd(d);

                for Obsrvr in self.observer do
                    if (Obsrvr.oclIsTypeOf(Leaderboard) = true) then
                        Obsrvr.oclAsType(Leaderboard).update(self);
                    else if (Obsrvr.oclIsTypeOf(Player) = true) then
                        Obsrvr.oclAsType(Player).update(self);
                    end; end;
                end;
            end;
        end;
    end

    pre argIsValid: o.oclIsTypeOf(Clock)
    post noPost: true

    --! calcSlider doc
    --! @brief Updates the position of the slider
    --!
    --! @return Integer
    calcSlider(): Integer =
    playHistory->iterate(p; ans: Integer = 0 |
        if playHistory->indexOf(p).mod(2) = 1 then
            ans + p.score
        else
            ans - p.score
        endif)
    pre noPre: true
    pre noPost: true

    --! calcStatus doc
    --! @brief Updates the status of the match
    --!
    --! @return MaatchStatus
    calcStatus(): MatchStatus =
        -- A match is complete if a player wins, the match times out or both
        -- players have played the same number of times and at least one
        -- empties their hand. A match is abandoned if a player quits
        -- otherwise the match is still in progress.
        if score.abs() >= 100 or
            (type = #UNRANKED and duration.durationInDays() = 30) or
            (type = #RANKED and duration.duration() = 300) or -- seconds
            (playHistory->size().mod(2) = 0 and
                rack->exists(r | r.tiles->size() = 0))
        then
            #COMPLETE
        else if playHistory->last().type = #QUIT then
            #ABANDONED
        else
            #INPROGRESS
        endif endif
    pre noPre: true
    pre noPost: true

    --! getTiles doc
    --! @brief Gets tiles to fill the empty slots in the rack
    getTiles(r: Rack)
    begin
        declare newTiles: Set(Tile);
        newTiles := self.board.tileBag.remove(9 - r.tiles->size());

        for t in newTiles do
            insert (r, t) into Hold;
        end;
    end

    pre hasSpace: r.tiles->size() < 9
    post gotTiles: (r.tiles->asSet() - r.tiles@pre->asSet()) =
        (board.tileBag.tiles@pre->asSet() - board.tileBag.tiles->asSet())

    --! getWordsSpeltByPlay doc
    --! @brief Returns all the words spelt by a play
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param OrderedSet(Tile) tileSeq The set of tiles to be used to make
    --!                                 the play
    --! @param DateTime pTime The point in time at which the play was made
    --! @return Set(String)
    getWordsSpeltByPlay(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile), pTime: DateTime): Bag(String) =
        let
            tcnt = tileSeq->size(),
            -- All the slots that were filled by tiles provided by the rack
            -- this turn
            mainWordSlots = if dir = #HORIZONTAL then
                Sequence{sCol..15}->iterate(
                c; ans: Sequence(Integer) = Sequence{} |
                    if (ans->size() < tcnt) and
                        (board.slots[sRow, c].isEmpty() or
                        (not board.slots[sRow, c].filledAt.before(pTime)))
                    then
                        ans->append(c)
                    else ans endif
                )
            else --if dir = #VERTICAL then
                Sequence{sRow..15}->iterate(
                r; ans: Sequence(Integer) = Sequence{} |
                    if (ans->size() < tcnt) and
                        (board.slots[r, sCol].isEmpty() or
                        (not board.slots[r, sCol].filledAt.before(pTime)))
                    then
                        ans->append(r)
                    else ans endif
                )
            endif,

            mainWord = if dir = #HORIZONTAL then
                Sequence{sCol..15}->iterate(c; ans: String = '' |
                    let
                        s = board.slots[sRow, c]
                    in if not s.isEmpty() and ((sCol + ans.size()) = c) and
                            (not s.filledAt.after(pTime))
                        then
                            ans + s.getTileString()
                        else if mainWordSlots->includes(c) then
                            ans + tileSeq->at(mainWordSlots->indexOf(c))
                                .getLetterString()
                        else ans endif endif
                )
            else --if dir = #VERTICAL then
                Sequence{sRow..15}->iterate(r; ans: String = '' |
                    let
                        s = board.slots[r, sCol]
                    in if not s.isEmpty() and ((sRow + ans.size()) = r) and
                            (not s.filledAt.after(pTime))
                        then
                            ans + s.getTileString()
                        else if mainWordSlots->includes(r) then
                            ans + tileSeq->at(mainWordSlots->indexOf(r))
                                .getLetterString()
                        else ans endif endif
                )
            endif,

            secondaryWords = if dir = #HORIZONTAL then
                mainWordSlots->iterate(c; ans: Bag(String) = Bag{} |
                    let
                        word = Sequence{1..(sRow-1)}->reverse()->iterate(
                            r; top: String = '' |
                                let
                                    s = board.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    s.filledAt.before(pTime) and
                                    ((sRow - top.size() - 1) = r)) then
                                        s.getTileString() + top
                                    else top endif
                            ) +
                            (if board.slots[sRow, c].isEmpty() then
                                tileSeq->at(mainWordSlots->indexOf(c))
                            else
                                board.slots[sRow, c].getTileString()
                            endif).oclAsType(String)
                            +
                            Sequence{(sRow+1)..15}->iterate(
                            r; bot: String = '' |
                                let
                                    s = board.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    s.filledAt.before(pTime) and
                                    ((sRow + bot.size() + 1) = r)) then
                                        bot + s.getTileString()
                                    else bot endif
                            )
                    in if word.size() > 1 then
                            ans->including(word)
                        else ans endif
                )
            else --if dir = #VERTICAL then
                mainWordSlots->iterate(r; ans: Bag(String) = Bag{} |
                    let
                        word = Sequence{1..(sCol-1)}->reverse()->iterate(
                            c; left: String = '' |
                                let
                                    s = board.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    s.filledAt.before(pTime) and
                                    ((sCol - left.size() - 1) = c)) then
                                        s.getTileString() + left
                                    else left endif
                            ) +
                            (if board.slots[r, sCol].isEmpty() then
                                tileSeq->at(mainWordSlots->indexOf(r))
                            else
                                board.slots[r, sCol].getTileString()
                            endif).oclAsType(String)
                            +
                            Sequence{(sCol+1)..15}->iterate(
                            c; right: String = '' |
                                let
                                    s = board.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    s.filledAt.before(pTime) and
                                    ((sCol + right.size() + 1) = c)) then
                                        right + s.getTileString()
                                    else right endif
                            )
                    in if word.size() > 1 then
                            ans->including(word)
                        else ans endif
                )
            endif
        in if secondaryWords <> null then
                Bag{mainWord}->union(secondaryWords)
            else Bag{mainWord} endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol}) and
        tileSeq->size() > 0 and dir <> null and pTime.isSelfValid()
    post noPost: true

    --! executePass doc
    --! @brief Creates a play with type pass
    --!
    --! @param Rack r The rack that triggered the Pass
    executePass(r: Rack)
    begin
        declare
            p: Play,
            pTime: DateTime,
            i: Integer;

        pTime := new DateTime();
        insert (pTime, self.scrumble.clock.time) into CurrentTime;
        pTime.setToNow();

        p := new Play(self.id + 'Play' +
            (self.playHistory->size() + 1).toString());
        insert (r, p) into Played;
        insert (self, p) into Plays;
        p.init(0, 0, null, null, #PASS, pTime);

        self.notify();
    end

    pre argIsValid: r <> null
    pre isPlayersTurn:
        let
            turn = playHistory->size().mod(players->size()) + 1
        in players->at(turn) = r.players
    pre matchNotFinished: status = #INPROGRESS
    post playMade:
        let
            lp = playHistory->last()
        in lp.type = #PASS and lp.time.equalsNow() and
            playHistory@pre->including(lp) = playHistory and
            lp.oclIsNew() and lp.tiles->size() = 0

    --! executeQuit doc
    --! @brief Creates a play with type quit
    --!
    --! @param Rack r The rack that triggered the Quit
    executeQuit(r: Rack)
    begin
        declare
            p: Play,
            pTime: DateTime,
            i: Integer;

        pTime := new DateTime();
        insert (pTime, self.scrumble.clock.time) into CurrentTime;
        pTime.setToNow();

        p := new Play(self.id + 'Play' +
            (self.playHistory->size() + 1).toString());
        insert (r, p) into Played;
        insert (self, p) into Plays;
        p.init(0, 0, null, null, #QUIT, pTime);

        self.notify();
    end

    pre argIsValid: r <> null
    pre isPlayersTurn:
        let
            turn = playHistory->size().mod(players->size()) + 1
        in players->at(turn) = r.players
    pre matchNotFinished: status = #INPROGRESS
    post playMade:
        let
            lp = playHistory->last()
        in lp.type = #QUIT and lp.time.equalsNow() and
            playHistory@pre->including(lp) = playHistory and
            lp.oclIsNew() and lp.tiles->size() = 0
    post abandoned: status = #ABANDONED

    --! executePlay doc
    --! @brief Places the tiles on the board
    --!
    --! @param Rack r The rack that triggered the Play
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param OrderedSet(Tile) tileSeq The set of tiles to be used to make
    --!                                 the play
    executePlay(r: Rack, sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile))
    begin
        declare
            p: Play,
            pTime: DateTime,
            i: Integer,
            words: Set(Word),
            s: Slot;

        pTime := new DateTime();
        insert (pTime, self.scrumble.clock.time) into CurrentTime;
        pTime.setToNow();

        p := new Play(self.id + 'Play' +
            (self.playHistory->size() + 1).toString());
        insert (r, p) into Played;
        insert (self, p) into Plays;
        p.init(sRow, sCol, dir, tileSeq, #PLAY, pTime);

        for t in tileSeq do
            -- Remove from Rack
            delete (r, t) from Hold;
            -- Store reference in Play
            insert (p, t) into Use;
        end;

        -- Fill the Slots on the Board
        i := 1;
        if dir = #HORIZONTAL then
            for col in Sequence{sCol..15} do
                --if self.board.slots[sRow, col].isEmpty() and
                --    i <= tileSeq->size()
                --then
                --    self.board.slots[sRow, col].fill(tileSeq->at(i));
                --    i := i + 1;
                --end;
                if self.board.getSlot(sRow, col).isEmpty() and
                    i <= tileSeq->size()
                then
                    self.board.getSlot(sRow, col).fill(tileSeq->at(i));
                    i := i + 1;
                end;
            end;
        else --if dir = #VERTICAL then
            for row in Sequence{sRow..15} do
                --if self.board.slots[row, sCol].isEmpty() and
                --    i <= tileSeq->size()
                --then
                --    self.board.slots[row, sCol].fill(tileSeq->at(i));
                --    i := i + 1;
                --end;
                if self.board.getSlot(row, sCol).isEmpty() and
                    i <= tileSeq->size()
                then
                    self.board.getSlot(row, sCol).fill(tileSeq->at(i));
                    i := i + 1;
                end;
            end;
        end;

        -- Find all the words spelt and link them to the play
        words := self.getWordsSpeltByPlay(sRow, sCol, dir, tileSeq, p.time)
            ->iterate(ws; ans: Set(Word) = Set{} |
                ans->including(self.dictionary.lookup(ws))
            )->excluding(null);
        for w in words do
            insert (p, w) into Spelt;
        end;

        -- Get new tiles from the LetterBag
        r.drawTiles();

        self.notify();
    end

    pre playIsValid: playHelperIsPlayValid(sRow, sCol, dir, tileSeq)
    pre isPlayersTurn:
        let
            turn = playHistory->size().mod(players->size()) + 1
        in players->at(turn) = r.players
    pre matchNotFinished: status = #INPROGRESS
    post playMade:
        let
            lp = playHistory->last()
        in lp.type = #PLAY and lp.time.equalsNow() and
            playHistory@pre->including(lp) = playHistory and
            lp.oclIsNew() and lp.tiles->asSet() = tileSeq->asSet() and
            (not lp.words->isEmpty())
    post tilesPlaced:
        (if dir = #HORIZONTAL then
            Sequence{sCol..15}->iterate(c; ans: Set(Slot) = Set{} |
                ans->including(board.slots[sRow, c]))
        else --if dir = #VERTICAL then
            Sequence{sRow..15}->iterate(r; ans: Set(Slot) = Set{} |
                ans->including(board.slots[r, sCol]))
        endif)->select(s | playHistory->last().time = s.filledAt)
            .getTile()->includesAll(tileSeq)

    --! playHelperAllTilesFit doc
    --! @brief Returns true if all the tiles to be used will occupy a space in
    --!        the row/column within the bounds of the start of the play and
    --!        the end of the board
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param Integer tcnt The number of tiles to be placed
    --! @return Boolean
    playHelperAllTilesFit(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        if dir = #HORIZONTAL then
            Sequence{sCol..15}->iterate(c; ans: Integer = 0 |
                if board.slots[sRow, c].isEmpty() then
                    ans + 1
                else ans endif
            ) >= tcnt
        else --if dir = #VERTICAL then
            Sequence{sRow..15}->iterate(r; ans: Integer = 0 |
                if board.slots[r, sCol].isEmpty() then
                    ans + 1
                else ans endif
            ) >= tcnt
        endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol, tcnt}) and
        dir <> null
    post noPost: true

    --! playHelperPlayIntersects doc
    --! @brief Returns true if the play intersects with a word on the board
    --!
    --! A play intersects with a word if there is an existing word
    --! intersecting with the tiles placed
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param Integer tcnt The number of tiles to be placed
    --! @return Boolean
    playHelperPlayIntersects(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        if dir = #HORIZONTAL then
            Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                ans or
                (board.slots[sRow, sCol + o - 1].isEmpty() implies
                    (not Set{board.slots[sRow - 1, sCol + o - 1].tile,
                    board.slots[sRow + 1, sCol + o - 1].tile}->isEmpty()))
            ) or board.slots[sRow, sCol + tcnt].tile <> null
        else --if dir = #VERTICAL then
            Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                ans or
                (board.slots[sRow + o - 1, sCol].isEmpty() implies
                    (not Set{board.slots[sRow + o - 1, sCol - 1].tile,
                    board.slots[sRow + o - 1, sCol + 1].tile}->isEmpty()))
            ) or board.slots[sRow + tcnt, sCol].tile <> null
        endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol, tcnt}) and
        dir <> null
    post noPost: true

    --! playHelperSpeltWordsValid doc
    --! @brief Checks that all the words that would be spelt by the play are
    --!        words in the game's dictionary
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param OrderedSet(Tile) tileSeq The set of tiles to be used to make
    --!                                 the play
    --! @return Boolean
    playHelperSpeltWordsValid(sRow: Integer, sCol: Integer,
    dir: PlayDirection, tileSeq: OrderedSet(Tile)): Boolean =
       getWordsSpeltByPlay(sRow, sCol, dir, tileSeq, scrumble.clock.time)
           ->asSet()->forAll(w | dictionary.lookup(w) <> null)
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol}) and
       dir <> null and tileSeq->size() > 0
    post noPost: true

    --! playHelperIsPlayValid doc
    --! @brief Returns true if the play is valid
    --!
    --! A play is valid if all the tiles fit within the bounds of the play and
    --! there is an existing word intersecting with the tiles placed
    --!
    --! @return Boolean
    playHelperIsPlayValid(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile)): Boolean =
        playHelperAllTilesFit(sRow, sCol, dir, tileSeq->size()) and
        ((playHistory->size() > 0 and
            playHelperPlayIntersects(sRow, sCol, dir, tileSeq->size())) or
        (playHistory->size() = 0 and sRow = 8 and sCol = 8 and
                dir <> null and tileSeq->size() > 0)) and
        playHelperSpeltWordsValid(sRow, sCol, dir, tileSeq)
    pre noPre: true
    pre noPost: true

    --! tilePointsAreValid doc
    --! @brief Checks that all the tiles with the same letter have the same
    --!        point value
    --!
    --! @return Boolean
    tilePointsAreValid(): Boolean =
        let
            bagTiles = board.tileBag.tiles,
            rackTiles = rack.tiles->asSet(),
            boardTiles = board.slots.tile,
            allTiles = bagTiles->union(rackTiles->union(boardTiles))
                ->excluding(null)
        in allTiles->forAll(t1, t2|
            t1.getLetter().equals(t2.getLetter()) implies
            t1.getPoints() = t2.getPoints())
    pre noPre: true
    pre noPost: true

    --! tileCountIsValid doc
    --! @brief Checks that the number of tiles being used in the match is
    --!        valid
    --!
    --! @return Boolean
    tileCountIsValid(): Boolean =
        let
            bagLetters = board.tileBag.tiles->asSet(),
            rackLetters = rack.tiles->asSet(),
            boardLetters = board.slots.tile->asSet(),
            allTiles = bagLetters->union(rackLetters->union(boardLetters))
                ->excluding(null),
            count = allTiles->iterate(
                tile; cnt:Tuple(a: Integer, b: Integer, c: Integer,
                d: Integer, e: Integer, f: Integer, g: Integer, h: Integer,
                i: Integer, j: Integer, k: Integer, l: Integer, m: Integer,
                n: Integer, o: Integer, p: Integer, q: Integer, r: Integer,
                s: Integer, t: Integer, u: Integer, v: Integer, w: Integer,
                x: Integer, y: Integer, z: Integer) =
                Tuple{a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0,
                h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0,
                p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0,
                x = 0, y = 0, z = 0} |
                    Tuple{
                    a = if tile.getLetterString() = 'A' then cnt.a + 1
                        else cnt.a endif,
                    b = if tile.getLetterString() = 'B' then cnt.b + 1
                        else cnt.b endif,
                    c = if tile.getLetterString() = 'C' then cnt.c + 1
                        else cnt.c endif,
                    d = if tile.getLetterString() = 'D' then cnt.d + 1
                        else cnt.d endif,
                    e = if tile.getLetterString() = 'E' then cnt.e + 1
                        else cnt.e endif,
                    f = if tile.getLetterString() = 'F' then cnt.f + 1
                        else cnt.f endif,
                    g = if tile.getLetterString() = 'G' then cnt.g + 1
                        else cnt.g endif,
                    h = if tile.getLetterString() = 'H' then cnt.h + 1
                        else cnt.h endif,
                    i = if tile.getLetterString() = 'I' then cnt.i + 1
                        else cnt.i endif,
                    j = if tile.getLetterString() = 'J' then cnt.j + 1
                        else cnt.j endif,
                    k = if tile.getLetterString() = 'K' then cnt.k + 1
                        else cnt.k endif,
                    l = if tile.getLetterString() = 'L' then cnt.l + 1
                        else cnt.l endif,
                    m = if tile.getLetterString() = 'M' then cnt.m + 1
                        else cnt.m endif,
                    n = if tile.getLetterString() = 'N' then cnt.n + 1
                        else cnt.n endif,
                    o = if tile.getLetterString() = 'O' then cnt.o + 1
                        else cnt.o endif,
                    p = if tile.getLetterString() = 'P' then cnt.p + 1
                        else cnt.p endif,
                    q = if tile.getLetterString() = 'Q' then cnt.q + 1
                        else cnt.q endif,
                    r = if tile.getLetterString() = 'R' then cnt.r + 1
                        else cnt.r endif,
                    s = if tile.getLetterString() = 'S' then cnt.s + 1
                        else cnt.s endif,
                    t = if tile.getLetterString() = 'T' then cnt.t + 1
                        else cnt.t endif,
                    u = if tile.getLetterString() = 'U' then cnt.u + 1
                        else cnt.u endif,
                    v = if tile.getLetterString() = 'V' then cnt.v + 1
                        else cnt.v endif,
                    w = if tile.getLetterString() = 'W' then cnt.w + 1
                        else cnt.w endif,
                    x = if tile.getLetterString() = 'X' then cnt.x + 1
                        else cnt.x endif,
                    y = if tile.getLetterString() = 'Y' then cnt.y + 1
                        else cnt.y endif,
                    z = if tile.getLetterString() = 'Z' then cnt.z + 1
                        else cnt.z endif}
                )
        in (count.a = 9 and count.b = 2 and count.c = 2 and count.d = 4 and
            count.e = 12 and count.f = 2 and count.g = 3 and count.h = 2 and
            count.i = 9 and count.j = 1 and count.k = 1 and count.l = 4 and
            count.m = 2 and count.n = 6 and count.o = 8 and count.p = 2 and
            count.q = 1 and count.r = 6 and count.s = 4 and count.t = 6 and
            count.u = 4 and count.v = 2 and count.w = 2 and count.x = 1 and
            count.y = 2 and count.z = 1)
    pre noPre: true
    pre noPost: true
statemachines
    psm matchStates
    states
        start: initial
        inprogress [status = #INPROGRESS]
        completed: final [status = #COMPLETE]
        abandoned: final [status = #ABANDONED]
    transitions
        start -> inprogress {create}
        inprogress -> inprogress {update()}
        inprogress -> completed {update()}
        inprogress -> abandoned {executeQuit()}
    end
end -- Match Class

class Leaderboard < Observer
operations
    --getters

    --! update doc
    --! @brief This is the method called by the observable to update the
    --!        Observer
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    begin
        if (o.oclIsTypeOf(Match) = true) then
            self.updateHelperMatch(o.oclAsType(Match));
        end;
    end
    pre noPre: true
    post noPost: true

    --! updateHelperMatch doc
    --! @brief Updates the players' ranks once a ranked match is complete
    --!
    --! @param Match o The match that called the method
    updateHelperMatch(o: Match)
    begin
        declare
            pTime: Integer,
            winner: Integer,
            loser: Integer,
            firstPlay: Play,
            p: Play,
            prevP: Play,

            player1: Player,
            p1Score: Integer,
            p1PlayCnt: Integer,
            p1AvgTime: Real,
            p1AvgScore: Real,

            player2: Player,
            p2Score: Integer,
            p2PlayCnt: Integer,
            p2AvgTime: Real,
            p2AvgScore: Real;

        if (o.type = #RANKED) then
            firstPlay := o.playHistory->first();

            player1 := firstPlay.rack.players;
            p1PlayCnt := 0;
            p1AvgTime := 0;
            p1AvgScore := 0;

            player2 := o.players->any(pl | pl <> player1);
            p2PlayCnt := 0;
            p2AvgTime := 0;
            p2AvgScore := 0;

            for i in Sequence{1..(o.playHistory->size())} do
                p := o.playHistory->at(i);
                if p = firstPlay then
                    pTime := p.time.difference(o.duration.getStart());
                else
                    prevP := o.playHistory->at(i - 1);
                    pTime := p.time.difference(prevP.time);
                end;

                if p.rack.players = player1 then
                    p1AvgTime := p1AvgTime + pTime;
                    p1AvgScore := p1AvgScore + p.score;
                    p1PlayCnt := p1PlayCnt + 1;
                else
                    p2AvgTime := p2AvgTime + pTime;
                    p2AvgScore := p2AvgScore + p.score;
                    p2PlayCnt := p2PlayCnt + 1;
                end;
            end;

            p1AvgTime := p1AvgTime / p1PlayCnt;
            p1AvgScore := p1AvgScore / p1PlayCnt;
            p2AvgTime := p2AvgTime / p2PlayCnt;
            p2AvgScore := p2AvgScore / p2PlayCnt;

            p1Score := (25 *
                    ((p1AvgScore/((p1AvgScore + p2AvgScore)/2)) +
                    (1 - (p1AvgTime/((p1AvgTime + p2AvgTime)/2)))) / 2)
                    .round();
            p2Score := (25 *
                    ((p2AvgScore/((p1AvgScore + p2AvgScore)/2)) +
                    (1 - (p2AvgTime/((p1AvgTime + p2AvgTime)/2)))) / 2)
                    .round();

            if o.score > 0 then -- If player 1 wins
                player1.score := player1.score + p1Score;
                player2.score := player2.score - p2Score;
            else if o.score < 0 then -- If player 2 wins
                player1.score := player1.score + p1Score;
                player2.score := player2.score - p2Score;
            end; end;
        end;
    end
    pre matchFinished: o.status <> #INPROGRESS
    post noPost: true

    --! add doc
    --! @brief Adds a player to the leaderboard
    --!
    --! @param Player p The player to be added to the leaderboard
    add(p: Player)
    begin
        new Rank (p.user.id + 'Rank') between (self, p);
        self.refresh();
    end
    pre argIsValid: p <> null
    post newRankCreated: (p.rank.oclIsNew() = true) and
        p.rank.placement <> null

    --! refresh doc
    --! @brief Updates the ranks of all players
    refresh()
    begin
        declare
            pLst: Sequence(Player),
            rVal: Integer,
            r: Rank,
            p: Player;

        pLst := self.players->sortedBy(p | p.score);
        for i in Sequence{1..pLst->size()} do
            p := pLst->at(i);
            if i = 1 then
                rVal := 1;
            else if pLst->at(i - 1).score = p.score then
                rVal := pLst->at(i - 1).rank.placement;
            else
                rVal := i;
            end; end;

            destroy p.rank;
            r := new Rank (p.user.id + 'Rank') between (self, p);
            r.placement := rVal;
        end;
    end
    pre playersExist: not players->isEmpty()
    post ranksAreOrdered:
        rank->forAll(r |
            let
                i = rank->indexOf(r),
                higherRanks = rank->subOrderedSet(1, i - 1)
            in rank->first() <> r implies
                higherRanks->forAll(upperR |
                    (upperR.placement < r.placement and
                        upperR.players.score > r.players.score) or
                    (upperR.placement = r.placement and
                        upperR.players.score = r.players.score)
                ) and
                higherRanks.placement->asSet()->excludes(r.placement) implies
                    r.placement = i
        )
end -- Leaderboard Class

associationclass Rank
between
    Leaderboard[1]
    Player[*] role players ordered
attributes
    placement: Integer
operations
    --! getRank doc
    --! @brief Returns the rank as an integer
    --!
    --! @return Integer
    getRank(): Integer = placement
    pre noPre: true
    post noPost: true
end -- Rank Association Class

------------------------------------------------------------------------------
-- Associations
------------------------------------------------------------------------------

-----------------------------Pattern and Datatype-----------------------------

association Watches between
    Observer[*]
    Observable[*]
end -- Watches Association

association CurrentTime between
    DateTime[*]
    DateTime[1] role now
end -- CurrentTime Association

association PeriodInterval between
    Period[*]
    DateTime[0..2] role interval ordered
end -- PeriodInterval Association

association OnlyLboard between
    Leaderboard[1] role lboard1
    Leaderboard[1] role lboard2
end -- OnlyLboard Association

association OnlyDict between
    Dictionary[1] role dict1
    Dictionary[1] role dict2
end -- OnlyDict Association

association MatchFactoryBuilder between
    MatchFactory[1] role mFactory
    MatchBuilder[1] role mBuilder
end -- MatchFactoryBuilder Association

---------------------------------Domain Level---------------------------------

association ScrumbleClock between
    Scrumble[1]
    Clock[1]
end -- ScrumbleClock Association

association ScrumbleUsers between
    Scrumble[1]
    User[*] role users
end -- ScrumbleUsers Association

association ScrumbleMatches between
    Scrumble[1]
    Match[*] role matches
end -- ScrumbleMatches Association

association ScrumbleDict between
    Scrumble[1]
    Dictionary[1]
end -- ScrumbleDict Association

association ScrumbleLboard between
    Scrumble[1]
    Leaderboard[1]
end -- ScrumbleLboard Association

association ScrumbleReqFactory between
    Scrumble[1]
    RequestFactory[1] role rFactory
end -- ScrumbleReqFactory Association

association ScrumbleMatchBuilder between
    Scrumble[1]
    MatchBuilder[1] role mBuilder
end -- ScrumbleMatchBuilder Association

association ScrumbleMatchFactory between
    Scrumble[1]
    MatchFactory[1] role mFactory
end -- ScrumbleMatchFactory Association

association ScrumbleQueues between
    Scrumble[1]
    Queue[*] role queues
end -- ScrumbleQueues Association

--------------------------------------ACL-------------------------------------

association UserRole between
    User[1]
    Role[1]
end -- UserRole Association

association RolePerms between
    Role[1]
    Permission[*] role permissions
end -- RolePerms Association

------------------------------Player Interactions-----------------------------

association Signal between
    Notification[*] role notifs
    Observable[1] role event
end -- Signal Association

association Notify between
    Notification[*] role notifs
    Player[1]
end -- Signals Association

association FriendList between
    Player[0..1] role friend
    Player[*] role friends
end -- Friend Association

composition PlayerChat between
    Chat[1] role chat
    Message[*] role messages ordered
end -- End PlayerChat Composition

association SentRequest between
    Player[1] role reqSender
    Request[*] role sentReqs
end -- End SentRequest Association

association RecievedRequest between
    Player[1] role reqRcvr
    Request[*] role rcvdReqs
end -- End RecievedRequest Association

association RequestMatch between
    MatchRequest[0..1] role matchReq
    Match[0..1]
end -- End RequestMatch Association

association SentMessage between
    Player[1] role msgSender
    Message[*] role sentMsgs
end -- End SentMessage Association

association RecievedMessage between
    Player[1] role msgRcvr
    Message[*] role rcvdMsgs
end -- End RecievedMessage Association

association Claim between
    Player[1]
    Report[*] role claims
end -- Claim Association

association Reported between
    Report[*] role reports
    Player[0..1] role reported --directed
end -- Reported Association

-------------------------------------Game-------------------------------------

association MatchGameBoard between
    Match[1]
    Board[1]
end -- End MatchGameBoard Association

composition Grid between
    Board[1] qualifier (row: Integer, col: Integer)
    Slot[1] role slots
end -- End Grid Composition

aggregation Fill between
    Slot[0..1]
    Tile[0..1]
end -- End Fill Aggregation

association LetterOptions between
    TileBag[1]
    Board[1]
end -- End LetterOptions Association

aggregation Stock between
    TileBag[0..1]
    Tile[*] role tiles
end -- End Stock Aggregation

association WordCheck between
    Match[*] role matches
    Dictionary[1]
end -- End WordCheck Association

association ValidWord between
    Dictionary[1]
    Word[*] role words
end -- End ValidWord Association

association Spelling between
    Word[*] role words
    Letter[1..*] role letters ordered
end -- End Spelling Association

association Spelt between
    Play[*] role plays
    Word[*] role words
end -- End Spelt Association

association Plays between
    Match[1]
    Play[*] role playHistory ordered
end -- End Plays Association

aggregation Hold between
    Rack[0..1]
    Tile[0..9] role tiles
end -- End Hold Aggregation

association Played between
    Rack[1]
    Play[*] role plays
end -- End Played Association

association Use between
    Play[0..1]
    Tile[0..9] role tiles ordered
end -- End Use Association

association Mark between
    Tile[*] role tiles
    Letter[1]
end -- End Mark Association

------------------------------------------------------------------------------
-- Constraints
------------------------------------------------------------------------------

constraints
---------------------------------Domain Level---------------------------------

context Scrumble
    -- Each Player has a unique username
    inv uniqueUsernames: users.role
        ->select(r | r.oclIsTypeOf(Player))
        ->isUnique(p | p.oclAsType(Player).username)

    inv currentTimeIsCorrect: clock.time.equals(clock.time.now)

    -- There may only be one queue for each match type
    inv oneQueuePerMatchType:
        let
            r = queues->any(q | q.matchType = #RANKED and q.timed = true),
            urt = queues->any(q | q.matchType = #UNRANKED and q.timed = true),
            urut = queues
                ->any(q | q.matchType = #UNRANKED and q.timed = false)
        in Set{r, urt, urut} = queues
-- End Scrumble Constraints

-------------------------------Abstract Classes-------------------------------

context Identifiable
    -- Each item has a unique id
    inv uniqueIDs: Identifiable.allInstances.isUnique(i | i.id)
        --ids->forAll(i1, i2 | i1 <> i2 implies i1.id <> i2.id)
-- End Identifiable Constraints

--context Observer
--    -- Objects cannot observe themselves
--    inv noSelfObserving: observable->excludes(self)
---- End Observer Constraints

-----------------------------------Datatype-----------------------------------

context DateTime
    inv dateIsValid: isSelfValid()

    -- There must only be one "today" in the system
    inv onlyOneCurrentTime:
        DateTime.allInstances.now->asSet()->excluding(null)->size() = 1
-- End DateTime Constraints

context Period
    -- All Periods are valid
    inv allPeriodsAreValid: isSelfValid()
-- End Period Constraints

------------------------------Player Interactions-----------------------------

context Player
    -- Matches must be ordered
    inv matchesAreOrdered: matchHistory->forAll(m |
        let
            i = matchHistory->indexOf(m),
            prevMatches = matchHistory->subOrderedSet(1, i - 1)
        in matchHistory->first() <> m implies
            prevMatches->forAll(prevM |
                prevM.duration.getStart().before(m.duration.getStart())
            )
    )

    -- For each type of request, ther can only be one pending request between
    -- each unique pair of players.
    inv onlyOnePendingReqPerPlayerPair:
        let
            pending = sentReqs->select(req | req.status = #PENDING)
                ->union(rcvdReqs->select(req | req.status = #PENDING))
        in pending->forAll(r1, r2 |
            (r1 <> r2 and r1.type = r2.type) implies (
                (r1.reqSender <> r2.reqSender and r1.reqRcvr <> r2.reqRcvr) or
                (r1.reqSender <> r2.reqRcvr and r1.reqSender <> r2.reqRcvr))
        )

    -- Once a friend request is accepted the players should be added to each
    -- other's friends list
    inv friendsListComplete:
        let
            frReqs = sentReqs->union(rcvdReqs)
                ->select(req | req.type = #FRIEND and req.status = #ACCEPTED),
            frLst = frReqs.reqSender->union(frReqs.reqRcvr)->asSet()
                ->excluding(self)
        in frLst = friends

    -- Blocked players can't be your friends
    inv notFriendAndBlocked:
        friends->excludesAll(block[player]->select(b |
            b.status = #BLOCKED).blocked
        )

    -- Cannot send requests to yourself
    inv noSelfReqsBlocks: sentReqs.reqRcvr->excludes(self) and
        blocked->excludes(self)

    -- All pending requests from players you block become lost and requests
    -- sent to them become recinded
    inv noPendingReqsWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not sentReqs->union(rcvdReqs)->exists(req |
                Set{req.reqSender, req.reqRcvr}->includes(b.blocked) and
                req.status = #PENDING))

    -- 1. A player may only open one match at a time
    -- 2. If a match is open the player's status must be set to #PLAYING
    -- 3. If the player does not have any matches open then their status
    --    cannot be #PLAYING
    inv statusAndRackStatusConsistent:
        (status = #PLAYING and rack->one(r | r.matchOpen = true)) or
        (status <> #PLAYING and (not rack->exists(r | r.matchOpen = true)))

    -- Players must not encounter players they have blocked in any match
    inv noMatchesWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not matchHistory->exists(m |
                m.players->includes(b.blocked) and
                m.duration.getStart().after(b.date))
        )

    -- There must not be any pending friend or message requests between a
    -- given pair of players if there exists an accepted request of the same
    -- type between them
    inv noPendingFriendOrMsgReqsIfAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type)),
            pending = frAndMsgReqs->select(req | req.status = #PENDING),
            accepted = frAndMsgReqs->select(req | req.status = #ACCEPTED)
        in pending->forAll(p | accepted->forAll(a |
            p.type = a.type implies
                Set{p.reqSender, p.reqRcvr} = Set{a.reqSender, a.reqRcvr}
        ))

    -- For a given pair or players, there may not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv noActiveMsgReqIfPlayersAreFriends:
        let
            allReqs = sentReqs->union(rcvdReqs),
            msgReqs = allReqs->select(req | req.type = #MESSAGE and
                Set{#PENDING, #ACCEPTED}->includes(req.status))
        in msgReqs->forAll(m |
            friends->excludesAll(Set{m.reqSender, m.reqRcvr}))

    -- For a given pair or players, there must not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv onlyOneAcceptedMsgOrFriendReqPerPair:
        let
            acceptedReqs = sentReqs->union(rcvdReqs)->select(req |
                req.status = #ACCEPTED and
                Set{#FRIEND,#MESSAGE}->includes(req.type))
        in acceptedReqs->forAll(a1 | not acceptedReqs->exists(a2 |
            a1 <> a2 and a1.type = a2.type and
                Set{a1.reqSender, a1.reqRcvr} = Set{a2.reqSender, a2.reqRcvr}
        ))

    -- Can only exchange match requests among friends
    inv onlyFriendsExchangeMatchReqs:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                Set{#ACCEPTED, #RECINDED}->includes(req.status)),
            matchReqs = allReqs->select(req | req.type = #MATCH)
        in matchReqs->forAll(mr | frReqs->exists(fr |
            Set{fr.reqSender, fr.reqRcvr} = Set{mr.reqSender, mr.reqRcvr} and
                fr.activePeriod.containsDate(mr.sentDate)
        ))

        -- Players may only have one chat open at a time
        inv noOtherChatOpen: chatState
            ->select(cs | cs.status = #OPEN)->size() <= 1

    -- Can only chat if one player has accepted a message or friend request
    -- from the other player
    inv onlyChatIfRequestAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type) and
                Set{#ACCEPTED, #RECINDED}->includes(req.status))
        in rcvdMsgs->forAll(m | frAndMsgReqs->exists(req |
            Set{req.reqSender, req.reqRcvr} = Set{m.msgSender, m.msgRcvr} and
                req.activePeriod.containsDate(m.sentDate)
        ))

    -- Enforcing this invariant would go against allowing players to go
    -- offline during a match.
    ---- players in match must have status in game
    --inv playerStatusConsistent:
    --    if matchHistory->any(m | m.status = #INPROGRESS) <> null then
    --        status = #PLAYING
    --    else
    --        status <> #PLAYING
    --    endif

    -- Can't play more than one match at a time
    inv onlyPlayingOneOrNoMatches:
        matchHistory->select(m | m.status = #INPROGRESS)->size() <= 1

    -- Players may only join up to one queue at a time
    inv onlyInOneQueue: queues->size() <= 1
-- End Player Constraints

context Chat
    -- Chats can only have 2 participants
    inv onlyTwoParticipants:
        let
            senders = messages.msgSender->asSet(),
            recipients = messages.msgRcvr->asSet()
        in participants->includesAll(senders) and
            participants->includesAll(recipients)

    -- Messages must be ordered
    inv messagesAreOrdered: messages->forAll(m |
        let
            i = messages->indexOf(m),
            previousMsgs = messages->subOrderedSet(1, i - 1)
        in messages->first() <> m implies
            previousMsgs->forAll(prevM | prevM.sentDate.before(m.sentDate)))
-- End Chat Constraints

context ChatState
    -- All messages from the other player before lastOpened date must be seen
    inv onlyMsgsAfterLastOpenedUnseen:
        chatRooms.messages->forAll(m |
            participants->excludes(m.msgSender) implies (
                (m.status = #UNSEEN and m.sentDate.after(lastOpened)) or
                (m.status = #SEEN and (not m.seenDate.after(lastOpened)))
            )
        )

    -- Can't send messages after closing the chat
    inv noSentMsgsAfterChatClosed: status = #CLOSED implies
        (not chatRooms.messages->exists(m |
            participants->includes(m.msgSender) and
            lastOpened.before(m.sentDate)))
-- End ChatState Constraints

context Message
    -- Each message must have a date
    inv hasDate: sentDate.oclIsKindOf(DateTime)

    -- Messages must have a body
    inv noEmptyMsgs: message.size() > 0

    -- Messages may only be seen after they have been sent
    inv validSeenDate: (status = #UNSEEN and seenDate = null) or
        (status = #SEEN and seenDate <> null and
            (not seenDate.before(sentDate)))
-- End Message Constraints

context Request
    -- Each request must have a sent date
    inv hasSentDate: sentDate.oclIsKindOf(DateTime)

    -- 1. ACCEPTED request must have an active period with a start but no
    --    end time and the start time is after the sent time
    -- 2. The active period starts after the request was sent and must not
    --    have an end time
    -- 3. PENDING, REJECTED and LOST requests have no active period
    -- 4. RECINDED requests have an active period with as start and end time
    --    and the start time is after the sent time
    inv validStatus: isSelfValid()
-- End Request Constraints

context MatchRequest
    -- All match requests have the type #MATCH
    inv matchReqTypeIsMatchReq: type = #MATCH

    -- Only accepted match requests may refer to a match
    inv noMatchUnlessAccepted:
        if status = #ACCEPTED then
            match->size() = 1
        else
            match->size() = 0
        endif

    -- Players may not request ranked matches
    inv noRankedMatchRequests: matchType <> #RANKED

    -- Accepted match type must match requested match type
    inv matchDataMatchesMatchReqData: status = #ACCEPTED implies
        (matchType = match.type and timed = match.timed and
        activePeriod.getStart() = match.duration.getStart())
-- End MatchRequest Constraints

context Report
    -- Only Player reports may be associated with more than one player
    inv onlyPlayerReportsHave2Players:
        if type = #PLAYER then
            reported->size() = 1
        else
            reported->size() = 0
        endif
-- End Report Constraints

-------------------------------------Game-------------------------------------

context Queue
    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: matchType = #RANKED implies timed
-- End Queue Constraints

context Rack
    -- No empty spaces unless there are no more tiles in the tileBag
    inv noEmptySpaceUnlessLetterBagEmpty: tiles->size() = 9 or
        (tiles->size() < 9 and matchHistory.board.tileBag.tiles->size() = 0)
-- End Rack Constraints

context Play
    -- Plays must have a direction
    inv hasDirection: direction <> null

    -- Words must intersect or be spelt right alongside existing words
    -- or from the center of the board if all slots are empty
    inv intersectsWithAnotherWord:
        (type = #PLAY and match.playHistory->first() <> self) implies
            (let
                grid = match.board,
                r = startRow,
                c = startCol,
                tcnt = tiles->size()
            in if direction = #HORIZONTAL then
                    Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                        ans or
                        (grid.slots[r, c + o - 1].isEmpty() implies
                            (not Set{grid.slots[r - 1, c + o - 1].tile,
                            grid.slots[r + 1, c + o - 1].tile}->isEmpty()))
                    ) or grid.slots[r, c + tcnt].tile <> null
                else --if direction = #VERTICAL then
                    Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                        ans or
                        (grid.slots[r + o - 1, c].isEmpty() implies
                            (not Set{grid.slots[r + o - 1, c - 1].tile,
                            grid.slots[r + o - 1, c + 1].tile}->isEmpty()))
                    ) or grid.slots[r + tcnt, c].tile <> null
                endif
            )

    -- Plays do not extend beyond the board
    inv allTilesOnBoard: type = #PLAY implies
        (let
            grid = match.board
        in if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(c; ans: Integer = 0 |
                    if not grid.slots[startRow, c].isEmpty() and
                    grid.slots[startRow, c].filledAt.equals(time) then
                        ans + 1
                    else ans endif
                ) >= tiles->size()
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(r; ans: Integer = 0 |
                    if not grid.slots[r, startCol].isEmpty() and
                    grid.slots[r, startCol].filledAt.equals(time) then
                        ans + 1
                    else ans endif
                ) >= tiles->size()
            endif
        )

    -- Passed plays or match quits cant have any tiles
    inv passAndQuitHaveNoTiles: Set{#PASS, #QUIT}->includes(type) implies
        tiles->isEmpty()
-- End Play Constraints

context Board
    -- Must have 15 by 15 slots
    inv boardGridIsValid:
        Sequence{1..15}->iterate(r; ans: Set(Slot) = Set{} |
            ans->union(Sequence{1..15}->iterate(c; ans: Set(Slot) = Set{} |
                ans->including(slots[r, c])
            ))
        )->includesAll(slots)
-- End Board Constraints

context Tile
    -- Ensure Tiles have a valid point value
    inv validPoints: points > 0 and points <= 10

    -- Ensure that tiles are held by only one object at a time
    inv onlyInOnePlace:
        Set{tileBag, rack, slot}->excluding(null)->size() = 1

    -- Tiles used in a play must be on the board
    -- Tiles not used in a play must either be in a rack or the tile bag
    inv tilesInAValidPlace:
        (play = null and (rack <> null or tileBag <> null)) or
        (play <> null and slot <> null and play.match = slot.board.match)
-- End Tile Constraints

context Slot
    -- Each slot must have a filledAt time if not empty
    inv hadFilledAtTimeIfFilled: (isEmpty() and filledAt = null) or
        ((not isEmpty()) and filledAt <> null)
-- End Slot Constraints

context Letter
    -- Ensure that the letter is valid
    inv validLetter: Set{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z'}->includes(letter)
-- End Letter Constraints

context Dictionary
    -- No duplicate words
    inv uniqueWords: words->forAll(w1, w2 |
            Set{w1.status, w2.status}->excludes(#DEPRECATED) and
            (w1 <> w2 implies (not w1.equals(w2.getWord())))
        )
-- End Dictionary Constraints

context Word
    -- All words must have a category assigned
    inv hasCategory: category <> null
-- End Word Constraints

context Match
    -- Each match must have a duration
    inv hasDuration: duration.oclIsKindOf(Period)

    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: type = #RANKED implies (timed = true)

    -- Plays must be ordered
    inv playsAreOrdered: playHistory->forAll(p |
        let
            i = playHistory->indexOf(p),
            previousPlays = playHistory->subOrderedSet(1, i - 1)
        in playHistory->first() <> p implies
            previousPlays->forAll(prevP | prevP.time.before(p.time)))

    -- First word must be spelt in the center
    inv firstPlayStartsAtCentre:
        let
            firstPlay = playHistory->first()
        in (firstPlay.startRow = 8 and firstPlay.startCol = 8)

    -- Plays must alternate between players, ie the game should be turn based
    inv playsAlternateBetweenPlayers:
        playHistory->forAll(p |
            let
                turn = (playHistory->indexOf(p) - 1).mod(players->size()) + 1
            in players->at(turn) = p.rack.players
        )

    -- Ensure all Tiles with the same letter have the same score
    inv consistentTilePointValues: tilePointsAreValid()

    -- must be a fixed set of tiles in circulation for a given match
    inv fixedNumberOfLettersInMatch: tileCountIsValid()

    -- Players must be similar rank for matches where players were assigned by
    -- the system
    inv similarRank: matchReq->size() = 0 implies
        players.rank->forAll(p1, p2 |
            (type = #RANKED and (p1.placement - p2.placement).abs() <= 100) or
            (p1.placement - p2.placement).abs() <= 200
        )

    inv allPlaysSpellValidWords: playHistory->forAll(p |
        getWordsSpeltByPlay(p.startRow, p.startCol, p.direction, p.tiles,
        p.time)->forAll(w | dictionary.lookup(w) <> null))

    inv allWordsSpeltByPlayLinked: playHistory->forAll(p | p.words->asSet() =
            getWordsSpeltByPlay(p.startRow, p.startCol, p.direction, p.tiles,
            p.time)->asSet()->iterate(w; ans: Set(Word) = Set{} |
                ans->including(dictionary.lookup(w))
            )
        )

    -- Once a match ends no additional plays can be made
    inv allPlaysWithinMatchDuration: playHistory->forAll(p |
        duration.containsDate(p.time))

    -- Ensures that the end date for a match corresponds with the final play
    -- if the match is finished or that there is no end date if the match is
    -- still going
    inv matchEndValid:
        let
            lp = playHistory->last(),
            dur = duration.duration()
        in (Set{#COMPLETE, #ABANDONED}->excludes(status) and
                duration.getEnd() = null) or
            (duration.getEnd() = lp.time and
                ((status = #ABANDONED and lp.type = #QUIT) or
                (status = #COMPLETE and
                    (score.abs() >= 100 or
                    (timed and dur > 0 and dur < 300))) --5 min
                )
            )

    -- Checks that no matches last longer than 30 days
    inv untimedMatchesHaveValidDurations:
        (not timed) implies duration.durationInDays() <= 30
-- End Match Constraints

context Leaderboard
    -- All ranks are ordered
    inv ranksAreAccurateAndOrdered:
        rank->forAll(r |
            let
                i = rank->indexOf(r),
                higherRanks = rank->subOrderedSet(1, i - 1)
            in rank->first() <> r implies
                higherRanks->forAll(upperR |
                    (upperR.placement < r.placement and
                        upperR.players.score > r.players.score) or
                    (upperR.placement = r.placement and
                        upperR.players.score = r.players.score)
                ) and
                higherRanks.placement->asSet()->excludes(r.placement) implies
                    r.placement = i
        )
-- End Leaderboard Constraints

-- End All Constraints
