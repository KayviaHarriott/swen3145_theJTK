------------------------------------------------------------------------------
--! @authors: Jason Hunter, Kayvia Harriott, Tashna-Gail Williams
--! Created on: 2021-10-11
--! @version: 0.4.9
--! Last Updated: 2021-11-24 17:01:53
------------------------------------------------------------------------------

model scrumble

------------------------------------------------------------------------------
-- Enumerations
------------------------------------------------------------------------------

enum Action {a, really, long, list, of, permissions}

enum BlockStatus {BLOCKED, UNBLOCKED}
enum ChatStatus {OPEN, CLOSED}
enum MatchStatus {INPROGRESS, COMPLETE, ABANDONED}
enum MessageStatus {UNSEEN, SEEN}
enum PlayerStatus {ONLINE, OFFLINE, AWAY, PLAYING}
enum AccountStatus {BANNED, UNBANNED}
enum ReportStatus {UNRESOLVED, UNDER_REVIEW, RESOLVED}
enum RequestStatus {PENDING, ACCEPTED, REJECTED, RECINDED, LOST}
enum WordStatus {VALID, DEPRECATED}

enum MatchType {RANKED, UNRANKED}
enum PlayType {PLAY, PASS, QUIT}
enum ReportType {BUG, PLAYER}
enum RequestType {FRIEND, MESSAGE, MATCH}

enum Category {ANIMAL, MUSIC, MOVIES, FOOD, BOOKS, COUNTRIES, NONE}
enum ProfileState {PRIVATE, PUBLIC}
enum PlayDirection {HORIZONTAL, VERTICAL}

--! @TODO:
--!     - All the method bodies need to be specified
--!     - Add attributes to represent the rest of the player's profile data
--!     - Rack might need an enum to indicate that a player has a specific
--!       match open so it doesn't generate notifs when the match is open and
--!       a play is made
--!     - Class to represent the match queue for players waiting to join a
--!       match. It would have a never ending loop constantly running to empty
--!       a queue of players and make matches. It would be observable by
--!       Player so a player can get updates when a match is made. We may need
--!       a queue for each type of match
--!     - Figure out how to manage adding and removing words since you
--!       wouldn't want changes to affect past games
--!     - May need a letter factory to facilitate creating new letters for
--!       words
--!     - Need a tile factory to create tiles for each match
--!     - Invariants for checking the active period based on how a request was
--!       addressed
--!     - builder class to create matches and a match factory that is
--!       associated with it (interface with the factory to have it make
--!       games. the builder specifies the different configurations)
--!     - Maybe make queue observable
--!     - Add a permissions class and link Requests, Block and Role to it.
--!       Each of them links to a collection of permissions
--!     - Update invariants to check the friends role of a player instead of
--!       searching for accepted requests like we do now. The constraints
--!       would likely be affected by the permissions granted now that we're
--!       fixing our ACLs
--!     - Add invariants, pre and post conditions to check that the friends
--!       role of a player is properly updated when friend requests are
--!       accepted or recinded as well as the permissions granted are updated
--!       accordingly
--!
--!     DESIGN PATTERN REFINEMENTS
--!         Observer Pattern
--!             In the observer pattern, observables update observers when
--!             they change creating the effect that the observer is
--!             "watching" the observable. So observables have a list of their
--!             observers and call a method in the observer to let them know
--!             things changed. The observer would then execute different
--!             operations to update anything else that depends on the state
--!             of the observable object.
--!
--!         Suggestions for our system:
--!             +------------------------+
--!             | observer    | observes |
--!             +-------------+----------+
--!             | leaderboard | match    |
--!             | player      | match    |
--!             | player      | request  |
--!             | match       | play     |
--!             | player      | chat     |
--!             | player      | report   |
--!             +-------------+----------+
--!
--!         Notes: - Leaderboard observes matches so that player may update
--!                  when a match ends
--!                - Player observes match for status updates
--!                - Player observes request so they may be notified when they
--!                  receive a request
--!                - Match observes play so play may advance the state of the
--!                  game (ie. update the bag, board, racks and score) when a
--!                  play is made and generate a notification
--!                - Player observes chat so chat may notify a player when a
--!                  new message is received
--!                - Player observes report so report may notify a player when
--!                  it's status changes
--!
--!         Builder Pattern
--!             to be researched
--!
--!     ACL REFINEMENTS
--!         - Permissions class - the class holds a value representing what
--!               action is allowed and the relevant objects are associated
--!               with a set of permissions
--!
--!         - Actions enum - lists out all the capabilities of any user of the
--!               system
--!
--!         - Role-Based ACL for Admins and users:
--!             - Role is associated with a set of permissions
--!             - Are we going to allow admins to play matches as well?
--!
--!         - Discressionary ACL for Player interactions:
--!             - Role is associated with a set of permissions
--!

------------------------------------------------------------------------------
-- Classes
------------------------------------------------------------------------------

-------------------------------Abstract Classes-------------------------------

abstract class Identifiable
attributes
    id: String
end -- Identifiable

abstract class Observer
operations
    --! update doc
    --! @brief This is the method called by the observable to update the
    --!        Observer
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    -- #TODO Pre and Post
    pre argIsValid: o <> null
end -- Observer Class

abstract class Observable
end -- Observable Class

-----------------------------------Datatypes----------------------------------

class DateTime
attributes
    TO_SEC: Tuple(y: Integer, d: Integer, hr: Integer, min: Integer) init:
        Tuple{y = 31557600, d = 86400, hr = 3600, min = 60}
    -- 31557600 is the number of seconds in a year
    -- 86400 is the number of seconds in a day
    -- 3600 is the number of seconds in an hour
    -- 60 is the number of seconds in a minute

    EPOSH: Tuple(
        y: Integer, m: Integer, d: Integer,
        hr: Integer, min: Integer, sec: Integer
    ) init: Tuple{y = 2000, m = 1, d = 1, hr = 0, min = 0, sec = 0}

    -- Initialized to this system's eposh time 2000-01-01 00:00:00
    day: Integer init: EPOSH.d
    month: Integer init: EPOSH.m
    year: Integer init: EPOSH.y
    hour: Integer init: EPOSH.hr
    minute: Integer init: EPOSH.min
    second: Integer init: EPOSH.sec
    secondsSinceEposh: Integer derived:
        toSecondsSinceEposh(year, month, day, hour, minute, second)
operations
    --! makeHumanReadable doc
    --! @brief Takes a duration in seconds and it into years, months, days
    --!        hours, minutes and seconds
    --!
    --! @param Integer sec The number of seconds since the eposh time
    --! @return Tuple(y: Integer, m: Integer, d: Integer,
    --!         hr: Integer, min: Integer, sec: Integer)
    makeHumanReadable(sec: Integer): Tuple(
    y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer) =
        let
            years = EPOSH.y + (sec div TO_SEC.y),
            leapDayCorrection = (years div 400) - (years div 100),
            remDays = sec.mod(TO_SEC.y) div TO_SEC.d + leapDayCorrection,
            daysOfEachMonth = if isLeapYear(years) then
                    Sequence{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                else
                    Sequence{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                endif,
            months = 1 + Sequence{1..12}->iterate(m2; ans: Integer = 0 |
                if (daysOfEachMonth->subSequence(1, m2)->sum() < remDays) then
                    ans + 1
                else
                    ans
                endif),
            days = remDays - daysOfEachMonth
                ->subSequence(1, months - 1)->sum(),
            hours = sec.mod(TO_SEC.y).mod(TO_SEC.d) div TO_SEC.hr,
            minutes = sec.mod(TO_SEC.y).mod(TO_SEC.d)
                .mod(TO_SEC.hr) div TO_SEC.min,
            seconds = sec.mod(TO_SEC.y).mod(TO_SEC.d)
                .mod(TO_SEC.hr).mod(TO_SEC.min)
        in Tuple{y = years, m = months, d = days,
            hr = hours, min = minutes, sec = seconds}

    pre argIsValid: sec > 0
    post resultIsValid: isValid(result.y, result.m, result.d,
        result.hr, result.min, result.sec)

    --! toSecondsSinceEposh doc
    --! @brief Converts the human-readable date to the number of seconds
    --!        since the eposh time
    --!
    --! @param Integer y The year of the time to be converted
    --! @param Integer m The month of the time to be converted
    --! @param Integer d The day of the time to be converted
    --! @param Integer hr The hour of the time to be converted
    --! @param Integer min The minute of the time to be converted
    --! @param Integer sec The second of the time to be converted
    --! @return Integer
    toSecondsSinceEposh(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer): Integer =
        let
            years = y - EPOSH.y,
            leapDayCorrection = (years div 400) - (years div 100),
            daysOfEachMonth = if isLeapYear(y) then
                    Sequence{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                else
                    Sequence{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
                endif,
            days = d + Sequence{1..(m - 1)}->iterate(prevM; ans: Integer = 0 |
                ans + daysOfEachMonth->at(prevM)) + leapDayCorrection - 1
        in (years * TO_SEC.y) + (days * TO_SEC.d) +
            (hr * TO_SEC.hr) + (min * TO_SEC.min) + sec

    pre argsAreValid: isValid(y, m, d, hr, min, sec)
    post resultIsValid:
        let
            date = makeHumanReadable(result)
        in result >= 0 and y = date.y and m = date.m and d = date.d and
            hr = date.hr and min = date.min and sec = date.sec

    --! initialise doc
    --! @brief Initialises the datetime instance
    --!
    --! @param Integer y The year to set the datetime to
    --! @param Integer m The month to set the datetime to
    --! @param Integer d The day to set the datetime to
    --! @param Integer hr The hour to set the datetime to
    --! @param Integer min The minute to set the datetime to
    --! @param Integer sec The second to set the datetime to
    initialise(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer)
    begin
        self.year := y;
        self.month := m;
        self.day := d;
        self.hour := hr;
        self.minute := min;
        self.second := sec;
    end

    pre parametersHaveValidValues: isValid(y, m, d, hr, min, sec)
    post attributesCorrectlyUpdated:
        day = d and month = m and year = y and
        hour = hr and minute = min and second = sec

    ---------------------------------Accessors--------------------------------

    getYear(): Integer = year
    getMonth(): Integer = month
    getDay(): Integer = day

    getHour(): Integer = hour
    getMinute(): Integer = minute
    getSecond(): Integer = second

    getNow(): DateTime = now
    post resultNotNull: result <> null

    ---------------------------------Mutators---------------------------------

    setYear(y: Integer)
    begin self.initialise(y, self.month, self.day,
        self.hour, self.minute, self.second); end
    post yearCorrectlyUpdated: year = y

    setMonth(m: Integer)
    begin self.initialise(self.year, m, self.day,
        self.hour, self.minute, self.second); end
    post monthCorrectlyUpdated: month = m

    setDay(d: Integer)
    begin self.initialise(self.year, self.month, d,
        self.hour, self.minute, self.second); end
    post dayCorrectlyUpdated: day = d

    setHour(h: Integer)
    begin self.initialise(self.year, self.month, self.day,
        h, self.minute, self.second); end
    post mutationSuccess: hour = h

    setMinute(m: Integer)
    begin self.initialise(self.year, self.month, self.day,
        self.hour, m, self.second); end
    post mutationSuccess: minute = m

    setSecond(s: Integer)
    begin self.initialise(self.year, self.month, self.day,
        self.hour, self.minute, s); end
    post mutationSuccess: second = s

    setToNow()
    begin self.initialise(self.now.year, self.now.month, self.now.day,
        self.now.hour, self.now.minute, self.now.minute); end
    post mutationSuccess: self.equals(now)

    --------------------------------Predicates--------------------------------

    -- returns true if all the attributes are not null, false otherwise
    isInitialised(): Boolean =
        day <> null and month <> null and year <> null and
        hour <> null and minute <> null and second <> null and
        secondsSinceEposh >= 0
    post returnValueIsAccurate:
        result = Set{day <> null, month <> null, year <> null,
            hour <> null, minute <> null, second <> null,
            secondsSinceEposh >= 0}
            ->forAll(t | t = true)

    -- returns true if self is before d, false otherwise
    before(d: DateTime): Boolean = secondsSinceEposh < d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueIsAccurate:
        result = (secondsSinceEposh < d.secondsSinceEposh) -- = true

    -- returns true if self has the same values as d, false otherwise
    equals(d: DateTime): Boolean = secondsSinceEposh = d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueConditions:
        result = (secondsSinceEposh < d.secondsSinceEposh)

    -- returns true if self is after d, false otherwise
    after(d: DateTime): Boolean = secondsSinceEposh > d.secondsSinceEposh
    pre bothAreInitialised: isInitialised() and d.isInitialised()
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post returnValueIsAccurate:
        result = (secondsSinceEposh > d.secondsSinceEposh)

    -- returns true if y is a leap year, false otherwise
    isLeapYear(y: Integer): Boolean = y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)
    pre yearIsValid: y <> null and y >= 2000
    post returnValueIsAccurate: result = (y.mod(400) = 0 or
        (y.mod(100) > 0 and y.mod(4) = 0)) -- = true

    secondValid(v: Integer): Boolean = v >= 0 and v < 60
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v < 60)

    minuteValid(v: Integer): Boolean = v >= 0 and v <= 59
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v <= 59)

    hourValid(v: Integer): Boolean = v >= 0 and v < 24
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 0 and v < 24)

    dayValid(v: Integer): Boolean = v >= 1 and v <= 31
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 1 and v <= 31)

    monthValid(v: Integer): Boolean = v >= 1 and v <= 12
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 1 and v <= 12)

    yearValid(v: Integer): Boolean = v >= 2000
    pre paramaterNotNull: v <> null
    post returnValueIsAccurate: result = (v >= 2000)

    dayAndMonthValid(m: Integer, d: Integer): Boolean =
        (Set{4, 6, 9, 11}->includes(m) implies d <= 30) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d <= 31)
    pre dayIsValid: dayValid(d)
    pre monthIsValid: monthValid(m)
    post returnValueIsAccurate: result =
        ((Set{4, 6, 9, 11}->includes(m) implies d < 31) and
        (Set{1, 3, 5, 7, 8, 10, 12}->includes(m) implies d < 32))

    febValid(y: Integer, d: Integer): Boolean =
        (isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28)
    pre dayIsValid: dayValid(d)
    pre yearIsValid: yearValid(y)
    post returnValueIsAccurate: result =
        ((isLeapYear(y) implies d <= 29) and
        (not isLeapYear(y) implies d <= 28))

    isValid(y: Integer, m: Integer, d: Integer,
    hr: Integer, min: Integer, sec: Integer): Boolean =
        dayValid(d) and monthValid(m) and yearValid(y) and
        dayAndMonthValid(m, d) and (m = 2 implies febValid(y, d)) and
        hourValid(hr) and minuteValid(min) and secondValid(sec)

    isSelfValid(): Boolean = isValid(year, month, day, hour, minute, second)

    equalsNow(): Boolean = self.equals(self.now)
    pre nowExists: not now->isEmpty()

    --------------------------------Operations--------------------------------

    difference(d: DateTime): Integer =
        secondsSinceEposh - d.secondsSinceEposh
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post resultIsCorrect: result =
        (secondsSinceEposh - d.secondsSinceEposh)

    differenceInDays(d: DateTime): Real = (difference(d) / TO_SEC.d)
    pre bothAreValid: isSelfValid() and d.isSelfValid()
    post resultIsCorrect: result =
        ((secondsSinceEposh - d.secondsSinceEposh) / TO_SEC.d)
end -- DateTime Class

class Period
operations
    --------------------------------Predicates--------------------------------

    -- Returns true if the period has a start date or has a start and end date
    -- and the start date is before the end date
    isValid(startDate: DateTime, endDate: DateTime): Boolean =
        startDate <> null and startDate.isInitialised() and
        (endDate <> null implies startDate.before(endDate))
    pre startDateValid: startDate <> null implies startDate.isSelfValid()
    pre endDateValid: endDate <> null implies endDate.isSelfValid()
    post resultIsCorrect: result = (startDate <> null and
        startDate.isInitialised() and
        (endDate <> null implies startDate.before(endDate)))

    -- Returns true if the current period is valid
    isSelfValid(): Boolean = isValid(getStart(), getEnd())

    -- Returns true if the end date for the current period is before the start
    -- date of the period passed as an argument
    before(p: Period): Boolean = getEnd().before(p.getStart())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = getEnd().before(p.getStart())

    -- Returns true if the start date for the current period is after the end
    -- date of the period passed as an argument
    after(p: Period): Boolean = getStart().after(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = getStart().after(p.getEnd())

    -- Returns true if the start and end of both periods is equal
    equals(p:Period): Boolean = getStart().equals(p.getStart()) and
        getEnd().equals(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (getStart().equals(p.getStart()) and
        getEnd().equals(p.getEnd()))

    -- Returns true if the current period starts before and ends after
    -- the period passed as an argument
    contains(p: Period): Boolean = containsDate(p.getStart()) and
        containsDate(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (containsDate(p.getStart()) and
        containsDate(p.getEnd()))

    -- Returns true if the end date for the current period falls within the
    -- range of the period passed as an argument and the start date doesn't
    overlapsOnLeftOf(p: Period): Boolean =
        getStart().before(p.getStart()) and p.containsDate(getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (getStart().before(p.getStart()) and
        p.containsDate(getEnd()))

    -- Returns true if the start date for the current period falls within the
    -- range of the period passed as an argument and the end date doesn't
    overlapsOnRightOf(p: Period): Boolean =
        p.containsDate(getStart()) and getEnd().after(p.getEnd())
    pre selfAndArgsAreValid: isSelfValid() and p.isSelfValid()
    post noMutations: interval = interval@pre and  p.interval = p.interval@pre
    post resultIsCorrect: result = (p.containsDate(getStart()) and
        getEnd().after(p.getEnd()))

    -- Returns true if the current period starts before and ends after
    -- the period passed as an argument
    containsDate(d: DateTime): Boolean = (not getStart().after(d)) and
        (getEnd() <> null implies (not getEnd().before(d)))
    pre selfAndArgsAreValid: isSelfValid() and d.isSelfValid()
    post noMutations: interval = interval@pre and  d = d@pre
    post resultIsCorrect: result = (getStart().before(d) and
        (getEnd() <> null implies getEnd().after(d)))

    ---------------------------------Accessors--------------------------------

    -- Returns the start date of the period
    getStart(): DateTime = interval->at(1)
    post noMutations: interval = interval@pre
    post resultIsCorrect: result = interval->at(1)

    -- Returns the end date of the period
    getEnd(): DateTime = interval->at(2)
    post noMutations: interval = interval@pre
    post resultIsCorrect: result = interval->at(2)

    ---------------------------------Mutators---------------------------------

    -- Adds a start date if no dates are assigned to the period
    addStart(s: DateTime)
    begin insert (self, s) into PeriodInterval; end
    pre selfNotInit: getStart() = null and getEnd() = null
    pre argIsValid: s.isSelfValid()
    post mutationSuccess: getStart() = s and getEnd() = interval@pre->at(2)
    post selfIsValid: isSelfValid()

    -- Adds an end date if a start date is specified
    addEnd(s: DateTime)
    begin insert (self, s) into PeriodInterval; end
    pre selfAndArgsAreValid: isSelfValid() and s.isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = s
    post selfStillValid: isValid(getStart(), getEnd())

    -- Removes start date if no end date is specified
    removeStart()
    begin delete (self, getStart()) from PeriodInterval end
    pre selfIsValid: isSelfValid()
    post selfNotInit: getStart() = null and getEnd() = null

    -- Removes the end date
    removeEnd()
    begin delete (self, getEnd()) from PeriodInterval end
    pre selfIsValid: isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = null

    -- Replaces start date with the new date
    replaceStart(s: DateTime)
    begin
        declare endDate: DateTime;
        endDate := getEnd();
        delete (self, getStart()) from PeriodInterval;
        delete (self, endDate) from PeriodInterval;

        insert (self, s) into PeriodInterval;
        insert (self, endDate) into PeriodInterval;
    end

    pre selfAndArgsAreValid: isSelfValid() and s.isSelfValid()
    post mutationSuccess: getStart() = s and getEnd() = interval@pre->at(2)
    post selfStillValid: isValid(getStart(), getEnd())

    -- Replaces the end date with the new date
    replaceEnd(s: DateTime)
    begin
        delete (self, getEnd()) from PeriodInterval;
        insert (self, s) into PeriodInterval;
    end

    pre argIsValid: s.isSelfValid()
    pre selfIsValid: isSelfValid()
    post mutationSuccess: getStart() = interval@pre->at(1) and getEnd() = s
    post selfStillValid: isValid(getStart(), getEnd())

    --------------------------------Operations--------------------------------

    duration(): Integer =
        if getEnd() <> null then
            getEnd().difference(getStart())
        else
            getStart().now.difference(getStart())
        endif
    pre selfIsValid: isSelfValid()
    post resultIsCorrect: result =
        if getEnd() <> null then
            getEnd().difference(getStart())
        else
            getStart().now.difference(getStart())
        endif

    durationInDays(): Real =
        if getEnd() <> null then
            getEnd().differenceInDays(getStart())
        else
            getStart().getNow().differenceInDays(getStart())
        endif
    pre selfIsValid: isSelfValid()
    post resultIsCorrect: result =
        if getEnd() <> null then
            getEnd().differenceInDays(getStart())
        else
            getStart().getNow().differenceInDays(getStart())
        endif
end -- Period Class

---------------------------------Domain Level---------------------------------

class Scrumble
operations
    --
end -- Scrumble Class

class User < Identifiable
operations
    -- wrappers for the capabilities/operations of all types of users
    -- (Players and admins)
end -- User Class

--------------------------------------ACL-------------------------------------

class Role
attributes
    --
operations
    --
end -- Role Class

class Permission
attributes
    action: Action
operations
    --getter
end -- Permission Class

--------------------------------Administration--------------------------------

class Admin < Role
attributes
    --
operations
    --! reviewReport doc
    --! @brief Sets the status of the report to #UNDER_REVIEW
    --!
    --! @param Report r The report to update the status of
    reviewReport(r: Report)
    pre argIsValid: r <> null
    pre isUnresolved: r.getStatus() = #UNRESOLVED
    post mutationSuccess: r.getStatus() = #UNDER_REVIEW

    --! resolveReport doc
    --! @brief Sets the status of the report as resolved
    --!
    --! @param Report r The report to update the status of
    resolveReport(r: Report)
    pre argIsValid: r <> null
    pre isUnderReview: r.getStatus() = #UNDER_REVIEW
    post mutationSuccess: r.getStatus() = #RESOLVED

    --! addWord doc
    --! @brief Creates a new word and adds it to the dictionary
    --!
    --! @param Type <var> Description
    --! @param Type <var> Description
    --addWord(w: Sequence(Letter), cat: Category)
    --kayvia edit 6
    addWord(l: Sequence(Letter), c: Category, d : Dictionary)
    begin
        declare w: Word;
        --let word be the sequence of letters, operation createWord suggested
        insert(d,w) into ValidWord;
        w.category := c;
        w.status := #VALID;
        --^^dont think this is needed because of word status init

    
    --insert (self.seenDate, self.sentDate.now) into CurrentTime;
    --    declare b: Block, d: DateTime;
    --    b := new Block() between(p, self);
    --    d := new DateTime();
        
        
    --    b.date := d;
    end
    pre : true --check that dictionary doesn't have word in it
    post : true -- check that category was assigned to word
    -- #TODO Pre and Post

    --! depricatedWord doc
    --! @brief Sets a word as depricated
    --!
    --! @param Word w The word to be deprecated
    --! @return type
    --! @throws conditon
    deprecateWord(w: Word)
    begin

    end
    pre : true
    post : true
    -- #TODO Pre and Post


    --! banPlayer doc
    --! @brief Bans a player
    --!
    --! @param Player p Player to be banned
    --kayvia edit 6
    banPlayer(p: Player)
    -- Sets their status to banned    
    begin
        p.accountStatus := #BANNED
    end
    pre checkPlayerStatusUnbanned: true
    post checkPlayerStatusBanned: true
    -- #TODO Pre and Post


end -- Admin Class

------------------------------Player Interactions-----------------------------

class Player < Observer, Role
attributes
    username: String
    email: String
    dob: DateTime
    score: Integer init: 500
    status: PlayerStatus init: #OFFLINE
    state: ProfileState init: #PRIVATE
    accountStatus: AccountStatus init: #UNBANNED
operations
    --getters (we'll have to restrict what may be obtained in the method I
    -- think)

    --! update doc
    --! @brief Generates notifications based on what event occured
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    -- #TODO Pre and Post

    --! updateHelperMatch doc
    --! @brief Updates the player's score if a ranked match was completed
    --!        or abandoned
    --!
    --! @param Match o The match that called the update method
    updateHelperMatch(o: Match)
    -- for the body we could generate a decimal value based on the difference
    -- in the players' ranks, the time it took to end the game, average points
    -- per play, average time per play
    -- we could cap the amount your score increases to +/- 25 points
    -- #TODO Pre and Post

    --! updateHelperChat doc
    --! @brief update helper function for chat events
    --!
    --! @param Chat o The Chat that called the update method
    updateHelperChat(o: Chat)
    -- #TODO Pre and Post

    --! updateHelperRequest doc
    --! @brief update helper function for request events
    --!
    --! @param Request o The Request that called the update method
    updateHelperRequest(o: Request)
    -- #TODO Pre and Post

    --! updateHelperReport doc
    --! @brief update helper function for report events
    --!
    --! @param Report o The Report that called the update method
    updateHelperReport(o: Report)
    -- #TODO Pre and Post

    --! updateHelperMatchReq doc
    --! @brief update helper function for matchRequest events
    --!
    --! @param MatchRequest o The MatchRequest that called the update method
    updateHelperMatchReq(o: MatchRequest)
    -- #TODO Pre and Post

    --! joinQueue doc
    --! @brief Adds the player to the match queue
    --!
    --! @param Queue q The queue to be joined
    joinQueue(q: Queue)
    begin
        new Join() between (q, self);
    end

    pre argIsValid: q <> null
    pre playerIsOnline: status = #ONLINE
    pre playerNotInQueue: queues->size() = 1
    post joinSuccessful: (q@pre.players->including(self) = q.players) and
        join.joinedAt->forAll(d | d.equalsNow()) and
        (queues->size() = 1)

    --! leaveQueue doc
    --! @brief Removes the player from the match queue they are currently in
    leaveQueue()
    begin
        for q in self.queues do
            destroy q;
        end;
    end

    pre playerIsInQueue: queues->size() = 1
    pre playerIsOnline: status = #ONLINE
    post leaveSuccessful: (queues->size() = 0) and
        (queues@pre.players->excluding(self) = queues.players)

    --! sendMsg doc
    --! @brief Sends a message in the specified chat
    --!
    --! @param Chat c The chat to send the message in
    --! @param String msg The message to be sent
    sendMsg(c: Chat, msg: String)
    pre playerIsOnline: status = #ONLINE
    pre argsAreValid: c <> null and msg.size() > 0
    post msgSent:
        let
            newMsg = c.messages->last()
        in newMsg.oclIsNew() and
            c.messages@pre->including(newMsg) = c.messages and
            newMsg.getBody() = msg and
            newMsg.sentDate.equalsNow()

    --! sendReq doc
    --! @brief Sends a request to the specified player
    --!
    --! @param Player p The player to send the request to
    --! @param RequestType t The type of request to be sent
    sendReq(p: Player, t: RequestType)
    pre playerIsOnline: status = #ONLINE
    pre argsAreValid: p <> null and t <> null
    post reqSent:
        let
            newReq = sentReqs->select(req | req.oclIsNew())
        in newReq->size() = 1 and
            sentReqs@pre->union(newReq) = sentReqs and
            p.rcvdReqs@pre->union(newReq) = p.rcvdReqs and
            newReq->one(req | req.sentDate.equalsNow())
            -- should also check that the status is pending or blocked on the
            -- receivers side

    --! addressReq doc
    --! @brief Updates the status of a received request
    --!
    --! @param Request req The received request to be addressed
    --! @param Boolean action Boolean representing accepting (true) or
    --!                   rejecting (false) the request
    addressReq(req: Request, action: Boolean)
    pre playerIsOnline: status = #ONLINE
    pre argsAreValid: req <> null and action <> null
    pre reqIsPending: req.status = #PENDING
    post reqAddressed: (action and req.status = #ACCEPTED) or
        ((not action) and req.status = #REJECTED)
    post activePeriodSet: req.activePeriod <> null and
        req.activePeriod.getStart().equalsNow()

    --! blockPlayer doc
    --! @brief Adds a player to the player's blocked list
    --!
    --! @param Player p The player to be blocked
    blockPlayer(p: Player)
    begin
        --new Block() between(p, self);
        declare b: Block, d: DateTime;
        b := new Block() between(p, self);
        d := new DateTime();    
        b.date := d;
        --d.setToNow();
        --b.changeBlockDate(d);
        --change date to now, not working
        --

    end
    pre playerIsOnline: status = #ONLINE
    pre argIsValid: p <> null

    --not sure about this -kayvia
    --begin
    --    if (blocked[player]->excludes(p)) then
    --        new Block() between (self, p);
    --    end;

    --    b := block->any(b | b.blocked = p);
    --    b.block();
    --end


    --! unblockPlayer doc
    --! @brief Unblocks a player
    --!
    --! @param Player p The player to be unblocked
    unblockPlayer(p: Player) --kayvia edited 1.
    begin
        delete (p,self) from Block;
        --declare d: Block;
        --d := Block() between(p, self);
    end

    pre argIsValid: p <> null
    --post playerBlocked: block[player]->exists(b|
    --    b.blocked->asSet() = Set{p} and b.status = #BLOCKED and
    --    b.date.equalsNow())

    --not sure what this was for
    --begin
    --    b := block->any(b | b.blocked = p);
    --    b.unblock();
    --end

    --check if player already blocked, not working
    --pre playerIsBlocked:
    --    let
    --        b = block[player]->any(b | b.blocked = p)
    --    in b <> null and b.status = #BLOCKED    
    


    --! reportBug doc
    --! @brief Creates a bug report
    --!
    --! @param String msg A description of the bug being reported
    reportBug(msg: String)
    pre playerIsOnline: status = #ONLINE
    pre argIsValid: msg.size() > 0
    post bugReported:
        let
            newClaim = claims->select(c | c.oclIsNew())
        in newClaim->size() = 1 and
            claims@pre->union(newClaim) = claims and
            newClaim->one(c | c.getDesc() = msg and c.reported->isEmpty())

    --! reportPlayer doc
    --! @brief Creates a report against the specified player
    --!
    --! @param Player p The player to be reported
    --! @param String msg The reason for reporting the player
    reportPlayer(p: Player, msg: String)
    pre playerIsOnline: status = #ONLINE
    pre argIsValid: p <> null and msg.size() > 0
    post playerReported:
        let
            newClaim = claims->select(c | c.oclIsNew())
        in newClaim->size() = 1 and
            claims@pre->union(newClaim) = claims and
            newClaim->one(c |
                c.getDesc() = msg and Set{p} = c.reported->asSet())

    --! openChat doc
    --! @brief Opens the specified chat
    --!
    --! @param Chat c The chat to be opened
    openChat(c: Chat)
    pre playerIsOnline: status = #ONLINE
    pre argIsValid: c <> null
    pre noChatOpen: chatState
        ->select(cs | cs.status = #OPEN)->size() = 0
    post onlySpecifiedChatOpen: chatState
        ->select(cs | cs.status = #OPEN).chatRooms->asSet() = Set{c}

    --! closeChat doc
    --! @brief Closes the currently opened chat
    closeChat()
    pre playerIsOnline: status = #ONLINE
    pre chatOpen: chatState
        ->select(cs | cs.status = #OPEN)->size() = 1
    post chatProperlyClosed:
        let
            openedChat = chatState@pre
                ->select(cs | cs.status = #OPEN).chatRooms->asSet()
        in chatState->one(cs |
            openedChat = cs.chatRooms->asSet() and
            cs.status = #CLOSED and cs.lastOpened.equalsNow())

    -- We don't have state tracking for what match is open or closed yet
    -- Opens the specified match

    --! openMatch doc
    --! @brief Opens the specified match
    --!
    --! @param Match m The match to be opened
    openMatch(m: Match)
    begin

    end
    pre: true
    post: true
    -- #TODO Pre and Post

    --! closeMatch doc
    --! @brief Closes the specified match
    --!
    --! @param Match m The match to be closed
    -- We don't have state tracking for what match is open or closed yet
    -- Closes the specified match
    --kayvia edit 3
    --closeMatch(m: Match) 
    closeMatch(p: Player)
    begin
        declare m: Match, d: DateTime;
        
        
        --delete (p,self) from Block;
        --declare d: Block;
    end
    pre: true
    post: true
    -- #TODO Pre and Post

    --! openApp doc
    --! @brief Executes actions that should occur once the player opens the
    --!        app or logs in
    openApp()
    begin self.status := #ONLINE; end
    pre notOnline: status = #OFFLINE
    post statusUpdated: status = #ONLINE

    --! closeApp doc
    --! @brief Executes actions that should occur once the player closes the
    --!        app or logs out
    closeApp()
    begin self.status := #OFFLINE; end
    pre isNotOffline: status <> #OFFLINE
    post statusUpdated: status = #OFFLINE

    -- #TODO Methods to set the status to away
statemachines
    psm playerStates
    states
        start: initial
        offline [status = #OFFLINE]
        online [status = #ONLINE]
        away [status = #AWAY]
        playing [status = #PLAYING]
        banned: final [status = #BANNED]
    transitions
        start -> offline {create}

        offline -> online {openApp()}
        offline -> banned

        online -> offline {closeApp()}
        online -> playing
        online -> away
        online -> banned

        away -> online
        away -> offline {closeApp()}
        away -> playing
        away -> banned

        playing -> online
        playing -> offline {closeApp()}
        playing -> away
        playing -> banned
    end
end -- Player Class

class Message < Identifiable
attributes
    status: MessageStatus init: #UNSEEN
    message: String
    sentDate: DateTime
    seenDate: DateTime
operations
    --! getBody doc
    --! @brief Returns the body/contents of the message
    --!
    --! @return String
    getBody(): String = message

    --! view doc
    --! @brief Sets the message status to SEEN
    view()
    begin
        self.status := #SEEN;
        self.seenDate := new DateTime();
        insert (self.seenDate, self.sentDate.now) into CurrentTime;
        self.seenDate.setToNow();
    end

    pre msgUnseen: status = #UNSEEN
    post statusUpdated: status = #SEEN
statemachines
    psm msgStates
    states
        unseen: initial [status = #UNSEEN]
        seen: final [status = #SEEN]
    transitions
        unseen -> seen {view()}
    end
end -- Message Class

class Notification
attributes
    deliverytime: DateTime
    dismissed: Boolean init: false
operations
    --! dismiss doc
    --! @brief Marks the notification as dismissed
    dismiss()
    begin
        self.dismissed := true;
    end
    --kayvia edit 4
    pre checkNotDismissed: self.dismissed <> true
    post isDismissed: self.dismissed = true
    -- #TODO Pre and Post
    --pre :
    --post :

    --! gotoAndDismiss doc
    --! @brief Opens the app to the relevant view then dismisses the
    --!        notification
    gotoAndDismiss()
    pre : true
    post : true
    -- #TODO Pre and Post

    --! gotoChatHelper doc
    --! @brief gotoAndDismiss helper for chat event notifications
    gotoChatHelper()
    pre : true
    post : true    
    -- #TODO Pre and Post

    --! gotoMatchHelper doc
    --! @brief gotoAndDismiss helper for match event notifications
    gotoMatchHelper()
    pre : true
    post : true   
    -- #TODO Pre and Post

    --! gotoRequestHelper doc
    --! @brief gotoAndDismiss helper for request event notifications
    gotoRequestHelper()
    pre : true
    post : true   
    -- #TODO Pre and Post

    --! gotoReportHelper doc
    --! @brief gotoAndDismiss helper for report event notifications
    gotoReportHelper()
    pre : true
    post : true    
    -- #TODO Pre and Post
statemachines
    psm notificationStates
    states
        unseen: initial [dismissed = false]
        seen: final [dismissed = true]
    transitions
        unseen -> seen {dismiss()}
    end
end

class Chat < Observable
operations
    --! createMessage doc
    --! @brief Creates a new message in the chat
    --!
    --! @param Player sender The player sending the message
    --! @param String msg The message to be sent
    createMessage(sender: Player, msg: String)
    pre isOpen: chatState.status->includes(#OPEN)
    pre argIsValid: sender <> null and msg.size() > 0
    post msgCreated:
        let
            newMsg = messages->last()
        in newMsg.oclIsNew() and
            messages@pre->including(newMsg) = messages and
            newMsg.getBody() = msg and
            newMsg.sentDate.equalsNow()

    --! view doc
    --! @brief Marks all the newest received messages as seen and dismissed
    --!        any linked notifications that have not been dismissed
    --!
    --! @param Player p The player trying to view the messages
    view(p: Player)
    --begin
    --    msgs := messages->select(m | m.status = #UNSEEN and m.msgSender <> p);
    --    for m in msgs do
    --        m.view();
    --    end;
    --end

    pre isOpen: chatState->one(cs |
        cs.participants->includesAll(Set{p}) and cs.status = #OPEN)
    pre argIsValid: p <> null
    post noUnseenMsgs: not messages->exists(m |
        m.status = #UNSEEN and m.msgSender <> p)
end -- Chat Class

associationclass ChatState
between
    Chat[*] role chatRooms
    Player[2] role participants
attributes
    status: ChatStatus init: #CLOSED
    lastOpened: DateTime
operations
    --! setOpen doc
    --! @brief Sets the chat state to #OPEN
    setOpen()
    -- view all unseen messages and set ChatStatus to OPEN
    pre notOpen: status = #CLOSED
    post openned: status = #OPEN
    post latestMsgSeen: not chatRooms.messages->exists(m |
        m.status = #UNSEEN and participants->excludes(m.msgSender))

    --! setClosed doc
    --! @brief Sets the chat state to #CLOSED
    setClosed()
    -- set lastOpened date and set ChatStatus to CLOSED
    pre openned: status = #OPEN
    post closed: status = #CLOSED
    post lastOpenedSet: lastOpened.equalsNow()
end -- End ChatState Association Class

class Request < Identifiable, Observable
attributes
    status: RequestStatus init: #PENDING
    sentDate: DateTime
    activePeriod: Period
    type: RequestType
operations
    --! accept doc
    --! @brief Mark the request as accepted
    accept()
    begin
        declare d: DateTime;
        self.status := #ACCEPTED;

        d := new DateTime();
        insert (d, self.sentDate.now) into CurrentTime;
        d.setToNow();

        self.activePeriod := new Period();
        self.activePeriod.addStart(d);
    end

    pre isPending: status = #PENDING
    post statusUpdated: status = #ACCEPTED
    post periodActivated: activePeriod.getStart().equalsNow() and
        activePeriod.getEnd() = null

    --! reject doc
    --! @brief Mark the request as rejected
    reject()
    begin self.status := #REJECTED; end
    pre isPending: status = #PENDING
    post statusUpdated: status = #REJECTED
    post notActivated: activePeriod = null

    --! recind doc
    --! @brief Mark the request as recinded
    recind()
    begin
        declare d: DateTime;
        self.status := #RECINDED;

        d := new DateTime();
        insert (d, self.sentDate.now) into CurrentTime;
        d.setToNow();

        self.activePeriod.addEnd(d);
    end

    pre isAccepted: status = #ACCEPTED
    post statusUpdated: status = #RECINDED
    post periodDeactivated: activePeriod.getEnd().equalsNow()

    --! block doc
    --! @brief Mark the request as lost
    block()
    begin self.status := #LOST; end
    pre isPending: status = #PENDING
    post statusUpdated: status = #LOST
    post notActivated: activePeriod = null
statemachines
    psm requestStates
    states
        start: initial
        pending [status = #PENDING]
        accepted [status = #ACCEPTED]
        rejected: final [status = #REJECTED]
        recinded: final [status = #RECINDED]
        lost: final [status = #LOST]
    transitions
        start -> pending {create}
        pending -> accepted {accept()}
        pending -> rejected {reject()}
        pending -> lost {block()}
        accepted -> recinded {recind()}
    end
end -- Request Class

class MatchRequest < Request
attributes
    matchType: MatchType
    timed: Boolean
operations
    --! accept doc
    --! @brief Mark the request as accepted and creates a new match
    accept()
    pre isPending: status = #PENDING
    post statusUpdated: status = #ACCEPTED
    post newMatchCreated: match->size() = 1
end -- MatchRequest Class

associationclass Block
between
    Player[*] role player
    Player[*] role blocked
attributes
    date: DateTime
    status: BlockStatus init: #BLOCKED
operations
    --! block doc
    --! @brief Mark a player as blocked
    --! 
    --! @param Player p1 The player that is blocking another player
    --! @param Player p2 The player that will be blocked by a player
    --kayvia edit 5
    block(p: Player)
    begin
        --self.status = #BLOCKED; --is this needed if default is Blocked?
    end
    post: true
    pre: self.status = #UNBLOCKED

    --! changeBlockDate doc
    --! @brief Mark a player as blocked
    --! 
    --! @param Player p1 The player that is blocking another player
    --! @param Player p2 The player that will be blocked by a player






end -- Block Association Class


class Report < Observable
attributes
    type: ReportType
    status: ReportStatus init: #UNRESOLVED
    description: String
operations
    --! init doc
    --! @brief Initializes the report
    --! @param ReportType repType The type of report to be made
    --! @param String desc A description of the bug/reason for reporting a
    --!                    player
    --! @param Player p The player to be reported
    init(repType: ReportType, desc: String, p: Player)
    pre argsAreValid: repType <> null and desc.size() > 0 and
        ((repType = #PLAYER and p <> null) or
        (repType <> #PLAYER and p = null))
    post initSuccess: type = repType and description = desc and
        reported = p and status = #UNRESOLVED

    --! getStatus doc
    --! @brief Returns the status of the report
    --!
    --! @return ReportStatus
    getStatus(): ReportStatus = status

    --! getDesc doc
    --! @brief Returns the description of the report
    --!
    --! @return String
    getDesc(): String = description
statemachines
    psm reportStates
    states
        unresolved: initial [status = #UNRESOLVED]
        underReview [status = #UNDER_REVIEW]
        resolved: final [status = #RESOLVED]
    transitions
        unresolved -> underReview
        underReview -> resolved
    end
end -- Report Class

-------------------------------------Game-------------------------------------

class Queue < Observable
operations
    --! matchmaking doc
    --! @brief Creates matches between players
    matchmaking()
    -- I'm thinking of having the method be recursive to allow it to loop
    -- until all players
    -- I'm also thinking of just having it be called at the start of the
    -- system and running for the lifetime of the system
    pre playersInQueue: not players->isEmpty()
    --post: check that the queue is empty or the remaining players are
    -- unmatchable
end -- Queue Class

associationclass Join
between
    Queue[*] role queues
    Player[*] role players
attributes
    matchType: MatchType
    timed: Boolean
    joinedAt: DateTime
operations
    --
end -- Join Association Class

associationclass Rack
between
    Player[2] role players
    Match[*] role matchHistory ordered
operations
    --! triggerPlay doc
    --! @brief starts the process of making a play
    triggerPlay(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile))
    -- Essentially a wrapper for the play method in match
    pre playerIsInGame: players.status = #PLAYING
    pre argsAreValid: Set{sRow, sCol, dir}->excludes(null) and
        tileSeq->size() > 0 and tiles->includesAll(tileSeq)
    post tilesRemoved: tiles->excludesAll(tileSeq)

    --! triggerPass doc
    --! @brief Starts the process of passing a turn
    triggerPass()
    pre playerIsInGame: players.status = #PLAYING
    post: true

    --! triggerQuit
    --! @brief Starts the process of forfeiting the game
    triggerQuit()
    pre playerIsInGame: players.status = #PLAYING
    post: true
end -- Rack Association Class

class Play < Identifiable
attributes
    type: PlayType
    -- The main word is the word in the same row/column where the tiles were
    -- placed. The main word does not have to start where the first tile
    -- was placed
    startRow: Integer -- row of the first letter of the main word
    startCol: Integer -- column of the first letter of the main word
    direction: PlayDirection
    score: Integer derived = calcScore()
    time: DateTime
    multiplier: Real derived = calcMultiplier()
operations
    --! init doc
    --! @brief Initializes the play
    --!
    --! The main word of a play is the word that lies in the same row/column
    --! as all the tiles places on the board for that play
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param OrderedSet(Tile) tileSeq The set of tiles to be used to make
    --!                                 the play
    --! @param PlayType t The type of play being made
    init(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile), t: PlayType)
    -- Essentially a wrapper for the executePlay method in match
    pre argsAreValid: t = #PLAY implies
        Set{sRow, sCol, dir}->excludes(null) and tileSeq->size() > 0
    post attributesSet: startRow = sRow and startCol = sCol and
        direction = dir and type = t and time <> null and
        time.equalsNow()

    --! calcScore doc
    --! @brief Calculates the points accumulated by the placement of the tiles
    --!        on the board
    --!
    --! @return Integer
    calcScore(): Integer =
        let
            activeTiles = rack.tiles->union(match.board.slots.tile)->asSet(),
            flatScore = words->iterate(w; ans:Integer = 0 |
                    ans + w.letters->iterate(l; ws:Integer = 0 |
                        ws + activeTiles
                            ->any(t | t.letter.letter = l.letter).points
                    )
                )
        in (flatScore * multiplier).floor
    pre isAPlay: type = #PLAY
    post: true

    --! calcMultiplier doc
    --! @brief Determines the score multiplier for the play
    --!
    --! @return Real
    calcMultiplier(): Real =
        if words.category->excluding(#NONE)
        ->includes(match.category) then
            1.5
        else
            1
        endif
    pre isAPlay: type = #PLAY
    post: true
end -- Play Class

class Board
end -- Board Class

class Slot
attributes
    filledAt: DateTime
operations
    --! getTile doc
    --! @brief Returns the tile in the slot
    --!
    --! @return Tile
    getTile(): Tile = tile

    --! getTileString doc
    --! @brief Returns the letter on the tile in the slot as a string
    --!
    --! @return String
    getTileString(): String = getTile().getLetterString()

    --! fill doc
    --! @brief Places a Tile into the slot
    --!
    --! @param Tile t The tile to be placed in the slot
    fill(t: Tile)
    -- #TODO Pre and Post

    --! isEmpty doc
    --! @brief Returns true if the slot does not contain a tile
    --! @return Boolean
    isEmpty(): Boolean = tile->isEmpty()
end -- Slot Class

class Tile
attributes
    points: Integer
operations
    --! getLetter doc
    --! @brief Returns the letter on the Tile
    --!
    --! @return Letter
    getLetter(): Letter = letter

    --! getLetterString doc
    --! @brief Returns the letter on the Tile as a string
    --!
    --! @return String
    getLetterString(): String = getLetter().getLetter()

    --! getPoints doc
    --! @brief Returns the point value of the Tile
    --!
    --! @return Integer
    getPoints(): Integer = points
statemachines
    psm placementState
    states
        start: initial
        bag [tileBag <> null and rack = null and slot = null]
        rack [tileBag = null and rack <> null and slot = null]
        board: final [tileBag = null and rack = null and slot <> null]
    transitions
        start -> bag {create}
        bag -> rack
        rack -> board
    end
end -- Tile Class

class Letter
attributes
    letter: String
operations
    --! getLetter doc
    --! @brief Returns the string value of the letter
    --!
    --! @return String
    getLetter(): String = letter

    --! equals doc
    --! @brief Returns true if the string value of both letters is the same
    --!
    --! @return Boolean
    equals(l: Letter): Boolean = (getLetter() = l.getLetter())
    pre argIsValid: l <> null
end -- Letter Class

class TileBag
operations
    --! init doc
    --! @brief Fills the tile bag with the tiles to be used for the match
    --!
    --! Calls a method in the Tile factory to create all the letters for the
    --! match
    init()
    -- #TODO Pre and Post

    --! remove doc
    --! @brief Randomly picks a tile from the bag
    remove()
    -- #TODO Pre and Post
end -- TileBag Class

class Word
attributes
    String: Word
    category: Category init: #NONE
    status: WordStatus init: #VALID
operations
    --! getWord doc
    --! @brief Returns a String that represents the word
    --!
    --! @return String
    getWord(): String = letters->iterate(l; ans: String = '' |
        ans + l.getLetter())

    --! equals doc
    --! @brief Returns true if the string values of both words is equal
    --!        (ignoring the case of the characters)
    --!
    --! @param String ws The string to compare the string form of the word to
    --! @return Boolean
    equals(ws: String): Boolean = getWord().equalsIgnoreCase(ws)
    pre argIsValid: ws <> null

    --! createWord doc
    --! @brief Creates a word using letters
    --!
    --! @return 
    --createWord()



    --protected setters
end -- Word Class

class Dictionary
operations
    --! lookup doc
    --! @brief Searches for the word that matches the arguement passed and
    --!        returns it, returns null otherwise
    --!
    --! @param String ws The word to be searched for in the dictionary
    --! @return Word
    lookup(ws: String): Word = words->any(w | w.equals(ws))
    pre argIsValid: ws <> null

    --protected setters
end -- Dictionary Class

class Match < Identifiable, Observable
attributes
    type: MatchType
    timed: Boolean
    duration: Period
    category: Category
    status: MatchStatus init: #INPROGRESS
    score: Integer derived = updateSlider()
operations
    --! init doc
    --! @brief Initializes the match
    --!
    --! Sets all the attributes of the match and creates the board
    --!
    --! @param MatchType matchType The type of match to be created
    --! @param Boolean matchTimed Whether the match is timed or not
    --! @param Category cat The special category to be applied
    init(matchType: MatchType, matchTimed: Boolean, cat: Category)
    pre argsAreValid: matchType <> null and matchTimed <> null and
        (matchType = #RANKED implies matchTimed) and cat <> null
    post isInitialised: type = matchType and timed = matchTimed and
        category = cat and status = #INPROGRESS and score = 0 and
        duration.getStart().equalsNow()

    --getters

    --! updateSlider doc
    --! @brief Updates the position of the slider
    --!
    --! @return Integer
    updateSlider(): Integer =
    playHistory->iterate(p; ans: Integer = 0 |
        if playHistory->indexOf(p).mod(2) = 1 then
            ans + p.score
        else
            ans - p.score
        endif)

    --! update doc
    --! @brief This is the method called by the observable to update the
    --!        Observer
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    -- #TODO Pre and Post

    --! updateHelperPlay doc
    --!
    --! Checks if the player is currently has the match open and creates a
    --! notification if they don't or signals to the players that the match
    --! is complete
    --!
    --! @param Play o The play that called the update method
    updateHelperPlay(o: Play)
    -- #TODO Pre and Post

    --! executePass doc
    --! @brief Creates a play with type pass
    --!
    --! @param Rack r The rack that triggered the Pass
    executePass(r: Rack)
    pre argIsValid: r <> null
    post playMade:
            let
                lp = playHistory->last()
            in lp.type = #PASS and lp.time.equalsNow() and
                playHistory@pre->including(lp) = playHistory and
                lp.oclIsNew()

    --! executeQuit doc
    --! @brief Creates a play with type quit
    --!
    --! @param Rack r The rack that triggered the Quit
    executeQuit(r: Rack)
    pre argIsValid: r <> null
    post playMade:
            let
                lp = playHistory->last()
            in lp.type = #QUIT and lp.time.equalsNow() and
                playHistory@pre->including(lp) = playHistory and
                lp.oclIsNew()

    --! executePlay doc
    --! @brief Places the tiles on the board
    --!
    --! @param Rack r The rack that triggered the Play
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param OrderedSet(Tile) tileSeq The set of tiles to be used to make
    --!                                 the play
    executePlay(r: Rack, sRow: Integer, sCol: Integer, dir: PlayDirection,
    tileSeq: OrderedSet(Tile))
    pre playIsValid: playHelperIsPlayValid(sRow, sCol, dir, tileSeq->size())
    post playMade:
            let
                lp = playHistory->last()
            in lp.type = #PLAY and lp.time.equalsNow() and
                playHistory@pre->including(lp) = playHistory and
                lp.oclIsNew()
    post tilesPlaced:
        if dir = #HORIZONTAL then
            Sequence{sCol..15}->iterate(c; ans: Set(Tile) = Set{} |
                ans->including(board.slots[sRow, c].getTile())
            )->includesAll(tileSeq)
        else --if dir = #VERTICAL then
            Sequence{sRow..15}->iterate(r; ans: Set(Tile) = Set{} |
                ans->including(board.slots[r, sCol].getTile())
            )->includesAll(tileSeq)
        endif

    --! playHelperAllTilesFit doc
    --! @brief Returns true if all the tiles to be used will occupy a space in
    --!        the row/column within the bounds of the start of the play and
    --!        the end of the board
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param Integer tcnt The number of tiles to be placed
    --! @return Boolean
    playHelperAllTilesFit(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        if dir = #HORIZONTAL then
            Sequence{sCol..15}->iterate(c; ans: Integer = 0 |
                if board.slots[sRow, c].isEmpty() then
                    ans + 1
                else ans endif
            ) >= tcnt
        else --if dir = #VERTICAL then
            Sequence{sRow..15}->iterate(r; ans: Integer = 0 |
                if board.slots[r, sCol].isEmpty() then
                    ans + 1
                else ans endif
            ) >= tcnt
        endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol, tcnt}) and
        dir <> null

    --! playHelperPlayIntersects doc
    --! @brief Returns true if the play intersects with a word on the board
    --!
    --! A play intersects with a word if there is an existing word
    --! intersecting with the tiles placed
    --!
    --! @param Integer sRow The row where the main word of the play starts
    --! @param Integer sCol The column where the main word of the play starts
    --! @param PlayDirection dir The direction in which the main word is spelt
    --! @param Integer tcnt The number of tiles to be placed
    --! @return Boolean
    playHelperPlayIntersects(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        if dir = #HORIZONTAL then
            Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                ans or
                (board.slots[sRow, sCol + o - 1].isEmpty() implies
                    (not Set{board.slots[sRow - 1, sCol + o - 1].tile,
                    board.slots[sRow + 1, sCol + o - 1].tile}->isEmpty()))
            ) or board.slots[sRow, sCol + tcnt].tile <> null
        else --if dir = #VERTICAL then
            Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                ans or
                (board.slots[sRow + o - 1, sCol].isEmpty() implies
                    (not Set{board.slots[sRow + o - 1, sCol - 1].tile,
                    board.slots[sRow + o - 1, sCol + 1].tile}->isEmpty()))
            ) or board.slots[sRow + tcnt, sCol].tile <> null
        endif
    pre argsAreValid: Sequence{1..15}->includesAll(Set{sRow, sCol, tcnt}) and
        dir <> null

    --! playHelperIsPlayValid doc
    --! @brief Returns true if the play is valid
    --!
    --! A play is valid if all the tiles fit within the bounds of the play and
    --! there is an existing word intersecting with the tiles placed
    --!
    --! @return Boolean
    playHelperIsPlayValid(sRow: Integer, sCol: Integer, dir: PlayDirection,
    tcnt: Integer): Boolean =
        playHelperAllTilesFit(sRow, sCol, dir, tcnt) and
        ((playHistory->size() > 0 and
            playHelperPlayIntersects(sRow, sCol, dir, tcnt)) or
        (playHistory->size() = 0 and sRow = 8 and sCol = 8 and
                dir <> null and tcnt > 0))
statemachines
    psm matchStates
    states
        start: initial
        inprogress [status = #INPROGRESS]
        completed: final [status = #COMPLETE]
        abandoned: final [status = #ABANDONED]
    transitions
        start -> inprogress {create}
        inprogress -> completed
        inprogress -> abandoned
    end
end -- Match Class

class Leaderboard < Observer
operations
    --getters

    --! update doc
    --! @brief This is the method called by the observable to update the
    --!        Observer
    --!
    --! @param Observable o The observable that called the method
    update(o: Observable)
    -- #TODO Pre and Post

    --! updateHelperMatch doc
    --! @brief Updates the players' ranks once a ranked match is complete
    --!
    --! @param Match o The match that called the method
    updateHelperMatch(o: Match)
    -- #TODO Pre and Post
end -- Leaderboard Class

associationclass Rank
between
    Leaderboard[1]
    Player[*] role players ordered
attributes
    placement: Integer
operations
    --! getRank doc
    --! @brief Returns the rank as an integer
    --!
    --! @return Integer
    getRank(): Integer = placement
end -- Rank Association Class

------------------------------------------------------------------------------
-- Associations
------------------------------------------------------------------------------

-----------------------------Pattern and Datatype-----------------------------

association Watches between
    Observer[*]
    Observable[*]
end -- Watches Association

association CurrentTime between
    DateTime[*]
    DateTime[1] role now
end -- CurrentTime Association

association PeriodInterval between
    Period[*]
    DateTime[0..2] role interval ordered
end -- PeriodInterval Association

association OnlyLboard between
    Leaderboard[1] role lboard1
    Leaderboard[1] role lboard2
end -- OnlyLboard Association

association OnlyDict between
    Dictionary[1] role dict1
    Dictionary[1] role dict2
end -- OnlyDict Association

---------------------------------Domain Level---------------------------------

association ScrumbleUsers between
    Scrumble[1]
    User[*] role users
end -- ScrumbleUsers Association

association ScrumbleMatches between
    Scrumble[1]
    Match[*] role matches
end -- ScrumbleMatches Association

association ScrumbleDict between
    Scrumble[1]
    Dictionary[1]
end -- ScrumbleDict Association

association ScrumbleLboard between
    Scrumble[1]
    Leaderboard[1]
end -- ScrumbleLboard Association

--------------------------------------ACL-------------------------------------

association UserRole between
    User[1]
    Role[1]
end -- UserRole Association

association RolePerms between
    Role[1]
    Permission[*] role permissions
end -- RolePerms Association

------------------------------Player Interactions-----------------------------

association Signal between
    Notification[*] role notifs
    Observable[1] role event
end -- Signal Association

association Notify between
    Notification[*] role notifs
    Player[1]
end -- Signals Association

association FriendList between
    Player[1] role friend
    Player[*] role friends
end -- Friend Association

composition PlayerChat between
    Chat[1] role chat
    Message[*] role messages ordered
end -- End PlayerChat Composition

association SentRequest between
    Player[1] role reqSender
    Request[*] role sentReqs
end -- End SentRequest Association

association RecievedRequest between
    Player[1] role reqRcvr
    Request[*] role rcvdReqs
end -- End RecievedRequest Association

association RequestMatch between
    MatchRequest[1] role matchReq
    Match[0..1]
end -- End RequestMatch Association

association SentMessage between
    Player[1] role msgSender
    Message[*] role sentMsgs
end -- End SentMessage Association

association RecievedMessage between
    Player[1] role msgRcvr
    Message[*] role rcvdMsgs
end -- End RecievedMessage Association

association Claim between
    Player[1]
    Report[*] role claims
end -- Claim Association

association Reported between
    Report[*] role reports
    Player[0..1] role reported --directed
end -- Reported Association

-------------------------------------Game-------------------------------------

association MatchGameBoard between
    Match[1]
    Board[1]
end -- End MatchGameBoard Association

composition Grid between
    Board[1] qualifier (row: Integer, col: Integer)
    Slot[1] role slots
end -- End Grid Composition

aggregation Fill between
    Slot[0..1]
    Tile[0..1]
end -- End Fill Aggregation

association LetterOptions between
    TileBag[1]
    Board[1]
end -- End LetterOptions Association

aggregation Stock between
    TileBag[0..1]
    Tile[*] role tiles
end -- End Stock Aggregation

association WordCheck between
    Match[*] role matches
    Dictionary[1]
end -- End WordCheck Association

association ValidWord between
    Dictionary[1]
    Word[*] role words
end -- End ValidWord Association

association Spelling between
    Word[*] role words
    Letter[*] role letters ordered
end -- End Spelling Association

association Spelt between
    Play[*] role plays
    Word[*] role words
end -- End Spelt Association

association Plays between
    Match[1]
    Play[*] role playHistory ordered
end -- End Plays Association

aggregation Hold between
    Rack[0..1]
    Tile[0..9] role tiles
end -- End Hold Aggregation

association Played between
    Rack[1]
    Play[*] role plays
end -- End Played Association

association Use between
    Play[0..1]
    Tile[0..9] role tiles ordered
end -- End Use Association

association Mark between
    Tile[*] role tiles
    Letter[1]
end -- End Mark Association

------------------------------------------------------------------------------
-- Constraints
------------------------------------------------------------------------------

constraints
---------------------------------Domain Level---------------------------------

context Scrumble
    -- Each Player has a unique username
    inv uniqueUsernames: users.role
        ->select(r | r.oclIsTypeOf(Player))
        ->isUnique(p | p.oclAsType(Player).username)
-- End Scrumble Constraints

-------------------------------Abstract Classes-------------------------------

context Identifiable
    -- Each item has a unique id
    inv uniqueIDs: Identifiable.allInstances.isUnique(i | i.id)
        --ids->forAll(i1, i2 | i1 <> i2 implies i1.id <> i2.id)
-- End Identifiable Constraints

--context Observer
--    -- Objects cannot observe themselves
--    inv noSelfObserving: observable->excludes(self)
---- End Observer Constraints

-----------------------------------Datatype-----------------------------------

context DateTime
    inv dateIsValid: isSelfValid()

    -- There must only be one "today" in the system
    inv onlyOneCurrentTime:
        DateTime.allInstances.now->asSet()->excluding(null)->size() = 1
-- End DateTime Constraints

context Period
    -- All Periods are valid
    inv allPeriodsAreValid: isSelfValid()
-- End Period Constraints

------------------------------Player Interactions-----------------------------

context Player
    -- Matches must be ordered
    inv matchesAreOrdered: matchHistory->forAll(m |
        let
            i = matchHistory->indexOf(m),
            prevMatches = matchHistory->subOrderedSet(1, i - 1)
        in matchHistory->first() <> m implies
            prevMatches->forAll(prevM |
                prevM.duration.getStart().before(m.duration.getStart())
            )
    )

    -- For each type of request, ther can only be one pending request between
    -- each unique pair of players.
    inv onlyOnePendingReqPerPlayerPair:
        let
            pending = sentReqs->select(req | req.status = #PENDING)
                ->union(rcvdReqs->select(req | req.status = #PENDING))
        in pending->forAll(r1, r2 |
            (r1 <> r2 and r1.type = r2.type) implies (
                (r1.reqSender <> r2.reqSender and r1.reqRcvr <> r2.reqRcvr) or
                (r1.reqSender <> r2.reqRcvr and r1.reqSender <> r2.reqRcvr))
        )

    -- Blocked players can't be your friends
    inv notFriendAndBlocked:
        let
            allReqs = sentReqs->union(rcvdReqs),
            acceptedFrReqs = allReqs->select(req | req.type = #FRIEND and
                req.status = #ACCEPTED),
            friends = acceptedFrReqs.reqSender->union(acceptedFrReqs.reqRcvr)
                ->asSet()->excluding(self),
            blockedLst = block[player]
                ->select(b | b.status = #BLOCKED).blocked
        in friends->excludesAll(blocked)

    -- Cannot send requests to yourself
    inv noSelfReqsBlocks: sentReqs.reqRcvr->excludes(self) and
        blocked->excludes(self)

    -- All pending requests from players you block become lost and requests
    -- sent to them become recinded
    inv noPendingReqsWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not sentReqs->union(rcvdReqs)->exists(req |
                Set{req.reqSender, req.reqRcvr}->includes(b.blocked) and
                req.status = #PENDING))

    -- Players must not encounter players they have blocked in any match
    inv noMatchesWithBlockedPlayers:
        block[player]->select(b | b.status = #BLOCKED)->forAll(b |
            not matchHistory->exists(m |
                m.players->includes(b.blocked) and
                m.duration.getStart().after(b.date))
        )

    -- There must not be any pending friend or message requests between a
    -- given pair of players if there exists an accepted request of the same
    -- type between them
    inv noPendingFriendOrMsgReqsIfAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type)),
            pending = frAndMsgReqs->select(req | req.status = #PENDING),
            accepted = frAndMsgReqs->select(req | req.status = #ACCEPTED)
        in pending->forAll(p | accepted->forAll(a |
            p.type = a.type implies
                (Set{p.reqSender, p.reqRcvr} -
                    Set{a.reqSender, a.reqRcvr})->size() > 0
        ))

    -- For a given pair or players, there may not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv noActiveMsgReqIfFriendReqAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                req.status = #ACCEPTED),
            msgReqs = allReqs->select(req | req.type = #MESSAGE and
                Set{#PENDING, #ACCEPTED}->includes(req.status))
        in frReqs->forAll(f | not msgReqs->exists(m |
            Set{f.reqSender, f.reqRcvr} = Set{m.reqSender, m.reqRcvr}
        ))

    -- For a given pair or players, there must not be any pending or accepted
    -- message requests between them if there exists an accepted friend
    -- request between them
    inv onlyOneAcceptedMsgOrFriendReqPerPair:
        let
            acceptedReqs = sentReqs->union(rcvdReqs)->select(req |
                req.status = #ACCEPTED and
                Set{#FRIEND,#MESSAGE}->includes(req.type))
        in acceptedReqs->forAll(a1 | not acceptedReqs->exists(a2 |
            a1 <> a2 and a1.type = a2.type and
                Set{a1.reqSender, a1.reqRcvr} = Set{a2.reqSender, a2.reqRcvr}
        ))

    -- Can only exchange match requests among friends
    inv onlyFriendsExchangeMatchReqs:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frReqs = allReqs->select(req | req.type = #FRIEND and
                Set{#ACCEPTED, #RECINDED}->includes(req.status)),
            matchReqs = allReqs->select(req | req.type = #MATCH)
        in matchReqs->forAll(mr | frReqs->exists(fr |
            Set{fr.reqSender, fr.reqRcvr} = Set{mr.reqSender, mr.reqRcvr} and
                fr.activePeriod.containsDate(mr.sentDate)
        ))

        -- Players may only have one chat open at a time
        inv noOtherChatOpen: chatState
            ->select(cs | cs.status = #OPEN)
            ->size() <= 1

    -- Can only chat if one player has accepted a message or friend request
    -- from the other player
    inv onlyChatIfRequestAccepted:
        let
            allReqs = sentReqs->union(rcvdReqs),
            frAndMsgReqs = allReqs->select(req |
                Set{#FRIEND, #MESSAGE}->includes(req.type) and
                Set{#ACCEPTED, #RECINDED}->includes(req.status))
        in rcvdMsgs->forAll(m | frAndMsgReqs->exists(req |
            Set{req.reqSender, req.reqRcvr} = Set{m.msgSender, m.msgRcvr} and
                req.activePeriod.containsDate(m.sentDate)
        ))

    -- Enforcing this invariant would go against allowing players to go
    -- offline during a match.
    ---- players in match must have status in game
    --inv playerStatusConsistent:
    --    if matchHistory->any(m | m.status = #INPROGRESS) <> null then
    --        status = #PLAYING
    --    else
    --        status <> #PLAYING
    --    endif

    -- Can't play more than one match at a time
    inv onlyPlayingOneOrNoMatches:
        matchHistory->select(m | m.status = #INPROGRESS)->size() <= 1

    -- Players may only join up to one queue at a time
    inv onlyInOneQueue: queues->size() <= 1
-- End Player Constraints

context Chat
    -- Chats can only have 2 participants
    inv onlyTwoParticipants:
        let
            senders = messages.msgSender->asSet(),
            recipients = messages.msgRcvr->asSet()
        in participants->includesAll(senders) and
            participants->includesAll(recipients)

    -- Messages must be ordered
    inv messagesAreOrdered: messages->forAll(m |
        let
            i = messages->indexOf(m),
            previousMsgs = messages->subOrderedSet(1, i - 1)
        in messages->first() <> m implies
            previousMsgs->forAll(prevM | prevM.sentDate.before(m.sentDate)))
-- End Chat Constraints

context ChatState
    -- All messages from the other player before lastOpened date must be seen
    inv onlyMsgsAfterLastOpenedUnseen:
        chatRooms.messages->forAll(m |
            participants->excludes(m.msgSender) implies (
                (m.status = #UNSEEN and m.sentDate.after(lastOpened)) or
                (m.status = #SEEN and (not m.seenDate.after(lastOpened)))
            )
        )

    -- Can't send messages after closing the chat
    inv noSentMsgsAfterChatClosed: status = #CLOSED implies
        (not chatRooms.messages->exists(m |
            participants->includes(m.msgSender) and
            lastOpened.before(m.sentDate)))
-- End ChatState Constraints

context Message
    -- Each message must have a date
    inv hasDate: sentDate.oclIsKindOf(DateTime)

    -- Messages must have a body
    inv noEmptyMsgs: message.size() > 0

    -- Messages may only be seen after they have been sent
    inv validSeenDate: (status = #UNSEEN and seenDate = null) or
        (status = #SEEN and seenDate <> null and seenDate.after(sentDate))
-- End Message Constraints

context Request
    -- Each request must have a sent date
    inv hasSentDate: sentDate.oclIsKindOf(DateTime)

    -- Each accepted request must have an active period that starts after it
    -- was sentand must not have an end date that is set once the request is
    -- recinded
    inv validAcceptedReq: status = #ACCEPTED implies
        (activePeriod <> null and activePeriod.getStart().after(sentDate) and
        activePeriod.getEnd() = null)
-- End Request Constraints

context MatchRequest
    -- All match requests have the type #MATCH
    inv matchReqTypeIsMatchReq: type = #MATCH

    -- Only accepted match requests may refer to a match
    inv noMatchUnlessAccepted:
        if status = #ACCEPTED then
            match->size() = 1
        else
            match->size() = 0
        endif

    -- Players may not request ranked matches
    inv noRankedMatchRequests: matchType <> #RANKED

    -- Accepted match type must match requested match type
    inv matchDataMatchesMatchReqData: status = #ACCEPTED implies
        (matchType = match.type and timed = match.timed and
        activePeriod.getStart() = match.duration.getStart())
-- End MatchRequest Constraints

context Report
    -- Only Player reports may be associated with more than one player
    inv onlyPlayerReportsHave2Players:
        if type = #PLAYER then
            reported->size() = 1
        else
            reported->size() = 0
        endif
-- End Report Constraints

-------------------------------------Game-------------------------------------

context Join
    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: matchType = #RANKED implies timed
-- End Join Constraints

context Rack
    -- No empty spaces unless there are no more tiles in the tileBag
    inv noEmptySpaceUnlessLetterBagEmpty: tiles->size() = 9 or
        (tiles->size() < 9 and matchHistory.board.tileBag.tiles->size() = 0)
-- End Rack Constraints

context Play
    -- Plays must have a direction
    inv hasDirection: direction <> null

    -- Words must intersect or be spelt right alongside existing words
    -- or from the center of the board if all slots are empty
    inv intersectsWithAnotherWord:
        (type = #PLAY and match.playHistory->first() <> self) implies
            (let
                grid = match.board,
                r = startRow,
                c = startCol,
                tcnt = tiles->size()
            in if direction = #HORIZONTAL then
                    Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                        ans or
                        (grid.slots[r, c + o - 1].isEmpty() implies
                            (not Set{grid.slots[r - 1, c + o - 1].tile,
                            grid.slots[r + 1, c + o - 1].tile}->isEmpty()))
                    ) or grid.slots[r, c + tcnt].tile <> null
                else --if direction = #VERTICAL then
                    Sequence{1..tcnt}->iterate(o; ans: Boolean = false |
                        ans or
                        (grid.slots[r + o - 1, c].isEmpty() implies
                            (not Set{grid.slots[r + o - 1, c - 1].tile,
                            grid.slots[r + o - 1, c + 1].tile}->isEmpty()))
                    ) or grid.slots[r + tcnt, c].tile <> null
                endif
            )

    -- Plays do not extend beyond the board
    inv allTilesOnBoard: type = #PLAY implies
        (let
            grid = match.board
        in if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(c; ans: Integer = 0 |
                    if not grid.slots[startRow, c].isEmpty() and
                    grid.slots[startRow, c].filledAt.equals(time) then
                        ans + 1
                    else ans endif
                ) >= tiles->size()
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(r; ans: Integer = 0 |
                    if not grid.slots[r, startCol].isEmpty() and
                    grid.slots[r, startCol].filledAt.equals(time) then
                        ans + 1
                    else ans endif
                ) >= tiles->size()
            endif
        )

    -- Passed plays or match quits cant have any tiles
    inv passAndQuitHaveNoTiles: Set{#PASS, #QUIT}->includes(type) implies
        tiles->isEmpty()

    -- Only valid words may be spelt and only words spelt may be linked to
    -- a play
    inv allWordsSpeltAreValidAndOnlySpeltWordsLinked: type = #PLAY implies
        (let
            grid = match.board,

            -- All the slots that were filled by tiles provided by the rack
            -- this turn
            mainWordSlots = if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(
                c; ans: Sequence(Integer) = Sequence{} |
                    if (not grid.slots[startRow, c].isEmpty()) and
                    grid.slots[startRow, c].filledAt.equals(time) then
                        ans->append(c)
                    else ans endif
                )
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(
                r; ans: Sequence(Integer) = Sequence{} |
                    if (not grid.slots[r, startCol].isEmpty()) and
                    grid.slots[r, startCol].filledAt.equals(time) then
                        ans->append(r)
                    else ans endif
                )
            endif,

            mainWord = if direction = #HORIZONTAL then
                Sequence{startCol..15}->iterate(c; ans: String = '' |
                    let
                        s = grid.slots[startRow, c]
                    in if not s.isEmpty() and
                        ((startCol + ans.size()) = c) then
                            ans + s.getTileString()
                        else ans endif
                )
            else --if direction = #VERTICAL then
                Sequence{startRow..15}->iterate(r; ans: String = '' |
                    let
                        s = grid.slots[r, startCol]
                    in if not s.isEmpty() and
                        ((startRow + ans.size()) = r) then
                            ans + s.getTileString()
                        else ans endif
                )
            endif,

            secondaryWords = if direction = #HORIZONTAL then
                mainWordSlots->iterate(c; ans: Set(String) = Set{} |
                    let
                        word = Sequence{1..(startRow-1)}->reverse()->iterate(
                            r; top: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startRow - top.size()) = r)) then
                                        s.getTileString() + top
                                    else top endif
                            ) +
                            Sequence{startRow..15}->iterate(
                            r; bot: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startRow + bot.size()) = r)) then
                                        bot + s.getTileString()
                                    else bot endif
                            )
                    in if word.size() > 1 then
                            ans->including(word)
                        else ans endif
                )
            else --if direction = #VERTICAL then
                mainWordSlots->iterate(r; ans: Set(String) = Set{} |
                    let
                        word = Sequence{1..(startCol-1)}->reverse()->iterate(
                            c; left: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startCol - left.size()) = c)) then
                                        s.getTileString() + left
                                    else left endif
                            ) +
                            Sequence{startCol..15}->iterate(
                            c; right: String = '' |
                                let
                                    s = grid.slots[r, c]
                                in if ((not s.isEmpty()) and
                                    (not s.filledAt.after(time)) and
                                    ((startCol + right.size()) = c)) then
                                        right + s.getTileString()
                                    else right endif
                            )
                    in if word.size() > 1 then
                            ans->including(word)
                        else ans endif
                )
            endif,

            allSpeltWords = secondaryWords->including(mainWord),

            allValidWords = match.dictionary.words
                ->iterate(w; wSet:Set(String) = Set{} |
                    wSet->including(w.getWord())
                ),

            allLinkedWords = words
                ->iterate(w; wSet:Set(String) = Set{} |
                    wSet->including(w.getWord())
                )
        in allValidWords->includesAll(allSpeltWords) and
            allSpeltWords->includesAll(allLinkedWords)
        )
-- End Play Constraints

context Board
    -- Must have 15 by 15 slots
    inv boardGridIsValid:
        Sequence{1..15}->iterate(r; ans: Set(Slot) = Set{} |
            ans->union(Sequence{1..15}->iterate(c; ans: Set(Slot) = Set{} |
                ans->including(slots[r, c])
            ))
        )->includesAll(slots)
-- End Board Constraints

context Tile
    -- Ensure Tiles have a valid point value
    inv validPoints: points > 0 and points <= 10

    -- Ensure that tiles are held by only one object at a time
    inv onlyInOnePlace:
        Set{tileBag, rack, slot}->excluding(null)->size() = 1
-- End Tile Constraints

context Slot
    -- Each slot must have a filledAt time if not empty
    inv hadFilledAtTimeIfFilled: (isEmpty() and filledAt = null) or
        ((not isEmpty()) and filledAt <> null)
-- End Slot Constraints

context Letter
    -- Ensure that the letter is valid
    inv validLetter: Set{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
        'X', 'Y', 'Z'}->includes(letter)
-- End Letter Constraints

context Dictionary
    -- No duplicate words
    inv uniqueWords: words->forAll(w1, w2 |
            Set{w1.status, w2.status}->excludes(#DEPRECATED) and
            (w1 <> w2 implies (not w1.equals(w2.getWord())))
        )
-- End Dictionary Constraints

context Match
    -- Each match must have a duration
    inv hasDuration: duration.oclIsKindOf(Period)

    -- Only unranked matches may be untimed
    inv noUntimedRankedMatches: type = #RANKED implies timed

    -- Plays must be ordered
    inv playsAreOrdered: playHistory->forAll(p |
        let
            i = playHistory->indexOf(p),
            previousPlays = playHistory->subOrderedSet(1, i - 1)
        in playHistory->first() <> p implies
            previousPlays->forAll(prevP | prevP.time.before(p.time)))

    -- First word must be spelt in the center
    inv firstPlayStartsAtCentre:
        let
            firstPlay = playHistory->first()
        in (firstPlay.startRow = 8 and firstPlay.startCol = 8)

    -- Plays must alternate between players, ie the game should be turn based
    inv playsAlternateBetweenPlayers:
        let
            player1 = playHistory->at(1).rack.players,
            player2 = playHistory->at(2).rack.players
        in playHistory->forAll(p |
            if playHistory->indexOf(p).mod(2) = 1 then
                player1 = p.rack.players
            else
                player2 = p.rack.players
            endif
        )

    -- Ensure all Tiles with the same letter have the same score
    inv consistentTilePointValues:
        let
            bagTiles = board.tileBag.tiles,
            rackTiles = rack.tiles,
            boardTiles = board.slots.tile,
            allTiles = bagTiles->union(rackTiles->union(boardTiles))
                ->excluding(null)
        in allTiles->forAll(t1, t2|
            t1.getLetter().equals(t2.getLetter()) implies
            t1.getPoints() = t2.getPoints())

    -- must be a fixed set of tiles in circulation for a given match
    inv fixedNumberOfLettersInMatch:
        let
            bagLetters = board.tileBag.tiles.letter->asSet(),
            rackLetters = rack.tiles.letter->asSet(),
            boardLetters = board.slots.tile.letter->asSet(),
            allTiles = bagLetters->union(rackLetters->union(boardLetters))
                ->excluding(null),
            count = allTiles->iterate(
                char; cnt:Tuple(a: Integer, b: Integer, c: Integer,
                d: Integer, e: Integer, f: Integer, g: Integer, h: Integer,
                i: Integer, j: Integer, k: Integer, l: Integer, m: Integer,
                n: Integer, o: Integer, p: Integer, q: Integer, r: Integer,
                s: Integer, t: Integer, u: Integer, v: Integer, w: Integer,
                x: Integer, y: Integer, z: Integer) =
                Tuple{a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0,
                h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0,
                p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0,
                x = 0, y = 0, z = 0} |
                    Tuple{
                    a = if char.letter = 'A' then cnt.a + 1 else cnt.a endif,
                    b = if char.letter = 'B' then cnt.b + 1 else cnt.b endif,
                    c = if char.letter = 'C' then cnt.c + 1 else cnt.c endif,
                    d = if char.letter = 'D' then cnt.d + 1 else cnt.d endif,
                    e = if char.letter = 'E' then cnt.e + 1 else cnt.e endif,
                    f = if char.letter = 'F' then cnt.f + 1 else cnt.f endif,
                    g = if char.letter = 'G' then cnt.g + 1 else cnt.g endif,
                    h = if char.letter = 'H' then cnt.h + 1 else cnt.h endif,
                    i = if char.letter = 'I' then cnt.i + 1 else cnt.i endif,
                    j = if char.letter = 'J' then cnt.j + 1 else cnt.j endif,
                    k = if char.letter = 'K' then cnt.k + 1 else cnt.k endif,
                    l = if char.letter = 'L' then cnt.l + 1 else cnt.l endif,
                    m = if char.letter = 'M' then cnt.m + 1 else cnt.m endif,
                    n = if char.letter = 'N' then cnt.n + 1 else cnt.n endif,
                    o = if char.letter = 'O' then cnt.o + 1 else cnt.o endif,
                    p = if char.letter = 'P' then cnt.p + 1 else cnt.p endif,
                    q = if char.letter = 'Q' then cnt.q + 1 else cnt.q endif,
                    r = if char.letter = 'R' then cnt.r + 1 else cnt.r endif,
                    s = if char.letter = 'S' then cnt.s + 1 else cnt.s endif,
                    t = if char.letter = 'T' then cnt.t + 1 else cnt.t endif,
                    u = if char.letter = 'U' then cnt.u + 1 else cnt.u endif,
                    v = if char.letter = 'V' then cnt.v + 1 else cnt.v endif,
                    w = if char.letter = 'W' then cnt.w + 1 else cnt.w endif,
                    x = if char.letter = 'X' then cnt.x + 1 else cnt.x endif,
                    y = if char.letter = 'Y' then cnt.y + 1 else cnt.y endif,
                    z = if char.letter = 'Z' then cnt.z + 1 else cnt.z endif}
                )
        in (count.a = 9 and count.b = 2 and count.c = 2 and count.d = 4 and
            count.e = 12 and count.f = 2 and count.g = 3 and count.h = 2 and
            count.i = 9 and count.j = 1 and count.k = 1 and count.l = 4 and
            count.m = 2 and count.n = 6 and count.o = 8 and count.p = 2 and
            count.q = 1 and count.r = 6 and count.s = 4 and count.t = 6 and
            count.u = 4 and count.v = 2 and count.w = 2 and count.x = 1 and
            count.y = 2 and count.z = 1)

    -- Players must be similar rank
    inv similarRank:
        players.rank->forAll(p1, p2 |
            (type = #RANKED and (p1.placement - p2.placement).abs() <= 100) or
            (matchReq->size() = 0 implies
                (p1.placement - p2.placement).abs() <= 200)
        )

    -- Once a match ends no additional plays can be made
    inv allPlaysWithinMatchDuration: playHistory->forAll(p |
        duration.containsDate(p.time))

    -- Ensures that the end date for a match corresponds with the final play
    -- if the match is finished or that there is no end date if the match is
    -- still going
    inv matchEndValid:
        let
            lp = playHistory->last(),
            dur = duration.duration()
        in (Set{#COMPLETE, #ABANDONED}->excludes(status) and
                duration.getEnd() = null) or
            (duration.getEnd() = lp.time and
                ((status = #ABANDONED and lp.type = #QUIT) or
                (status = #COMPLETE and
                    (score.abs() >= 100 or
                    (timed and dur > 0 and dur < 300))) --5 min
                )
            )

    -- Checks that no matches last longer than 30 days
    inv untimedMatchesHaveValidDurations:
        (not timed) implies duration.durationInDays() <= 30
-- End Match Constraints

context Leaderboard
    -- All ranks are ordered
    inv ranksAreAccurateAndOrdered:
        rank->forAll(r |
            let
                i = rank->indexOf(r),
                higherRanks = rank->subOrderedSet(1, i - 1)
            in rank->first() <> r implies
                higherRanks->forAll(upperR |
                    (upperR.placement < r.placement and
                        upperR.players.score > r.players.score) or
                    (upperR.placement = r.placement and
                        upperR.players.score = r.players.score)
                ) and
                higherRanks.placement->asSet()->excludes(r.placement) implies
                    r.placement = i
        )
-- End Leaderboard Constraints

-- End All Constraints
